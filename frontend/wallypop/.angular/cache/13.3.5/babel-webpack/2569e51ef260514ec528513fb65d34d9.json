{"ast":null,"code":"/*\n Highcharts JS v8.2.2 (2020-10-22)\n\n (c) 2009-2018 Torstein Honsi\n\n License: www.highcharts.com/license\n*/\n(function (c) {\n  \"object\" === typeof module && module.exports ? (c[\"default\"] = c, module.exports = c) : \"function\" === typeof define && define.amd ? define(\"highcharts/highcharts-more\", [\"highcharts\"], function (A) {\n    c(A);\n    c.Highcharts = A;\n    return c;\n  }) : c(\"undefined\" !== typeof Highcharts ? Highcharts : void 0);\n})(function (c) {\n  function A(c, b, h, a) {\n    c.hasOwnProperty(b) || (c[b] = a.apply(null, h));\n  }\n\n  c = c ? c._modules : {};\n  A(c, \"Extensions/Pane.js\", [c[\"Core/Chart/Chart.js\"], c[\"Core/Globals.js\"], c[\"Core/Pointer.js\"], c[\"Core/Utilities.js\"], c[\"Mixins/CenteredSeries.js\"]], function (c, b, h, a, f) {\n    function q(e, f, m) {\n      return Math.sqrt(Math.pow(e - m[0], 2) + Math.pow(f - m[1], 2)) <= m[2] / 2;\n    }\n\n    var u = a.addEvent,\n        z = a.extend,\n        E = a.merge,\n        B = a.pick,\n        e = a.splat;\n    c.prototype.collectionsWithUpdate.push(\"pane\");\n\n    a = function () {\n      function b(e, m) {\n        this.options = this.chart = this.center = this.background = void 0;\n        this.coll = \"pane\";\n        this.defaultOptions = {\n          center: [\"50%\", \"50%\"],\n          size: \"85%\",\n          innerSize: \"0%\",\n          startAngle: 0\n        };\n        this.defaultBackgroundOptions = {\n          shape: \"circle\",\n          borderWidth: 1,\n          borderColor: \"#cccccc\",\n          backgroundColor: {\n            linearGradient: {\n              x1: 0,\n              y1: 0,\n              x2: 0,\n              y2: 1\n            },\n            stops: [[0, \"#ffffff\"], [1, \"#e6e6e6\"]]\n          },\n          from: -Number.MAX_VALUE,\n          innerRadius: 0,\n          to: Number.MAX_VALUE,\n          outerRadius: \"105%\"\n        };\n        this.init(e, m);\n      }\n\n      b.prototype.init = function (e, m) {\n        this.chart = m;\n        this.background = [];\n        m.pane.push(this);\n        this.setOptions(e);\n      };\n\n      b.prototype.setOptions = function (e) {\n        this.options = E(this.defaultOptions, this.chart.angular ? {\n          background: {}\n        } : void 0, e);\n      };\n\n      b.prototype.render = function () {\n        var b = this.options,\n            m = this.options.background,\n            f = this.chart.renderer;\n        this.group || (this.group = f.g(\"pane-group\").attr({\n          zIndex: b.zIndex || 0\n        }).add());\n        this.updateCenter();\n        if (m) for (m = e(m), b = Math.max(m.length, this.background.length || 0), f = 0; f < b; f++) m[f] && this.axis ? this.renderBackground(E(this.defaultBackgroundOptions, m[f]), f) : this.background[f] && (this.background[f] = this.background[f].destroy(), this.background.splice(f, 1));\n      };\n\n      b.prototype.renderBackground = function (e, f) {\n        var b = \"animate\",\n            m = {\n          \"class\": \"highcharts-pane \" + (e.className || \"\")\n        };\n        this.chart.styledMode || z(m, {\n          fill: e.backgroundColor,\n          stroke: e.borderColor,\n          \"stroke-width\": e.borderWidth\n        });\n        this.background[f] || (this.background[f] = this.chart.renderer.path().add(this.group), b = \"attr\");\n        this.background[f][b]({\n          d: this.axis.getPlotBandPath(e.from, e.to, e)\n        }).attr(m);\n      };\n\n      b.prototype.updateCenter = function (e) {\n        this.center = (e || this.axis || {}).center = f.getCenter.call(this);\n      };\n\n      b.prototype.update = function (e, f) {\n        E(!0, this.options, e);\n        E(!0, this.chart.options.pane, e);\n        this.setOptions(this.options);\n        this.render();\n        this.chart.axes.forEach(function (e) {\n          e.pane === this && (e.pane = null, e.update({}, f));\n        }, this);\n      };\n\n      return b;\n    }();\n\n    c.prototype.getHoverPane = function (e) {\n      var f = this,\n          b;\n      e && f.pane.forEach(function (m) {\n        var a = e.chartX - f.plotLeft,\n            p = e.chartY - f.plotTop;\n        q(f.inverted ? p : a, f.inverted ? a : p, m.center) && (b = m);\n      });\n      return b;\n    };\n\n    u(c, \"afterIsInsidePlot\", function (e) {\n      this.polar && (e.isInsidePlot = this.pane.some(function (f) {\n        return q(e.x, e.y, f.center);\n      }));\n    });\n    u(h, \"beforeGetHoverData\", function (e) {\n      var f = this.chart;\n      f.polar && (f.hoverPane = f.getHoverPane(e), e.filter = function (b) {\n        return b.visible && !(!e.shared && b.directTouch) && B(b.options.enableMouseTracking, !0) && (!f.hoverPane || b.xAxis.pane === f.hoverPane);\n      });\n    });\n    u(h, \"afterGetHoverData\", function (e) {\n      var f = this.chart;\n      e.hoverPoint && e.hoverPoint.plotX && e.hoverPoint.plotY && f.hoverPane && !q(e.hoverPoint.plotX, e.hoverPoint.plotY, f.hoverPane.center) && (e.hoverPoint = void 0);\n    });\n    b.Pane = a;\n    return b.Pane;\n  });\n  A(c, \"Core/Axis/HiddenAxis.js\", [], function () {\n    return function () {\n      function c() {}\n\n      c.init = function (b) {\n        b.getOffset = function () {};\n\n        b.redraw = function () {\n          this.isDirty = !1;\n        };\n\n        b.render = function () {\n          this.isDirty = !1;\n        };\n\n        b.createLabelCollector = function () {\n          return function () {};\n        };\n\n        b.setScale = function () {};\n\n        b.setCategories = function () {};\n\n        b.setTitle = function () {};\n\n        b.isHidden = !0;\n      };\n\n      return c;\n    }();\n  });\n  A(c, \"Core/Axis/RadialAxis.js\", [c[\"Core/Axis/Axis.js\"], c[\"Core/Axis/Tick.js\"], c[\"Core/Axis/HiddenAxis.js\"], c[\"Core/Utilities.js\"]], function (c, b, h, a) {\n    var f = a.addEvent,\n        q = a.correctFloat,\n        u = a.defined,\n        z = a.extend,\n        E = a.fireEvent,\n        B = a.merge,\n        e = a.pick,\n        x = a.relativeLength,\n        w = a.wrap;\n\n    a = function () {\n      function b() {}\n\n      b.init = function (f) {\n        var b = c.prototype;\n\n        f.setOptions = function (e) {\n          e = this.options = B(f.constructor.defaultOptions, this.defaultPolarOptions, e);\n          e.plotBands || (e.plotBands = []);\n          E(this, \"afterSetOptions\");\n        };\n\n        f.getOffset = function () {\n          b.getOffset.call(this);\n          this.chart.axisOffset[this.side] = 0;\n        };\n\n        f.getLinePath = function (f, l, k) {\n          f = this.pane.center;\n          var d = this.chart,\n              g = e(l, f[2] / 2 - this.offset);\n          \"undefined\" === typeof k && (k = this.horiz ? 0 : this.center && -this.center[3] / 2);\n          k && (g += k);\n          this.isCircular || \"undefined\" !== typeof l ? (l = this.chart.renderer.symbols.arc(this.left + f[0], this.top + f[1], g, g, {\n            start: this.startAngleRad,\n            end: this.endAngleRad,\n            open: !0,\n            innerR: 0\n          }), l.xBounds = [this.left + f[0]], l.yBounds = [this.top + f[1] - g]) : (l = this.postTranslate(this.angleRad, g), l = [[\"M\", this.center[0] + d.plotLeft, this.center[1] + d.plotTop], [\"L\", l.x, l.y]]);\n          return l;\n        };\n\n        f.setAxisTranslation = function () {\n          b.setAxisTranslation.call(this);\n          this.center && (this.transA = this.isCircular ? (this.endAngleRad - this.startAngleRad) / (this.max - this.min || 1) : (this.center[2] - this.center[3]) / 2 / (this.max - this.min || 1), this.minPixelPadding = this.isXAxis ? this.transA * this.minPointOffset : 0);\n        };\n\n        f.beforeSetTickPositions = function () {\n          this.autoConnect = this.isCircular && \"undefined\" === typeof e(this.userMax, this.options.max) && q(this.endAngleRad - this.startAngleRad) === q(2 * Math.PI);\n          !this.isCircular && this.chart.inverted && this.max++;\n          this.autoConnect && (this.max += this.categories && 1 || this.pointRange || this.closestPointRange || 0);\n        };\n\n        f.setAxisSize = function () {\n          b.setAxisSize.call(this);\n\n          if (this.isRadial) {\n            this.pane.updateCenter(this);\n            var f = this.center = z([], this.pane.center);\n            if (this.isCircular) this.sector = this.endAngleRad - this.startAngleRad;else {\n              var l = this.postTranslate(this.angleRad, f[3] / 2);\n              f[0] = l.x - this.chart.plotLeft;\n              f[1] = l.y - this.chart.plotTop;\n            }\n            this.len = this.width = this.height = (f[2] - f[3]) * e(this.sector, 1) / 2;\n          }\n        };\n\n        f.getPosition = function (f, l) {\n          f = this.translate(f);\n          return this.postTranslate(this.isCircular ? f : this.angleRad, e(this.isCircular ? l : 0 > f ? 0 : f, this.center[2] / 2) - this.offset);\n        };\n\n        f.postTranslate = function (e, l) {\n          var k = this.chart,\n              d = this.center;\n          e = this.startAngleRad + e;\n          return {\n            x: k.plotLeft + d[0] + Math.cos(e) * l,\n            y: k.plotTop + d[1] + Math.sin(e) * l\n          };\n        };\n\n        f.getPlotBandPath = function (f, l, k) {\n          var d = function (d) {\n            if (\"string\" === typeof d) {\n              var g = parseInt(d, 10);\n              n.test(d) && (g = g * D / 100);\n              return g;\n            }\n\n            return d;\n          },\n              g = this.center,\n              r = this.startAngleRad,\n              D = g[2] / 2,\n              t = Math.min(this.offset, 0),\n              n = /%$/;\n\n          var y = this.isCircular;\n          var b = e(d(k.outerRadius), D),\n              p = d(k.innerRadius);\n          d = e(d(k.thickness), 10);\n          if (\"polygon\" === this.options.gridLineInterpolation) t = this.getPlotLinePath({\n            value: f\n          }).concat(this.getPlotLinePath({\n            value: l,\n            reverse: !0\n          }));else {\n            f = Math.max(f, this.min);\n            l = Math.min(l, this.max);\n            f = this.translate(f);\n            l = this.translate(l);\n            y || (b = f || 0, p = l || 0);\n            if (\"circle\" !== k.shape && y) k = r + (f || 0), r += l || 0;else {\n              k = -Math.PI / 2;\n              r = 1.5 * Math.PI;\n              var a = !0;\n            }\n            b -= t;\n            t = this.chart.renderer.symbols.arc(this.left + g[0], this.top + g[1], b, b, {\n              start: Math.min(k, r),\n              end: Math.max(k, r),\n              innerR: e(p, b - (d - t)),\n              open: a\n            });\n            y && (y = (r + k) / 2, a = this.left + g[0] + g[2] / 2 * Math.cos(y), t.xBounds = y > -Math.PI / 2 && y < Math.PI / 2 ? [a, this.chart.plotWidth] : [0, a], t.yBounds = [this.top + g[1] + g[2] / 2 * Math.sin(y)], t.yBounds[0] += y > -Math.PI && 0 > y || y > Math.PI ? -10 : 10);\n          }\n          return t;\n        };\n\n        f.getCrosshairPosition = function (e, l, k) {\n          var d = e.value,\n              g = this.pane.center;\n\n          if (this.isCircular) {\n            if (u(d)) e.point && (r = e.point.shapeArgs || {}, r.start && (d = this.chart.inverted ? this.translate(e.point.rectPlotY, !0) : e.point.x));else {\n              var r = e.chartX || 0;\n              var D = e.chartY || 0;\n              d = this.translate(Math.atan2(D - k, r - l) - this.startAngleRad, !0);\n            }\n            e = this.getPosition(d);\n            r = e.x;\n            D = e.y;\n          } else u(d) || (r = e.chartX, D = e.chartY), u(r) && u(D) && (k = g[1] + this.chart.plotTop, d = this.translate(Math.min(Math.sqrt(Math.pow(r - l, 2) + Math.pow(D - k, 2)), g[2] / 2) - g[3] / 2, !0));\n\n          return [d, r || 0, D || 0];\n        };\n\n        f.getPlotLinePath = function (e) {\n          var l = this,\n              k = l.pane.center,\n              d = l.chart,\n              g = d.inverted,\n              r = e.value,\n              D = e.reverse,\n              t = l.getPosition(r),\n              n = l.pane.options.background ? l.pane.options.background[0] || l.pane.options.background : {},\n              f = n.innerRadius || \"0%\",\n              b = n.outerRadius || \"100%\";\n          n = k[0] + d.plotLeft;\n          var a = k[1] + d.plotTop,\n              p = t.x,\n              m = t.y,\n              h = l.height;\n          t = k[3] / 2;\n          var v;\n          e.isCrosshair && (m = this.getCrosshairPosition(e, n, a), r = m[0], p = m[1], m = m[2]);\n          if (l.isCircular) r = Math.sqrt(Math.pow(p - n, 2) + Math.pow(m - a, 2)), D = \"string\" === typeof f ? x(f, 1) : f / r, d = \"string\" === typeof b ? x(b, 1) : b / r, k && t && (r = t / r, D < r && (D = r), d < r && (d = r)), k = [[\"M\", n + D * (p - n), a - D * (a - m)], [\"L\", p - (1 - d) * (p - n), m + (1 - d) * (a - m)]];else if ((r = l.translate(r)) && (0 > r || r > h) && (r = 0), \"circle\" === l.options.gridLineInterpolation) k = l.getLinePath(0, r, t);else if (k = [], d[g ? \"yAxis\" : \"xAxis\"].forEach(function (d) {\n            d.pane === l.pane && (v = d);\n          }), v) for (n = v.tickPositions, v.autoConnect && (n = n.concat([n[0]])), D && (n = n.slice().reverse()), r && (r += t), p = 0; p < n.length; p++) a = v.getPosition(n[p], r), k.push(p ? [\"L\", a.x, a.y] : [\"M\", a.x, a.y]);\n          return k;\n        };\n\n        f.getTitlePosition = function () {\n          var e = this.center,\n              l = this.chart,\n              k = this.options.title;\n          return {\n            x: l.plotLeft + e[0] + (k.x || 0),\n            y: l.plotTop + e[1] - {\n              high: .5,\n              middle: .25,\n              low: 0\n            }[k.align] * e[2] + (k.y || 0)\n          };\n        };\n\n        f.createLabelCollector = function () {\n          var e = this;\n          return function () {\n            if (e.isRadial && e.tickPositions && !0 !== e.options.labels.allowOverlap) return e.tickPositions.map(function (l) {\n              return e.ticks[l] && e.ticks[l].label;\n            }).filter(function (e) {\n              return !!e;\n            });\n          };\n        };\n      };\n\n      b.compose = function (a, m) {\n        f(a, \"init\", function (e) {\n          var l = this.chart,\n              k = l.inverted,\n              d = l.angular,\n              g = l.polar,\n              r = this.isXAxis,\n              D = this.coll,\n              t = d && r,\n              n,\n              f = l.options;\n          e = e.userOptions.pane || 0;\n          e = this.pane = l.pane && l.pane[e];\n          if (\"colorAxis\" === D) this.isRadial = !1;else {\n            if (d) {\n              if (t ? h.init(this) : b.init(this), n = !r) this.defaultPolarOptions = b.defaultRadialGaugeOptions;\n            } else g && (b.init(this), this.defaultPolarOptions = (n = this.horiz) ? b.defaultCircularOptions : B(\"xAxis\" === D ? a.defaultOptions : a.defaultYAxisOptions, b.defaultRadialOptions), k && \"yAxis\" === D && (this.defaultPolarOptions.stackLabels = a.defaultYAxisOptions.stackLabels));\n\n            d || g ? (this.isRadial = !0, f.chart.zoomType = null, this.labelCollector || (this.labelCollector = this.createLabelCollector()), this.labelCollector && l.labelCollectors.push(this.labelCollector)) : this.isRadial = !1;\n            e && n && (e.axis = this);\n            this.isCircular = n;\n          }\n        });\n        f(a, \"afterInit\", function () {\n          var f = this.chart,\n              l = this.options,\n              k = this.pane,\n              d = k && k.options;\n          f.angular && this.isXAxis || !k || !f.angular && !f.polar || (this.angleRad = (l.angle || 0) * Math.PI / 180, this.startAngleRad = (d.startAngle - 90) * Math.PI / 180, this.endAngleRad = (e(d.endAngle, d.startAngle + 360) - 90) * Math.PI / 180, this.offset = l.offset || 0);\n        });\n        f(a, \"autoLabelAlign\", function (e) {\n          this.isRadial && (e.align = void 0, e.preventDefault());\n        });\n        f(a, \"destroy\", function () {\n          if (this.chart && this.chart.labelCollectors) {\n            var e = this.labelCollector ? this.chart.labelCollectors.indexOf(this.labelCollector) : -1;\n            0 <= e && this.chart.labelCollectors.splice(e, 1);\n          }\n        });\n        f(a, \"initialAxisTranslation\", function () {\n          this.isRadial && this.beforeSetTickPositions();\n        });\n        f(m, \"afterGetPosition\", function (e) {\n          this.axis.getPosition && z(e.pos, this.axis.getPosition(this.pos));\n        });\n        f(m, \"afterGetLabelPosition\", function (f) {\n          var l = this.axis,\n              k = this.label;\n\n          if (k) {\n            var d = k.getBBox(),\n                g = l.options.labels,\n                r = g.y,\n                D = 20,\n                t = g.align,\n                n = (l.translate(this.pos) + l.startAngleRad + Math.PI / 2) / Math.PI * 180 % 360,\n                y = Math.round(n),\n                b = \"end\",\n                a = 0 > y ? y + 360 : y,\n                m = a,\n                h = 0,\n                v = 0,\n                p = null === g.y ? .3 * -d.height : 0;\n\n            if (l.isRadial) {\n              var c = l.getPosition(this.pos, l.center[2] / 2 + x(e(g.distance, -25), l.center[2] / 2, -l.center[2] / 2));\n              \"auto\" === g.rotation ? k.attr({\n                rotation: n\n              }) : null === r && (r = l.chart.renderer.fontMetrics(k.styles && k.styles.fontSize).b - d.height / 2);\n              null === t && (l.isCircular ? (d.width > l.len * l.tickInterval / (l.max - l.min) && (D = 0), t = n > D && n < 180 - D ? \"left\" : n > 180 + D && n < 360 - D ? \"right\" : \"center\") : t = \"center\", k.attr({\n                align: t\n              }));\n\n              if (\"auto\" === t && 2 === l.tickPositions.length && l.isCircular) {\n                90 < a && 180 > a ? a = 180 - a : 270 < a && 360 >= a && (a = 540 - a);\n                180 < m && 360 >= m && (m = 360 - m);\n                if (l.pane.options.startAngle === y || l.pane.options.startAngle === y + 360 || l.pane.options.startAngle === y - 360) b = \"start\";\n                t = -90 <= y && 90 >= y || -360 <= y && -270 >= y || 270 <= y && 360 >= y ? \"start\" === b ? \"right\" : \"left\" : \"start\" === b ? \"left\" : \"right\";\n                70 < m && 110 > m && (t = \"center\");\n                15 > a || 180 <= a && 195 > a ? h = .3 * d.height : 15 <= a && 35 >= a ? h = \"start\" === b ? 0 : .75 * d.height : 195 <= a && 215 >= a ? h = \"start\" === b ? .75 * d.height : 0 : 35 < a && 90 >= a ? h = \"start\" === b ? .25 * -d.height : d.height : 215 < a && 270 >= a && (h = \"start\" === b ? d.height : .25 * -d.height);\n                15 > m ? v = \"start\" === b ? .15 * -d.height : .15 * d.height : 165 < m && 180 >= m && (v = \"start\" === b ? .15 * d.height : .15 * -d.height);\n                k.attr({\n                  align: t\n                });\n                k.translate(v, h + p);\n              }\n\n              f.pos.x = c.x + g.x;\n              f.pos.y = c.y + r;\n            }\n          }\n        });\n        w(m.prototype, \"getMarkPath\", function (e, l, k, d, g, r, D) {\n          var t = this.axis;\n          t.isRadial ? (e = t.getPosition(this.pos, t.center[2] / 2 + d), l = [\"M\", l, k, \"L\", e.x, e.y]) : l = e.call(this, l, k, d, g, r, D);\n          return l;\n        });\n      };\n\n      b.defaultCircularOptions = {\n        gridLineWidth: 1,\n        labels: {\n          align: null,\n          distance: 15,\n          x: 0,\n          y: null,\n          style: {\n            textOverflow: \"none\"\n          }\n        },\n        maxPadding: 0,\n        minPadding: 0,\n        showLastLabel: !1,\n        tickLength: 0\n      };\n      b.defaultRadialGaugeOptions = {\n        labels: {\n          align: \"center\",\n          x: 0,\n          y: null\n        },\n        minorGridLineWidth: 0,\n        minorTickInterval: \"auto\",\n        minorTickLength: 10,\n        minorTickPosition: \"inside\",\n        minorTickWidth: 1,\n        tickLength: 10,\n        tickPosition: \"inside\",\n        tickWidth: 2,\n        title: {\n          rotation: 0\n        },\n        zIndex: 2\n      };\n      b.defaultRadialOptions = {\n        gridLineInterpolation: \"circle\",\n        gridLineWidth: 1,\n        labels: {\n          align: \"right\",\n          x: -3,\n          y: -2\n        },\n        showLastLabel: !1,\n        title: {\n          x: 4,\n          text: null,\n          rotation: 90\n        }\n      };\n      return b;\n    }();\n\n    a.compose(c, b);\n    return a;\n  });\n  A(c, \"Series/AreaRangeSeries.js\", [c[\"Core/Series/Series.js\"], c[\"Core/Globals.js\"], c[\"Core/Series/Point.js\"], c[\"Core/Utilities.js\"]], function (c, b, h, a) {\n    var f = a.defined,\n        q = a.extend,\n        u = a.isArray,\n        z = a.isNumber,\n        E = a.pick,\n        B = c.seriesTypes.area.prototype,\n        e = c.seriesTypes.column.prototype,\n        x = h.prototype,\n        w = b.Series.prototype;\n    c.seriesType(\"arearange\", \"area\", {\n      lineWidth: 1,\n      threshold: null,\n      tooltip: {\n        pointFormat: '<span style=\"color:{series.color}\">\\u25cf</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'\n      },\n      trackByArea: !0,\n      dataLabels: {\n        align: void 0,\n        verticalAlign: void 0,\n        xLow: 0,\n        xHigh: 0,\n        yLow: 0,\n        yHigh: 0\n      }\n    }, {\n      pointArrayMap: [\"low\", \"high\"],\n      pointValKey: \"low\",\n      deferTranslatePolar: !0,\n      toYData: function (e) {\n        return [e.low, e.high];\n      },\n      highToXY: function (e) {\n        var f = this.chart,\n            b = this.xAxis.postTranslate(e.rectPlotX, this.yAxis.len - e.plotHigh);\n        e.plotHighX = b.x - f.plotLeft;\n        e.plotHigh = b.y - f.plotTop;\n        e.plotLowX = e.plotX;\n      },\n      translate: function () {\n        var e = this,\n            f = e.yAxis,\n            b = !!e.modifyValue;\n        B.translate.apply(e);\n        e.points.forEach(function (a) {\n          var l = a.high,\n              k = a.plotY;\n          a.isNull ? a.plotY = null : (a.plotLow = k, a.plotHigh = f.translate(b ? e.modifyValue(l, a) : l, 0, 1, 0, 1), b && (a.yBottom = a.plotHigh));\n        });\n        this.chart.polar && this.points.forEach(function (f) {\n          e.highToXY(f);\n          f.tooltipPos = [(f.plotHighX + f.plotLowX) / 2, (f.plotHigh + f.plotLow) / 2];\n        });\n      },\n      getGraphPath: function (e) {\n        var f = [],\n            b = [],\n            a,\n            l = B.getGraphPath;\n        var k = this.options;\n        var d = this.chart.polar,\n            g = d && !1 !== k.connectEnds,\n            r = k.connectNulls,\n            D = k.step;\n        e = e || this.points;\n\n        for (a = e.length; a--;) {\n          var t = e[a];\n          var n = d ? {\n            plotX: t.rectPlotX,\n            plotY: t.yBottom,\n            doCurve: !1\n          } : {\n            plotX: t.plotX,\n            plotY: t.plotY,\n            doCurve: !1\n          };\n          t.isNull || g || r || e[a + 1] && !e[a + 1].isNull || b.push(n);\n          var y = {\n            polarPlotY: t.polarPlotY,\n            rectPlotX: t.rectPlotX,\n            yBottom: t.yBottom,\n            plotX: E(t.plotHighX, t.plotX),\n            plotY: t.plotHigh,\n            isNull: t.isNull\n          };\n          b.push(y);\n          f.push(y);\n          t.isNull || g || r || e[a - 1] && !e[a - 1].isNull || b.push(n);\n        }\n\n        e = l.call(this, e);\n        D && (!0 === D && (D = \"left\"), k.step = {\n          left: \"right\",\n          center: \"center\",\n          right: \"left\"\n        }[D]);\n        f = l.call(this, f);\n        b = l.call(this, b);\n        k.step = D;\n        k = [].concat(e, f);\n        !this.chart.polar && b[0] && \"M\" === b[0][0] && (b[0] = [\"L\", b[0][1], b[0][2]]);\n        this.graphPath = k;\n        this.areaPath = e.concat(b);\n        k.isArea = !0;\n        k.xMap = e.xMap;\n        this.areaPath.xMap = e.xMap;\n        return k;\n      },\n      drawDataLabels: function () {\n        var e = this.points,\n            f = e.length,\n            b,\n            a = [],\n            l = this.options.dataLabels,\n            k,\n            d = this.chart.inverted;\n\n        if (u(l)) {\n          var g = l[0] || {\n            enabled: !1\n          };\n          var r = l[1] || {\n            enabled: !1\n          };\n        } else g = q({}, l), g.x = l.xHigh, g.y = l.yHigh, r = q({}, l), r.x = l.xLow, r.y = l.yLow;\n\n        if (g.enabled || this._hasPointLabels) {\n          for (b = f; b--;) if (k = e[b]) {\n            var D = g.inside ? k.plotHigh < k.plotLow : k.plotHigh > k.plotLow;\n            k.y = k.high;\n            k._plotY = k.plotY;\n            k.plotY = k.plotHigh;\n            a[b] = k.dataLabel;\n            k.dataLabel = k.dataLabelUpper;\n            k.below = D;\n            d ? g.align || (g.align = D ? \"right\" : \"left\") : g.verticalAlign || (g.verticalAlign = D ? \"top\" : \"bottom\");\n          }\n\n          this.options.dataLabels = g;\n          w.drawDataLabels && w.drawDataLabels.apply(this, arguments);\n\n          for (b = f; b--;) if (k = e[b]) k.dataLabelUpper = k.dataLabel, k.dataLabel = a[b], delete k.dataLabels, k.y = k.low, k.plotY = k._plotY;\n        }\n\n        if (r.enabled || this._hasPointLabels) {\n          for (b = f; b--;) if (k = e[b]) D = r.inside ? k.plotHigh < k.plotLow : k.plotHigh > k.plotLow, k.below = !D, d ? r.align || (r.align = D ? \"left\" : \"right\") : r.verticalAlign || (r.verticalAlign = D ? \"bottom\" : \"top\");\n\n          this.options.dataLabels = r;\n          w.drawDataLabels && w.drawDataLabels.apply(this, arguments);\n        }\n\n        if (g.enabled) for (b = f; b--;) if (k = e[b]) k.dataLabels = [k.dataLabelUpper, k.dataLabel].filter(function (d) {\n          return !!d;\n        });\n        this.options.dataLabels = l;\n      },\n      alignDataLabel: function () {\n        e.alignDataLabel.apply(this, arguments);\n      },\n      drawPoints: function () {\n        var e = this.points.length,\n            b;\n        w.drawPoints.apply(this, arguments);\n\n        for (b = 0; b < e;) {\n          var a = this.points[b];\n          a.origProps = {\n            plotY: a.plotY,\n            plotX: a.plotX,\n            isInside: a.isInside,\n            negative: a.negative,\n            zone: a.zone,\n            y: a.y\n          };\n          a.lowerGraphic = a.graphic;\n          a.graphic = a.upperGraphic;\n          a.plotY = a.plotHigh;\n          f(a.plotHighX) && (a.plotX = a.plotHighX);\n          a.y = a.high;\n          a.negative = a.high < (this.options.threshold || 0);\n          a.zone = this.zones.length && a.getZone();\n          this.chart.polar || (a.isInside = a.isTopInside = \"undefined\" !== typeof a.plotY && 0 <= a.plotY && a.plotY <= this.yAxis.len && 0 <= a.plotX && a.plotX <= this.xAxis.len);\n          b++;\n        }\n\n        w.drawPoints.apply(this, arguments);\n\n        for (b = 0; b < e;) a = this.points[b], a.upperGraphic = a.graphic, a.graphic = a.lowerGraphic, q(a, a.origProps), delete a.origProps, b++;\n      },\n      setStackedPoints: b.noop\n    }, {\n      setState: function () {\n        var e = this.state,\n            a = this.series,\n            b = a.chart.polar;\n        f(this.plotHigh) || (this.plotHigh = a.yAxis.toPixels(this.high, !0));\n        f(this.plotLow) || (this.plotLow = this.plotY = a.yAxis.toPixels(this.low, !0));\n        a.stateMarkerGraphic && (a.lowerStateMarkerGraphic = a.stateMarkerGraphic, a.stateMarkerGraphic = a.upperStateMarkerGraphic);\n        this.graphic = this.upperGraphic;\n        this.plotY = this.plotHigh;\n        b && (this.plotX = this.plotHighX);\n        x.setState.apply(this, arguments);\n        this.state = e;\n        this.plotY = this.plotLow;\n        this.graphic = this.lowerGraphic;\n        b && (this.plotX = this.plotLowX);\n        a.stateMarkerGraphic && (a.upperStateMarkerGraphic = a.stateMarkerGraphic, a.stateMarkerGraphic = a.lowerStateMarkerGraphic, a.lowerStateMarkerGraphic = void 0);\n        x.setState.apply(this, arguments);\n      },\n      haloPath: function () {\n        var e = this.series.chart.polar,\n            a = [];\n        this.plotY = this.plotLow;\n        e && (this.plotX = this.plotLowX);\n        this.isInside && (a = x.haloPath.apply(this, arguments));\n        this.plotY = this.plotHigh;\n        e && (this.plotX = this.plotHighX);\n        this.isTopInside && (a = a.concat(x.haloPath.apply(this, arguments)));\n        return a;\n      },\n      destroyElements: function () {\n        [\"lowerGraphic\", \"upperGraphic\"].forEach(function (e) {\n          this[e] && (this[e] = this[e].destroy());\n        }, this);\n        this.graphic = null;\n        return x.destroyElements.apply(this, arguments);\n      },\n      isValid: function () {\n        return z(this.low) && z(this.high);\n      }\n    });\n    \"\";\n  });\n  A(c, \"Series/AreaSplineRangeSeries.js\", [c[\"Core/Series/Series.js\"]], function (c) {\n    c.seriesType(\"areasplinerange\", \"arearange\", null, {\n      getPointSpline: c.seriesTypes.spline.prototype.getPointSpline\n    });\n    \"\";\n  });\n  A(c, \"Series/ColumnRangeSeries.js\", [c[\"Core/Series/Series.js\"], c[\"Core/Globals.js\"], c[\"Core/Options.js\"], c[\"Core/Utilities.js\"]], function (c, b, h, a) {\n    b = b.noop;\n    h = h.defaultOptions;\n    var f = a.clamp,\n        q = a.merge,\n        u = a.pick,\n        z = c.seriesTypes.column.prototype;\n    c.seriesType(\"columnrange\", \"arearange\", q(h.plotOptions.column, h.plotOptions.arearange, {\n      pointRange: null,\n      marker: null,\n      states: {\n        hover: {\n          halo: !1\n        }\n      }\n    }), {\n      translate: function () {\n        var a = this,\n            b = a.yAxis,\n            e = a.xAxis,\n            h = e.startAngleRad,\n            c,\n            m = a.chart,\n            q = a.xAxis.isRadial,\n            v = Math.max(m.chartWidth, m.chartHeight) + 999,\n            p;\n        z.translate.apply(a);\n        a.points.forEach(function (l) {\n          var k = l.shapeArgs,\n              d = a.options.minPointLength;\n          l.plotHigh = p = f(b.translate(l.high, 0, 1, 0, 1), -v, v);\n          l.plotLow = f(l.plotY, -v, v);\n          var g = p;\n          var r = u(l.rectPlotY, l.plotY) - p;\n          Math.abs(r) < d ? (d -= r, r += d, g -= d / 2) : 0 > r && (r *= -1, g -= r);\n          q ? (c = l.barX + h, l.shapeType = \"arc\", l.shapeArgs = a.polarArc(g + r, g, c, c + l.pointWidth)) : (k.height = r, k.y = g, l.tooltipPos = m.inverted ? [b.len + b.pos - m.plotLeft - g - r / 2, e.len + e.pos - m.plotTop - k.x - k.width / 2, r] : [e.left - m.plotLeft + k.x + k.width / 2, b.pos - m.plotTop + g + r / 2, r]);\n        });\n      },\n      directTouch: !0,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      drawGraph: b,\n      getSymbol: b,\n      crispCol: function () {\n        return z.crispCol.apply(this, arguments);\n      },\n      drawPoints: function () {\n        return z.drawPoints.apply(this, arguments);\n      },\n      drawTracker: function () {\n        return z.drawTracker.apply(this, arguments);\n      },\n      getColumnMetrics: function () {\n        return z.getColumnMetrics.apply(this, arguments);\n      },\n      pointAttribs: function () {\n        return z.pointAttribs.apply(this, arguments);\n      },\n      animate: function () {\n        return z.animate.apply(this, arguments);\n      },\n      polarArc: function () {\n        return z.polarArc.apply(this, arguments);\n      },\n      translate3dPoints: function () {\n        return z.translate3dPoints.apply(this, arguments);\n      },\n      translate3dShapes: function () {\n        return z.translate3dShapes.apply(this, arguments);\n      }\n    }, {\n      setState: z.pointClass.prototype.setState\n    });\n    \"\";\n  });\n  A(c, \"Series/ColumnPyramidSeries.js\", [c[\"Core/Series/Series.js\"], c[\"Series/ColumnSeries.js\"], c[\"Core/Utilities.js\"]], function (c, b, h) {\n    var a = b.prototype,\n        f = h.clamp,\n        q = h.pick;\n    c.seriesType(\"columnpyramid\", \"column\", {}, {\n      translate: function () {\n        var b = this,\n            h = b.chart,\n            c = b.options,\n            B = b.dense = 2 > b.closestPointRange * b.xAxis.transA;\n        B = b.borderWidth = q(c.borderWidth, B ? 0 : 1);\n        var e = b.yAxis,\n            x = c.threshold,\n            w = b.translatedThreshold = e.getThreshold(x),\n            m = q(c.minPointLength, 5),\n            C = b.getColumnMetrics(),\n            v = C.width,\n            p = b.barW = Math.max(v, 1 + 2 * B),\n            l = b.pointXOffset = C.offset;\n        h.inverted && (w -= .5);\n        c.pointPadding && (p = Math.ceil(p));\n        a.translate.apply(b);\n        b.points.forEach(function (k) {\n          var d = q(k.yBottom, w),\n              g = 999 + Math.abs(d),\n              r = f(k.plotY, -g, e.len + g);\n          g = k.plotX + l;\n          var a = p / 2,\n              t = Math.min(r, d);\n          d = Math.max(r, d) - t;\n          var n;\n          k.barX = g;\n          k.pointWidth = v;\n          k.tooltipPos = h.inverted ? [e.len + e.pos - h.plotLeft - r, b.xAxis.len - g - a, d] : [g + a, r + e.pos - h.plotTop, d];\n          r = x + (k.total || k.y);\n          \"percent\" === c.stacking && (r = x + (0 > k.y) ? -100 : 100);\n          r = e.toPixels(r, !0);\n          var y = (n = h.plotHeight - r - (h.plotHeight - w)) ? a * (t - r) / n : 0;\n          var G = n ? a * (t + d - r) / n : 0;\n          n = g - y + a;\n          y = g + y + a;\n          var H = g + G + a;\n          G = g - G + a;\n          var u = t - m;\n          var F = t + d;\n          0 > k.y && (u = t, F = t + d + m);\n          h.inverted && (H = h.plotWidth - t, n = r - (h.plotWidth - w), y = a * (r - H) / n, G = a * (r - (H - d)) / n, n = g + a + y, y = n - 2 * y, H = g - G + a, G = g + G + a, u = t, F = t + d - m, 0 > k.y && (F = t + d + m));\n          k.shapeType = \"path\";\n          k.shapeArgs = {\n            x: n,\n            y: u,\n            width: y - n,\n            height: d,\n            d: [[\"M\", n, u], [\"L\", y, u], [\"L\", H, F], [\"L\", G, F], [\"Z\"]]\n          };\n        });\n      }\n    });\n    \"\";\n  });\n  A(c, \"Series/GaugeSeries.js\", [c[\"Core/Series/Series.js\"], c[\"Core/Globals.js\"], c[\"Core/Utilities.js\"]], function (c, b, h) {\n    var a = h.clamp,\n        f = h.isNumber,\n        q = h.merge,\n        u = h.pick,\n        z = h.pInt,\n        E = b.Series;\n    h = b.TrackerMixin;\n    c.seriesType(\"gauge\", \"line\", {\n      dataLabels: {\n        borderColor: \"#cccccc\",\n        borderRadius: 3,\n        borderWidth: 1,\n        crop: !1,\n        defer: !1,\n        enabled: !0,\n        verticalAlign: \"top\",\n        y: 15,\n        zIndex: 2\n      },\n      dial: {},\n      pivot: {},\n      tooltip: {\n        headerFormat: \"\"\n      },\n      showInLegend: !1\n    }, {\n      angular: !0,\n      directTouch: !0,\n      drawGraph: b.noop,\n      fixedBox: !0,\n      forceDL: !0,\n      noSharedTooltip: !0,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      translate: function () {\n        var b = this.yAxis,\n            e = this.options,\n            h = b.center;\n        this.generatePoints();\n        this.points.forEach(function (c) {\n          var m = q(e.dial, c.dial),\n              x = z(u(m.radius, \"80%\")) * h[2] / 200,\n              w = z(u(m.baseLength, \"70%\")) * x / 100,\n              p = z(u(m.rearLength, \"10%\")) * x / 100,\n              l = m.baseWidth || 3,\n              k = m.topWidth || 1,\n              d = e.overshoot,\n              g = b.startAngleRad + b.translate(c.y, null, null, null, !0);\n          if (f(d) || !1 === e.wrap) d = f(d) ? d / 180 * Math.PI : 0, g = a(g, b.startAngleRad - d, b.endAngleRad + d);\n          g = 180 * g / Math.PI;\n          c.shapeType = \"path\";\n          c.shapeArgs = {\n            d: m.path || [[\"M\", -p, -l / 2], [\"L\", w, -l / 2], [\"L\", x, -k / 2], [\"L\", x, k / 2], [\"L\", w, l / 2], [\"L\", -p, l / 2], [\"Z\"]],\n            translateX: h[0],\n            translateY: h[1],\n            rotation: g\n          };\n          c.plotX = h[0];\n          c.plotY = h[1];\n        });\n      },\n      drawPoints: function () {\n        var a = this,\n            e = a.chart,\n            b = a.yAxis.center,\n            f = a.pivot,\n            h = a.options,\n            c = h.pivot,\n            z = e.renderer;\n        a.points.forEach(function (b) {\n          var f = b.graphic,\n              k = b.shapeArgs,\n              d = k.d,\n              g = q(h.dial, b.dial);\n          f ? (f.animate(k), k.d = d) : b.graphic = z[b.shapeType](k).attr({\n            rotation: k.rotation,\n            zIndex: 1\n          }).addClass(\"highcharts-dial\").add(a.group);\n          if (!e.styledMode) b.graphic[f ? \"animate\" : \"attr\"]({\n            stroke: g.borderColor || \"none\",\n            \"stroke-width\": g.borderWidth || 0,\n            fill: g.backgroundColor || \"#000000\"\n          });\n        });\n        f ? f.animate({\n          translateX: b[0],\n          translateY: b[1]\n        }) : (a.pivot = z.circle(0, 0, u(c.radius, 5)).attr({\n          zIndex: 2\n        }).addClass(\"highcharts-pivot\").translate(b[0], b[1]).add(a.group), e.styledMode || a.pivot.attr({\n          \"stroke-width\": c.borderWidth || 0,\n          stroke: c.borderColor || \"#cccccc\",\n          fill: c.backgroundColor || \"#000000\"\n        }));\n      },\n      animate: function (a) {\n        var e = this;\n        a || e.points.forEach(function (a) {\n          var b = a.graphic;\n          b && (b.attr({\n            rotation: 180 * e.yAxis.startAngleRad / Math.PI\n          }), b.animate({\n            rotation: a.shapeArgs.rotation\n          }, e.options.animation));\n        });\n      },\n      render: function () {\n        this.group = this.plotGroup(\"group\", \"series\", this.visible ? \"visible\" : \"hidden\", this.options.zIndex, this.chart.seriesGroup);\n        E.prototype.render.call(this);\n        this.group.clip(this.chart.clipRect);\n      },\n      setData: function (a, e) {\n        E.prototype.setData.call(this, a, !1);\n        this.processData();\n        this.generatePoints();\n        u(e, !0) && this.chart.redraw();\n      },\n      hasData: function () {\n        return !!this.points.length;\n      },\n      drawTracker: h && h.drawTrackerPoint\n    }, {\n      setState: function (a) {\n        this.state = a;\n      }\n    });\n    \"\";\n  });\n  A(c, \"Series/BoxPlotSeries.js\", [c[\"Core/Series/Series.js\"], c[\"Series/ColumnSeries.js\"], c[\"Core/Globals.js\"], c[\"Core/Utilities.js\"]], function (c, b, h, a) {\n    var f = b.prototype;\n    b = h.noop;\n    var q = a.pick;\n    c.seriesType(\"boxplot\", \"column\", {\n      threshold: null,\n      tooltip: {\n        pointFormat: '<span style=\"color:{point.color}\">\\u25cf</span> <b> {series.name}</b><br/>Maximum: {point.high}<br/>Upper quartile: {point.q3}<br/>Median: {point.median}<br/>Lower quartile: {point.q1}<br/>Minimum: {point.low}<br/>'\n      },\n      whiskerLength: \"50%\",\n      fillColor: \"#ffffff\",\n      lineWidth: 1,\n      medianWidth: 2,\n      whiskerWidth: 2\n    }, {\n      pointArrayMap: [\"low\", \"q1\", \"median\", \"q3\", \"high\"],\n      toYData: function (a) {\n        return [a.low, a.q1, a.median, a.q3, a.high];\n      },\n      pointValKey: \"high\",\n      pointAttribs: function () {\n        return {};\n      },\n      drawDataLabels: b,\n      translate: function () {\n        var a = this.yAxis,\n            b = this.pointArrayMap;\n        f.translate.apply(this);\n        this.points.forEach(function (f) {\n          b.forEach(function (b) {\n            null !== f[b] && (f[b + \"Plot\"] = a.translate(f[b], 0, 1, 0, 1));\n          });\n          f.plotHigh = f.highPlot;\n        });\n      },\n      drawPoints: function () {\n        var a = this,\n            b = a.options,\n            f = a.chart,\n            h = f.renderer,\n            e,\n            c,\n            w,\n            m,\n            C,\n            v,\n            p = 0,\n            l,\n            k,\n            d,\n            g,\n            r = !1 !== a.doQuartiles,\n            D,\n            t = a.options.whiskerLength;\n        a.points.forEach(function (n) {\n          var y = n.graphic,\n              G = y ? \"animate\" : \"attr\",\n              x = n.shapeArgs,\n              I = {},\n              F = {},\n              J = {},\n              K = {},\n              u = n.color || a.color;\n          \"undefined\" !== typeof n.plotY && (l = Math.round(x.width), k = Math.floor(x.x), d = k + l, g = Math.round(l / 2), e = Math.floor(r ? n.q1Plot : n.lowPlot), c = Math.floor(r ? n.q3Plot : n.lowPlot), w = Math.floor(n.highPlot), m = Math.floor(n.lowPlot), y || (n.graphic = y = h.g(\"point\").add(a.group), n.stem = h.path().addClass(\"highcharts-boxplot-stem\").add(y), t && (n.whiskers = h.path().addClass(\"highcharts-boxplot-whisker\").add(y)), r && (n.box = h.path(void 0).addClass(\"highcharts-boxplot-box\").add(y)), n.medianShape = h.path(void 0).addClass(\"highcharts-boxplot-median\").add(y)), f.styledMode || (F.stroke = n.stemColor || b.stemColor || u, F[\"stroke-width\"] = q(n.stemWidth, b.stemWidth, b.lineWidth), F.dashstyle = n.stemDashStyle || b.stemDashStyle || b.dashStyle, n.stem.attr(F), t && (J.stroke = n.whiskerColor || b.whiskerColor || u, J[\"stroke-width\"] = q(n.whiskerWidth, b.whiskerWidth, b.lineWidth), J.dashstyle = n.whiskerDashStyle || b.whiskerDashStyle || b.dashStyle, n.whiskers.attr(J)), r && (I.fill = n.fillColor || b.fillColor || u, I.stroke = b.lineColor || u, I[\"stroke-width\"] = b.lineWidth || 0, I.dashstyle = n.boxDashStyle || b.boxDashStyle || b.dashStyle, n.box.attr(I)), K.stroke = n.medianColor || b.medianColor || u, K[\"stroke-width\"] = q(n.medianWidth, b.medianWidth, b.lineWidth), K.dashstyle = n.medianDashStyle || b.medianDashStyle || b.dashStyle, n.medianShape.attr(K)), v = n.stem.strokeWidth() % 2 / 2, p = k + g + v, y = [[\"M\", p, c], [\"L\", p, w], [\"M\", p, e], [\"L\", p, m]], n.stem[G]({\n            d: y\n          }), r && (v = n.box.strokeWidth() % 2 / 2, e = Math.floor(e) + v, c = Math.floor(c) + v, k += v, d += v, y = [[\"M\", k, c], [\"L\", k, e], [\"L\", d, e], [\"L\", d, c], [\"L\", k, c], [\"Z\"]], n.box[G]({\n            d: y\n          })), t && (v = n.whiskers.strokeWidth() % 2 / 2, w += v, m += v, D = /%$/.test(t) ? g * parseFloat(t) / 100 : t / 2, y = [[\"M\", p - D, w], [\"L\", p + D, w], [\"M\", p - D, m], [\"L\", p + D, m]], n.whiskers[G]({\n            d: y\n          })), C = Math.round(n.medianPlot), v = n.medianShape.strokeWidth() % 2 / 2, C += v, y = [[\"M\", k, C], [\"L\", d, C]], n.medianShape[G]({\n            d: y\n          }));\n        });\n      },\n      setStackedPoints: b\n    });\n    \"\";\n  });\n  A(c, \"Series/ErrorBarSeries.js\", [c[\"Core/Series/Series.js\"], c[\"Core/Globals.js\"]], function (c, b) {\n    b = b.noop;\n    var h = c.seriesTypes;\n    c.seriesType(\"errorbar\", \"boxplot\", {\n      color: \"#000000\",\n      grouping: !1,\n      linkedTo: \":previous\",\n      tooltip: {\n        pointFormat: '<span style=\"color:{point.color}\">\\u25cf</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'\n      },\n      whiskerWidth: null\n    }, {\n      type: \"errorbar\",\n      pointArrayMap: [\"low\", \"high\"],\n      toYData: function (a) {\n        return [a.low, a.high];\n      },\n      pointValKey: \"high\",\n      doQuartiles: !1,\n      drawDataLabels: h.arearange ? function () {\n        var a = this.pointValKey;\n        h.arearange.prototype.drawDataLabels.call(this);\n        this.data.forEach(function (b) {\n          b.y = b[a];\n        });\n      } : b,\n      getColumnMetrics: function () {\n        return this.linkedParent && this.linkedParent.columnMetrics || h.column.prototype.getColumnMetrics.call(this);\n      }\n    });\n    \"\";\n  });\n  A(c, \"Series/WaterfallSeries.js\", [c[\"Core/Axis/Axis.js\"], c[\"Core/Series/Series.js\"], c[\"Core/Chart/Chart.js\"], c[\"Core/Globals.js\"], c[\"Core/Series/Point.js\"], c[\"Extensions/Stacking.js\"], c[\"Core/Utilities.js\"]], function (c, b, h, a, f, q, u) {\n    var z = b.seriesTypes,\n        E = u.addEvent,\n        B = u.arrayMax,\n        e = u.arrayMin,\n        x = u.correctFloat,\n        w = u.isNumber,\n        m = u.objectEach,\n        C = u.pick,\n        v = a.Series,\n        p;\n\n    (function (e) {\n      function a() {\n        var d = this.waterfall.stacks;\n        d && (d.changed = !1, delete d.alreadyChanged);\n      }\n\n      function d() {\n        var d = this.options.stackLabels;\n        d && d.enabled && this.waterfall.stacks && this.waterfall.renderStackTotals();\n      }\n\n      function g() {\n        for (var d = this.axes, g = this.series, e = g.length; e--;) g[e].options.stacking && (d.forEach(function (d) {\n          d.isXAxis || (d.waterfall.stacks.changed = !0);\n        }), e = 0);\n      }\n\n      function b() {\n        this.waterfall || (this.waterfall = new f(this));\n      }\n\n      var f = function () {\n        function d(d) {\n          this.axis = d;\n          this.stacks = {\n            changed: !1\n          };\n        }\n\n        d.prototype.renderStackTotals = function () {\n          var d = this.axis,\n              g = d.waterfall.stacks,\n              e = d.stacking && d.stacking.stackTotalGroup,\n              a = new q(d, d.options.stackLabels, !1, 0, void 0);\n          this.dummyStackItem = a;\n          m(g, function (d) {\n            m(d, function (d) {\n              a.total = d.stackTotal;\n              d.label && (a.label = d.label);\n              q.prototype.render.call(a, e);\n              d.label = a.label;\n              delete a.label;\n            });\n          });\n          a.total = null;\n        };\n\n        return d;\n      }();\n\n      e.Composition = f;\n\n      e.compose = function (e, k) {\n        E(e, \"init\", b);\n        E(e, \"afterBuildStacks\", a);\n        E(e, \"afterRender\", d);\n        E(k, \"beforeRedraw\", g);\n      };\n    })(p || (p = {}));\n\n    b.seriesType(\"waterfall\", \"column\", {\n      dataLabels: {\n        inside: !0\n      },\n      lineWidth: 1,\n      lineColor: \"#333333\",\n      dashStyle: \"Dot\",\n      borderColor: \"#333333\",\n      states: {\n        hover: {\n          lineWidthPlus: 0\n        }\n      }\n    }, {\n      pointValKey: \"y\",\n      showLine: !0,\n      generatePoints: function () {\n        var e;\n        z.column.prototype.generatePoints.apply(this);\n        var a = 0;\n\n        for (e = this.points.length; a < e; a++) {\n          var d = this.points[a];\n          var g = this.processedYData[a];\n          if (d.isIntermediateSum || d.isSum) d.y = x(g);\n        }\n      },\n      translate: function () {\n        var e = this.options,\n            a = this.yAxis,\n            d,\n            g = C(e.minPointLength, 5),\n            b = g / 2,\n            f = e.threshold,\n            t = e.stacking,\n            n = a.waterfall.stacks[this.stackKey];\n        z.column.prototype.translate.apply(this);\n        var y = d = f;\n        var h = this.points;\n        var c = 0;\n\n        for (e = h.length; c < e; c++) {\n          var m = h[c];\n          var x = this.processedYData[c];\n          var q = m.shapeArgs;\n          var p = [0, x];\n          var w = m.y;\n\n          if (t) {\n            if (n) {\n              p = n[c];\n\n              if (\"overlap\" === t) {\n                var u = p.stackState[p.stateIndex--];\n                u = 0 <= w ? u : u - w;\n                Object.hasOwnProperty.call(p, \"absolutePos\") && delete p.absolutePos;\n                Object.hasOwnProperty.call(p, \"absoluteNeg\") && delete p.absoluteNeg;\n              } else 0 <= w ? (u = p.threshold + p.posTotal, p.posTotal -= w) : (u = p.threshold + p.negTotal, p.negTotal -= w, u -= w), !p.posTotal && Object.hasOwnProperty.call(p, \"absolutePos\") && (p.posTotal = p.absolutePos, delete p.absolutePos), !p.negTotal && Object.hasOwnProperty.call(p, \"absoluteNeg\") && (p.negTotal = p.absoluteNeg, delete p.absoluteNeg);\n\n              m.isSum || (p.connectorThreshold = p.threshold + p.stackTotal);\n              a.reversed ? (x = 0 <= w ? u - w : u + w, w = u) : (x = u, w = u - w);\n              m.below = x <= C(f, 0);\n              q.y = a.translate(x, 0, 1, 0, 1);\n              q.height = Math.abs(q.y - a.translate(w, 0, 1, 0, 1));\n            }\n\n            if (w = a.waterfall.dummyStackItem) w.x = c, w.label = n[c].label, w.setOffset(this.pointXOffset || 0, this.barW || 0, this.stackedYNeg[c], this.stackedYPos[c]);\n          } else u = Math.max(y, y + w) + p[0], q.y = a.translate(u, 0, 1, 0, 1), m.isSum ? (q.y = a.translate(p[1], 0, 1, 0, 1), q.height = Math.min(a.translate(p[0], 0, 1, 0, 1), a.len) - q.y) : m.isIntermediateSum ? (0 <= w ? (x = p[1] + d, w = d) : (x = d, w = p[1] + d), a.reversed && (x ^= w, w ^= x, x ^= w), q.y = a.translate(x, 0, 1, 0, 1), q.height = Math.abs(q.y - Math.min(a.translate(w, 0, 1, 0, 1), a.len)), d += p[1]) : (q.height = 0 < x ? a.translate(y, 0, 1, 0, 1) - q.y : a.translate(y, 0, 1, 0, 1) - a.translate(y - x, 0, 1, 0, 1), y += x, m.below = y < C(f, 0)), 0 > q.height && (q.y += q.height, q.height *= -1);\n\n          m.plotY = q.y = Math.round(q.y) - this.borderWidth % 2 / 2;\n          q.height = Math.max(Math.round(q.height), .001);\n          m.yBottom = q.y + q.height;\n          q.height <= g && !m.isNull ? (q.height = g, q.y -= b, m.plotY = q.y, m.minPointLengthOffset = 0 > m.y ? -b : b) : (m.isNull && (q.width = 0), m.minPointLengthOffset = 0);\n          q = m.plotY + (m.negative ? q.height : 0);\n          this.chart.inverted ? m.tooltipPos[0] = a.len - q : m.tooltipPos[1] = q;\n        }\n      },\n      processData: function (a) {\n        var e = this.options,\n            d = this.yData,\n            g = e.data,\n            b = d.length,\n            f = e.threshold || 0,\n            t,\n            n,\n            l,\n            h,\n            c;\n\n        for (c = n = t = l = h = 0; c < b; c++) {\n          var m = d[c];\n          var q = g && g[c] ? g[c] : {};\n          \"sum\" === m || q.isSum ? d[c] = x(n) : \"intermediateSum\" === m || q.isIntermediateSum ? (d[c] = x(t), t = 0) : (n += m, t += m);\n          l = Math.min(n, l);\n          h = Math.max(n, h);\n        }\n\n        v.prototype.processData.call(this, a);\n        e.stacking || (this.dataMin = l + f, this.dataMax = h);\n      },\n      toYData: function (a) {\n        return a.isSum ? \"sum\" : a.isIntermediateSum ? \"intermediateSum\" : a.y;\n      },\n      updateParallelArrays: function (a, e) {\n        v.prototype.updateParallelArrays.call(this, a, e);\n        if (\"sum\" === this.yData[0] || \"intermediateSum\" === this.yData[0]) this.yData[0] = null;\n      },\n      pointAttribs: function (a, e) {\n        var d = this.options.upColor;\n        d && !a.options.color && (a.color = 0 < a.y ? d : null);\n        a = z.column.prototype.pointAttribs.call(this, a, e);\n        delete a.dashstyle;\n        return a;\n      },\n      getGraphPath: function () {\n        return [[\"M\", 0, 0]];\n      },\n      getCrispPath: function () {\n        var a = this.data,\n            e = this.yAxis,\n            d = a.length,\n            g = Math.round(this.graph.strokeWidth()) % 2 / 2,\n            b = Math.round(this.borderWidth) % 2 / 2,\n            f = this.xAxis.reversed,\n            t = this.yAxis.reversed,\n            n = this.options.stacking,\n            y = [],\n            c;\n\n        for (c = 1; c < d; c++) {\n          var h = a[c].shapeArgs;\n          var m = a[c - 1];\n          var q = a[c - 1].shapeArgs;\n          var p = e.waterfall.stacks[this.stackKey];\n          var x = 0 < m.y ? -q.height : 0;\n          p && q && h && (p = p[c - 1], n ? (p = p.connectorThreshold, x = Math.round(e.translate(p, 0, 1, 0, 1) + (t ? x : 0)) - g) : x = q.y + m.minPointLengthOffset + b - g, y.push([\"M\", (q.x || 0) + (f ? 0 : q.width || 0), x], [\"L\", (h.x || 0) + (f ? h.width || 0 : 0), x]));\n          !n && y.length && q && (0 > m.y && !t || 0 < m.y && t) && (y[y.length - 2][2] += q.height, y[y.length - 1][2] += q.height);\n        }\n\n        return y;\n      },\n      drawGraph: function () {\n        v.prototype.drawGraph.call(this);\n        this.graph.attr({\n          d: this.getCrispPath()\n        });\n      },\n      setStackedPoints: function () {\n        function a(d, g, a, e) {\n          if (E) for (a; a < E; a++) v.stackState[a] += e;else v.stackState[0] = d, E = v.stackState.length;\n          v.stackState.push(v.stackState[E - 1] + g);\n        }\n\n        var e = this.options,\n            d = this.yAxis.waterfall.stacks,\n            g = e.threshold,\n            b = g || 0,\n            f = b,\n            t = this.stackKey,\n            n = this.xData,\n            c = n.length,\n            h,\n            q,\n            m;\n        this.yAxis.stacking.usePercentage = !1;\n        var p = q = m = b;\n\n        if (this.visible || !this.chart.options.chart.ignoreHiddenSeries) {\n          var x = d.changed;\n          (h = d.alreadyChanged) && 0 > h.indexOf(t) && (x = !0);\n          d[t] || (d[t] = {});\n          h = d[t];\n\n          for (var w = 0; w < c; w++) {\n            var u = n[w];\n            if (!h[u] || x) h[u] = {\n              negTotal: 0,\n              posTotal: 0,\n              stackTotal: 0,\n              threshold: 0,\n              stateIndex: 0,\n              stackState: [],\n              label: x && h[u] ? h[u].label : void 0\n            };\n            var v = h[u];\n            var z = this.yData[w];\n            0 <= z ? v.posTotal += z : v.negTotal += z;\n            var B = e.data[w];\n            u = v.absolutePos = v.posTotal;\n            var C = v.absoluteNeg = v.negTotal;\n            v.stackTotal = u + C;\n            var E = v.stackState.length;\n            B && B.isIntermediateSum ? (a(m, q, 0, m), m = q, q = g, b ^= f, f ^= b, b ^= f) : B && B.isSum ? (a(g, p, E), b = g) : (a(b, z, 0, p), B && (p += z, q += z));\n            v.stateIndex++;\n            v.threshold = b;\n            b += v.stackTotal;\n          }\n\n          d.changed = !1;\n          d.alreadyChanged || (d.alreadyChanged = []);\n          d.alreadyChanged.push(t);\n        }\n      },\n      getExtremes: function () {\n        var a = this.options.stacking;\n\n        if (a) {\n          var b = this.yAxis;\n          b = b.waterfall.stacks;\n          var d = this.stackedYNeg = [];\n          var g = this.stackedYPos = [];\n          \"overlap\" === a ? m(b[this.stackKey], function (a) {\n            d.push(e(a.stackState));\n            g.push(B(a.stackState));\n          }) : m(b[this.stackKey], function (a) {\n            d.push(a.negTotal + a.threshold);\n            g.push(a.posTotal + a.threshold);\n          });\n          return {\n            dataMin: e(d),\n            dataMax: B(g)\n          };\n        }\n\n        return {\n          dataMin: this.dataMin,\n          dataMax: this.dataMax\n        };\n      }\n    }, {\n      getClassName: function () {\n        var a = f.prototype.getClassName.call(this);\n        this.isSum ? a += \" highcharts-sum\" : this.isIntermediateSum && (a += \" highcharts-intermediate-sum\");\n        return a;\n      },\n      isValid: function () {\n        return w(this.y) || this.isSum || !!this.isIntermediateSum;\n      }\n    });\n    \"\";\n    p.compose(c, h);\n    return p;\n  });\n  A(c, \"Series/PolygonSeries.js\", [c[\"Core/Series/Series.js\"], c[\"Core/Globals.js\"], c[\"Mixins/LegendSymbol.js\"]], function (c, b, h) {\n    var a = c.seriesTypes,\n        f = b.Series;\n    c.seriesType(\"polygon\", \"scatter\", {\n      marker: {\n        enabled: !1,\n        states: {\n          hover: {\n            enabled: !1\n          }\n        }\n      },\n      stickyTracking: !1,\n      tooltip: {\n        followPointer: !0,\n        pointFormat: \"\"\n      },\n      trackByArea: !0\n    }, {\n      type: \"polygon\",\n      getGraphPath: function () {\n        for (var a = f.prototype.getGraphPath.call(this), b = a.length + 1; b--;) (b === a.length || \"M\" === a[b][0]) && 0 < b && a.splice(b, 0, [\"Z\"]);\n\n        return this.areaPath = a;\n      },\n      drawGraph: function () {\n        this.options.fillColor = this.color;\n        a.area.prototype.drawGraph.call(this);\n      },\n      drawLegendSymbol: h.drawRectangle,\n      drawTracker: f.prototype.drawTracker,\n      setStackedPoints: b.noop\n    });\n    \"\";\n  });\n  A(c, \"Series/Bubble/BubbleLegend.js\", [c[\"Core/Chart/Chart.js\"], c[\"Core/Color/Color.js\"], c[\"Core/Globals.js\"], c[\"Core/Legend.js\"], c[\"Core/Utilities.js\"]], function (c, b, h, a, f) {\n    var q = b.parse;\n    b = f.addEvent;\n    var u = f.arrayMax,\n        z = f.arrayMin,\n        E = f.isNumber,\n        B = f.merge,\n        e = f.objectEach,\n        x = f.pick,\n        w = f.setOptions,\n        m = f.stableSort,\n        C = f.wrap;\n    \"\";\n    var v = h.Series,\n        p = h.noop;\n    w({\n      legend: {\n        bubbleLegend: {\n          borderColor: void 0,\n          borderWidth: 2,\n          className: void 0,\n          color: void 0,\n          connectorClassName: void 0,\n          connectorColor: void 0,\n          connectorDistance: 60,\n          connectorWidth: 1,\n          enabled: !1,\n          labels: {\n            className: void 0,\n            allowOverlap: !1,\n            format: \"\",\n            formatter: void 0,\n            align: \"right\",\n            style: {\n              fontSize: 10,\n              color: void 0\n            },\n            x: 0,\n            y: 0\n          },\n          maxSize: 60,\n          minSize: 10,\n          legendIndex: 0,\n          ranges: {\n            value: void 0,\n            borderColor: void 0,\n            color: void 0,\n            connectorColor: void 0\n          },\n          sizeBy: \"area\",\n          sizeByAbsoluteValue: !1,\n          zIndex: 1,\n          zThreshold: 0\n        }\n      }\n    });\n\n    w = function () {\n      function a(a, d) {\n        this.options = this.symbols = this.visible = this.ranges = this.movementX = this.maxLabel = this.legendSymbol = this.legendItemWidth = this.legendItemHeight = this.legendItem = this.legendGroup = this.legend = this.fontMetrics = this.chart = void 0;\n        this.setState = p;\n        this.init(a, d);\n      }\n\n      a.prototype.init = function (a, d) {\n        this.options = a;\n        this.visible = !0;\n        this.chart = d.chart;\n        this.legend = d;\n      };\n\n      a.prototype.addToLegend = function (a) {\n        a.splice(this.options.legendIndex, 0, this);\n      };\n\n      a.prototype.drawLegendSymbol = function (a) {\n        var d = this.chart,\n            g = this.options,\n            e = x(a.options.itemDistance, 20),\n            b = g.ranges;\n        var f = g.connectorDistance;\n        this.fontMetrics = d.renderer.fontMetrics(g.labels.style.fontSize.toString() + \"px\");\n        b && b.length && E(b[0].value) ? (m(b, function (d, a) {\n          return a.value - d.value;\n        }), this.ranges = b, this.setOptions(), this.render(), d = this.getMaxLabelSize(), b = this.ranges[0].radius, a = 2 * b, f = f - b + d.width, f = 0 < f ? f : 0, this.maxLabel = d, this.movementX = \"left\" === g.labels.align ? f : 0, this.legendItemWidth = a + f + e, this.legendItemHeight = a + this.fontMetrics.h / 2) : a.options.bubbleLegend.autoRanges = !0;\n      };\n\n      a.prototype.setOptions = function () {\n        var a = this.ranges,\n            d = this.options,\n            g = this.chart.series[d.seriesIndex],\n            e = this.legend.baseline,\n            b = {\n          \"z-index\": d.zIndex,\n          \"stroke-width\": d.borderWidth\n        },\n            f = {\n          \"z-index\": d.zIndex,\n          \"stroke-width\": d.connectorWidth\n        },\n            n = this.getLabelStyles(),\n            c = g.options.marker.fillOpacity,\n            h = this.chart.styledMode;\n        a.forEach(function (t, r) {\n          h || (b.stroke = x(t.borderColor, d.borderColor, g.color), b.fill = x(t.color, d.color, 1 !== c ? q(g.color).setOpacity(c).get(\"rgba\") : g.color), f.stroke = x(t.connectorColor, d.connectorColor, g.color));\n          a[r].radius = this.getRangeRadius(t.value);\n          a[r] = B(a[r], {\n            center: a[0].radius - a[r].radius + e\n          });\n          h || B(!0, a[r], {\n            bubbleStyle: B(!1, b),\n            connectorStyle: B(!1, f),\n            labelStyle: n\n          });\n        }, this);\n      };\n\n      a.prototype.getLabelStyles = function () {\n        var a = this.options,\n            d = {},\n            g = \"left\" === a.labels.align,\n            b = this.legend.options.rtl;\n        e(a.labels.style, function (a, g) {\n          \"color\" !== g && \"fontSize\" !== g && \"z-index\" !== g && (d[g] = a);\n        });\n        return B(!1, d, {\n          \"font-size\": a.labels.style.fontSize,\n          fill: x(a.labels.style.color, \"#000000\"),\n          \"z-index\": a.zIndex,\n          align: b || g ? \"right\" : \"left\"\n        });\n      };\n\n      a.prototype.getRangeRadius = function (a) {\n        var d = this.options;\n        return this.chart.series[this.options.seriesIndex].getRadius.call(this, d.ranges[d.ranges.length - 1].value, d.ranges[0].value, d.minSize, d.maxSize, a);\n      };\n\n      a.prototype.render = function () {\n        var a = this.chart.renderer,\n            d = this.options.zThreshold;\n        this.symbols || (this.symbols = {\n          connectors: [],\n          bubbleItems: [],\n          labels: []\n        });\n        this.legendSymbol = a.g(\"bubble-legend\");\n        this.legendItem = a.g(\"bubble-legend-item\");\n        this.legendSymbol.translateX = 0;\n        this.legendSymbol.translateY = 0;\n        this.ranges.forEach(function (a) {\n          a.value >= d && this.renderRange(a);\n        }, this);\n        this.legendSymbol.add(this.legendItem);\n        this.legendItem.add(this.legendGroup);\n        this.hideOverlappingLabels();\n      };\n\n      a.prototype.renderRange = function (a) {\n        var d = this.options,\n            g = d.labels,\n            e = this.chart.renderer,\n            b = this.symbols,\n            f = b.labels,\n            n = a.center,\n            k = Math.abs(a.radius),\n            c = d.connectorDistance || 0,\n            h = g.align,\n            l = g.style.fontSize;\n        c = this.legend.options.rtl || \"left\" === h ? -c : c;\n        g = d.connectorWidth;\n        var m = this.ranges[0].radius || 0,\n            q = n - k - d.borderWidth / 2 + g / 2;\n        l = l / 2 - (this.fontMetrics.h - l) / 2;\n        var p = e.styledMode;\n        \"center\" === h && (c = 0, d.connectorDistance = 0, a.labelStyle.align = \"center\");\n        h = q + d.labels.y;\n        var x = m + c + d.labels.x;\n        b.bubbleItems.push(e.circle(m, n + ((q % 1 ? 1 : .5) - (g % 2 ? 0 : .5)), k).attr(p ? {} : a.bubbleStyle).addClass((p ? \"highcharts-color-\" + this.options.seriesIndex + \" \" : \"\") + \"highcharts-bubble-legend-symbol \" + (d.className || \"\")).add(this.legendSymbol));\n        b.connectors.push(e.path(e.crispLine([[\"M\", m, q], [\"L\", m + c, q]], d.connectorWidth)).attr(p ? {} : a.connectorStyle).addClass((p ? \"highcharts-color-\" + this.options.seriesIndex + \" \" : \"\") + \"highcharts-bubble-legend-connectors \" + (d.connectorClassName || \"\")).add(this.legendSymbol));\n        a = e.text(this.formatLabel(a), x, h + l).attr(p ? {} : a.labelStyle).addClass(\"highcharts-bubble-legend-labels \" + (d.labels.className || \"\")).add(this.legendSymbol);\n        f.push(a);\n        a.placed = !0;\n        a.alignAttr = {\n          x: x,\n          y: h + l\n        };\n      };\n\n      a.prototype.getMaxLabelSize = function () {\n        var a, d;\n        this.symbols.labels.forEach(function (g) {\n          d = g.getBBox(!0);\n          a = a ? d.width > a.width ? d : a : d;\n        });\n        return a || {};\n      };\n\n      a.prototype.formatLabel = function (a) {\n        var d = this.options,\n            g = d.labels.formatter;\n        d = d.labels.format;\n        var e = this.chart.numberFormatter;\n        return d ? f.format(d, a) : g ? g.call(a) : e(a.value, 1);\n      };\n\n      a.prototype.hideOverlappingLabels = function () {\n        var a = this.chart,\n            d = this.symbols;\n        !this.options.labels.allowOverlap && d && (a.hideOverlappingLabels(d.labels), d.labels.forEach(function (a, e) {\n          a.newOpacity ? a.newOpacity !== a.oldOpacity && d.connectors[e].show() : d.connectors[e].hide();\n        }));\n      };\n\n      a.prototype.getRanges = function () {\n        var a = this.legend.bubbleLegend,\n            d = a.options.ranges,\n            g,\n            e = Number.MAX_VALUE,\n            b = -Number.MAX_VALUE;\n        a.chart.series.forEach(function (d) {\n          d.isBubble && !d.ignoreSeries && (g = d.zData.filter(E), g.length && (e = x(d.options.zMin, Math.min(e, Math.max(z(g), !1 === d.options.displayNegative ? d.options.zThreshold : -Number.MAX_VALUE))), b = x(d.options.zMax, Math.max(b, u(g)))));\n        });\n        var f = e === b ? [{\n          value: b\n        }] : [{\n          value: e\n        }, {\n          value: (e + b) / 2\n        }, {\n          value: b,\n          autoRanges: !0\n        }];\n        d.length && d[0].radius && f.reverse();\n        f.forEach(function (a, g) {\n          d && d[g] && (f[g] = B(!1, d[g], a));\n        });\n        return f;\n      };\n\n      a.prototype.predictBubbleSizes = function () {\n        var a = this.chart,\n            d = this.fontMetrics,\n            g = a.legend.options,\n            e = \"horizontal\" === g.layout,\n            b = e ? a.legend.lastLineHeight : 0,\n            f = a.plotSizeX,\n            n = a.plotSizeY,\n            c = a.series[this.options.seriesIndex];\n        a = Math.ceil(c.minPxSize);\n        var h = Math.ceil(c.maxPxSize);\n        c = c.options.maxSize;\n        var l = Math.min(n, f);\n        if (g.floating || !/%$/.test(c)) d = h;else if (c = parseFloat(c), d = (l + b - d.h / 2) * c / 100 / (c / 100 + 1), e && n - d >= f || !e && f - d >= n) d = h;\n        return [a, Math.ceil(d)];\n      };\n\n      a.prototype.updateRanges = function (a, d) {\n        var g = this.legend.options.bubbleLegend;\n        g.minSize = a;\n        g.maxSize = d;\n        g.ranges = this.getRanges();\n      };\n\n      a.prototype.correctSizes = function () {\n        var a = this.legend,\n            d = this.chart.series[this.options.seriesIndex];\n        1 < Math.abs(Math.ceil(d.maxPxSize) - this.options.maxSize) && (this.updateRanges(this.options.minSize, d.maxPxSize), a.render());\n      };\n\n      return a;\n    }();\n\n    b(a, \"afterGetAllItems\", function (a) {\n      var e = this.bubbleLegend,\n          d = this.options,\n          g = d.bubbleLegend,\n          b = this.chart.getVisibleBubbleSeriesIndex();\n      e && e.ranges && e.ranges.length && (g.ranges.length && (g.autoRanges = !!g.ranges[0].autoRanges), this.destroyItem(e));\n      0 <= b && d.enabled && g.enabled && (g.seriesIndex = b, this.bubbleLegend = new h.BubbleLegend(g, this), this.bubbleLegend.addToLegend(a.allItems));\n    });\n\n    c.prototype.getVisibleBubbleSeriesIndex = function () {\n      for (var a = this.series, e = 0; e < a.length;) {\n        if (a[e] && a[e].isBubble && a[e].visible && a[e].zData.length) return e;\n        e++;\n      }\n\n      return -1;\n    };\n\n    a.prototype.getLinesHeights = function () {\n      var a = this.allItems,\n          e = [],\n          d = a.length,\n          g,\n          b = 0;\n\n      for (g = 0; g < d; g++) if (a[g].legendItemHeight && (a[g].itemHeight = a[g].legendItemHeight), a[g] === a[d - 1] || a[g + 1] && a[g]._legendItemPos[1] !== a[g + 1]._legendItemPos[1]) {\n        e.push({\n          height: 0\n        });\n        var f = e[e.length - 1];\n\n        for (b; b <= g; b++) a[b].itemHeight > f.height && (f.height = a[b].itemHeight);\n\n        f.step = g;\n      }\n\n      return e;\n    };\n\n    a.prototype.retranslateItems = function (a) {\n      var e,\n          d,\n          g,\n          b = this.options.rtl,\n          f = 0;\n      this.allItems.forEach(function (t, n) {\n        e = t.legendGroup.translateX;\n        d = t._legendItemPos[1];\n        if ((g = t.movementX) || b && t.ranges) g = b ? e - t.options.maxSize / 2 : e + g, t.legendGroup.attr({\n          translateX: g\n        });\n        n > a[f].step && f++;\n        t.legendGroup.attr({\n          translateY: Math.round(d + a[f].height / 2)\n        });\n        t._legendItemPos[1] = d + a[f].height / 2;\n      });\n    };\n\n    b(v, \"legendItemClick\", function () {\n      var a = this.chart,\n          e = this.visible,\n          d = this.chart.legend;\n      d && d.bubbleLegend && (this.visible = !e, this.ignoreSeries = e, a = 0 <= a.getVisibleBubbleSeriesIndex(), d.bubbleLegend.visible !== a && (d.update({\n        bubbleLegend: {\n          enabled: a\n        }\n      }), d.bubbleLegend.visible = a), this.visible = e);\n    });\n    C(c.prototype, \"drawChartBox\", function (a, b, d) {\n      var g = this.legend,\n          f = 0 <= this.getVisibleBubbleSeriesIndex();\n\n      if (g && g.options.enabled && g.bubbleLegend && g.options.bubbleLegend.autoRanges && f) {\n        var c = g.bubbleLegend.options;\n        f = g.bubbleLegend.predictBubbleSizes();\n        g.bubbleLegend.updateRanges(f[0], f[1]);\n        c.placed || (g.group.placed = !1, g.allItems.forEach(function (d) {\n          d.legendGroup.translateY = null;\n        }));\n        g.render();\n        this.getMargins();\n        this.axes.forEach(function (d) {\n          d.visible && d.render();\n          c.placed || (d.setScale(), d.updateNames(), e(d.ticks, function (d) {\n            d.isNew = !0;\n            d.isNewLabel = !0;\n          }));\n        });\n        c.placed = !0;\n        this.getMargins();\n        a.call(this, b, d);\n        g.bubbleLegend.correctSizes();\n        g.retranslateItems(g.getLinesHeights());\n      } else a.call(this, b, d), g && g.options.enabled && g.bubbleLegend && (g.render(), g.retranslateItems(g.getLinesHeights()));\n    });\n    h.BubbleLegend = w;\n    return h.BubbleLegend;\n  });\n  A(c, \"Series/Bubble/BubbleSeries.js\", [c[\"Core/Axis/Axis.js\"], c[\"Core/Series/Series.js\"], c[\"Core/Color/Color.js\"], c[\"Core/Globals.js\"], c[\"Core/Series/Point.js\"], c[\"Core/Utilities.js\"]], function (c, b, h, a, f, q) {\n    var u = h.parse;\n    h = a.noop;\n    var z = q.arrayMax,\n        E = q.arrayMin,\n        B = q.clamp,\n        e = q.extend,\n        x = q.isNumber,\n        w = q.pick,\n        m = q.pInt,\n        C = a.Series,\n        v = b.seriesTypes;\n    \"\";\n    b.seriesType(\"bubble\", \"scatter\", {\n      dataLabels: {\n        formatter: function () {\n          return this.point.z;\n        },\n        inside: !0,\n        verticalAlign: \"middle\"\n      },\n      animationLimit: 250,\n      marker: {\n        lineColor: null,\n        lineWidth: 1,\n        fillOpacity: .5,\n        radius: null,\n        states: {\n          hover: {\n            radiusPlus: 0\n          }\n        },\n        symbol: \"circle\"\n      },\n      minSize: 8,\n      maxSize: \"20%\",\n      softThreshold: !1,\n      states: {\n        hover: {\n          halo: {\n            size: 5\n          }\n        }\n      },\n      tooltip: {\n        pointFormat: \"({point.x}, {point.y}), Size: {point.z}\"\n      },\n      turboThreshold: 0,\n      zThreshold: 0,\n      zoneAxis: \"z\"\n    }, {\n      pointArrayMap: [\"y\", \"z\"],\n      parallelArrays: [\"x\", \"y\", \"z\"],\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      specialGroup: \"group\",\n      bubblePadding: !0,\n      zoneAxis: \"z\",\n      directTouch: !0,\n      isBubble: !0,\n      pointAttribs: function (a, e) {\n        var b = this.options.marker.fillOpacity;\n        a = C.prototype.pointAttribs.call(this, a, e);\n        1 !== b && (a.fill = u(a.fill).setOpacity(b).get(\"rgba\"));\n        return a;\n      },\n      getRadii: function (a, e, b) {\n        var d = this.zData,\n            g = this.yData,\n            f = b.minPxSize,\n            c = b.maxPxSize,\n            t = [];\n        var n = 0;\n\n        for (b = d.length; n < b; n++) {\n          var h = d[n];\n          t.push(this.getRadius(a, e, f, c, h, g[n]));\n        }\n\n        this.radii = t;\n      },\n      getRadius: function (a, e, b, d, g, f) {\n        var r = this.options,\n            t = \"width\" !== r.sizeBy,\n            n = r.zThreshold,\n            c = e - a,\n            h = .5;\n        if (null === f || null === g) return null;\n\n        if (x(g)) {\n          r.sizeByAbsoluteValue && (g = Math.abs(g - n), c = Math.max(e - n, Math.abs(a - n)), a = 0);\n          if (g < a) return b / 2 - 1;\n          0 < c && (h = (g - a) / c);\n        }\n\n        t && 0 <= h && (h = Math.sqrt(h));\n        return Math.ceil(b + h * (d - b)) / 2;\n      },\n      animate: function (a) {\n        !a && this.points.length < this.options.animationLimit && this.points.forEach(function (a) {\n          var e = a.graphic;\n          e && e.width && (this.hasRendered || e.attr({\n            x: a.plotX,\n            y: a.plotY,\n            width: 1,\n            height: 1\n          }), e.animate(this.markerAttribs(a), this.options.animation));\n        }, this);\n      },\n      hasData: function () {\n        return !!this.processedXData.length;\n      },\n      translate: function () {\n        var a,\n            b = this.data,\n            f = this.radii;\n        v.scatter.prototype.translate.call(this);\n\n        for (a = b.length; a--;) {\n          var d = b[a];\n          var g = f ? f[a] : 0;\n          x(g) && g >= this.minPxSize / 2 ? (d.marker = e(d.marker, {\n            radius: g,\n            width: 2 * g,\n            height: 2 * g\n          }), d.dlBox = {\n            x: d.plotX - g,\n            y: d.plotY - g,\n            width: 2 * g,\n            height: 2 * g\n          }) : d.shapeArgs = d.plotY = d.dlBox = void 0;\n        }\n      },\n      alignDataLabel: v.column.prototype.alignDataLabel,\n      buildKDTree: h,\n      applyZones: h\n    }, {\n      haloPath: function (a) {\n        return f.prototype.haloPath.call(this, 0 === a ? 0 : (this.marker ? this.marker.radius || 0 : 0) + a);\n      },\n      ttBelow: !1\n    });\n\n    c.prototype.beforePadding = function () {\n      var a = this,\n          e = this.len,\n          b = this.chart,\n          d = 0,\n          g = e,\n          f = this.isXAxis,\n          c = f ? \"xData\" : \"yData\",\n          t = this.min,\n          n = {},\n          h = Math.min(b.plotWidth, b.plotHeight),\n          q = Number.MAX_VALUE,\n          u = -Number.MAX_VALUE,\n          v = this.max - t,\n          F = e / v,\n          C = [];\n      this.series.forEach(function (d) {\n        var e = d.options;\n        !d.bubblePadding || !d.visible && b.options.chart.ignoreHiddenSeries || (a.allowZoomOutside = !0, C.push(d), f && ([\"minSize\", \"maxSize\"].forEach(function (d) {\n          var a = e[d],\n              g = /%$/.test(a);\n          a = m(a);\n          n[d] = g ? h * a / 100 : a;\n        }), d.minPxSize = n.minSize, d.maxPxSize = Math.max(n.maxSize, n.minSize), d = d.zData.filter(x), d.length && (q = w(e.zMin, B(E(d), !1 === e.displayNegative ? e.zThreshold : -Number.MAX_VALUE, q)), u = w(e.zMax, Math.max(u, z(d))))));\n      });\n      C.forEach(function (e) {\n        var b = e[c],\n            n = b.length;\n        f && e.getRadii(q, u, e);\n        if (0 < v) for (; n--;) if (x(b[n]) && a.dataMin <= b[n] && b[n] <= a.max) {\n          var r = e.radii ? e.radii[n] : 0;\n          d = Math.min((b[n] - t) * F - r, d);\n          g = Math.max((b[n] - t) * F + r, g);\n        }\n      });\n      C.length && 0 < v && !this.logarithmic && (g -= e, F *= (e + Math.max(0, d) - Math.min(g, e)) / e, [[\"min\", \"userMin\", d], [\"max\", \"userMax\", g]].forEach(function (d) {\n        \"undefined\" === typeof w(a.options[d[0]], a[d[1]]) && (a[d[0]] += d[2] / F);\n      }));\n    };\n\n    \"\";\n  });\n  A(c, \"Series/Networkgraph/DraggableNodes.js\", [c[\"Core/Chart/Chart.js\"], c[\"Core/Globals.js\"], c[\"Core/Utilities.js\"]], function (c, b, h) {\n    var a = h.addEvent;\n    b.dragNodesMixin = {\n      onMouseDown: function (a, b) {\n        b = this.chart.pointer.normalize(b);\n        a.fixedPosition = {\n          chartX: b.chartX,\n          chartY: b.chartY,\n          plotX: a.plotX,\n          plotY: a.plotY\n        };\n        a.inDragMode = !0;\n      },\n      onMouseMove: function (a, b) {\n        if (a.fixedPosition && a.inDragMode) {\n          var f = this.chart;\n          b = f.pointer.normalize(b);\n          var c = a.fixedPosition.chartX - b.chartX,\n              h = a.fixedPosition.chartY - b.chartY;\n          b = f.graphLayoutsLookup;\n          if (5 < Math.abs(c) || 5 < Math.abs(h)) c = a.fixedPosition.plotX - c, h = a.fixedPosition.plotY - h, f.isInsidePlot(c, h) && (a.plotX = c, a.plotY = h, a.hasDragged = !0, this.redrawHalo(a), b.forEach(function (a) {\n            a.restartSimulation();\n          }));\n        }\n      },\n      onMouseUp: function (a, b) {\n        a.fixedPosition && (a.hasDragged && (this.layout.enableSimulation ? this.layout.start() : this.chart.redraw()), a.inDragMode = a.hasDragged = !1, this.options.fixedDraggable || delete a.fixedPosition);\n      },\n      redrawHalo: function (a) {\n        a && this.halo && this.halo.attr({\n          d: a.haloPath(this.options.states.hover.halo.size)\n        });\n      }\n    };\n    a(c, \"load\", function () {\n      var b = this,\n          c,\n          h,\n          z;\n      b.container && (c = a(b.container, \"mousedown\", function (f) {\n        var c = b.hoverPoint;\n        c && c.series && c.series.hasDraggableNodes && c.series.options.draggable && (c.series.onMouseDown(c, f), h = a(b.container, \"mousemove\", function (a) {\n          return c && c.series && c.series.onMouseMove(c, a);\n        }), z = a(b.container.ownerDocument, \"mouseup\", function (a) {\n          h();\n          z();\n          return c && c.series && c.series.onMouseUp(c, a);\n        }));\n      }));\n      a(b, \"destroy\", function () {\n        c();\n      });\n    });\n  });\n  A(c, \"Series/Networkgraph/Integrations.js\", [c[\"Core/Globals.js\"]], function (c) {\n    c.networkgraphIntegrations = {\n      verlet: {\n        attractiveForceFunction: function (b, c) {\n          return (c - b) / b;\n        },\n        repulsiveForceFunction: function (b, c) {\n          return (c - b) / b * (c > b ? 1 : 0);\n        },\n        barycenter: function () {\n          var b = this.options.gravitationalConstant,\n              c = this.barycenter.xFactor,\n              a = this.barycenter.yFactor;\n          c = (c - (this.box.left + this.box.width) / 2) * b;\n          a = (a - (this.box.top + this.box.height) / 2) * b;\n          this.nodes.forEach(function (b) {\n            b.fixedPosition || (b.plotX -= c / b.mass / b.degree, b.plotY -= a / b.mass / b.degree);\n          });\n        },\n        repulsive: function (b, c, a) {\n          c = c * this.diffTemperature / b.mass / b.degree;\n          b.fixedPosition || (b.plotX += a.x * c, b.plotY += a.y * c);\n        },\n        attractive: function (b, c, a) {\n          var f = b.getMass(),\n              h = -a.x * c * this.diffTemperature;\n          c = -a.y * c * this.diffTemperature;\n          b.fromNode.fixedPosition || (b.fromNode.plotX -= h * f.fromNode / b.fromNode.degree, b.fromNode.plotY -= c * f.fromNode / b.fromNode.degree);\n          b.toNode.fixedPosition || (b.toNode.plotX += h * f.toNode / b.toNode.degree, b.toNode.plotY += c * f.toNode / b.toNode.degree);\n        },\n        integrate: function (b, c) {\n          var a = -b.options.friction,\n              f = b.options.maxSpeed,\n              h = (c.plotX + c.dispX - c.prevX) * a;\n          a *= c.plotY + c.dispY - c.prevY;\n          var u = Math.abs,\n              z = u(h) / (h || 1);\n          u = u(a) / (a || 1);\n          h = z * Math.min(f, Math.abs(h));\n          a = u * Math.min(f, Math.abs(a));\n          c.prevX = c.plotX + c.dispX;\n          c.prevY = c.plotY + c.dispY;\n          c.plotX += h;\n          c.plotY += a;\n          c.temperature = b.vectorLength({\n            x: h,\n            y: a\n          });\n        },\n        getK: function (b) {\n          return Math.pow(b.box.width * b.box.height / b.nodes.length, .5);\n        }\n      },\n      euler: {\n        attractiveForceFunction: function (b, c) {\n          return b * b / c;\n        },\n        repulsiveForceFunction: function (b, c) {\n          return c * c / b;\n        },\n        barycenter: function () {\n          var b = this.options.gravitationalConstant,\n              c = this.barycenter.xFactor,\n              a = this.barycenter.yFactor;\n          this.nodes.forEach(function (f) {\n            if (!f.fixedPosition) {\n              var h = f.getDegree();\n              h *= 1 + h / 2;\n              f.dispX += (c - f.plotX) * b * h / f.degree;\n              f.dispY += (a - f.plotY) * b * h / f.degree;\n            }\n          });\n        },\n        repulsive: function (b, c, a, f) {\n          b.dispX += a.x / f * c / b.degree;\n          b.dispY += a.y / f * c / b.degree;\n        },\n        attractive: function (b, c, a, f) {\n          var h = b.getMass(),\n              u = a.x / f * c;\n          c *= a.y / f;\n          b.fromNode.fixedPosition || (b.fromNode.dispX -= u * h.fromNode / b.fromNode.degree, b.fromNode.dispY -= c * h.fromNode / b.fromNode.degree);\n          b.toNode.fixedPosition || (b.toNode.dispX += u * h.toNode / b.toNode.degree, b.toNode.dispY += c * h.toNode / b.toNode.degree);\n        },\n        integrate: function (b, c) {\n          c.dispX += c.dispX * b.options.friction;\n          c.dispY += c.dispY * b.options.friction;\n          var a = c.temperature = b.vectorLength({\n            x: c.dispX,\n            y: c.dispY\n          });\n          0 !== a && (c.plotX += c.dispX / a * Math.min(Math.abs(c.dispX), b.temperature), c.plotY += c.dispY / a * Math.min(Math.abs(c.dispY), b.temperature));\n        },\n        getK: function (b) {\n          return Math.pow(b.box.width * b.box.height / b.nodes.length, .3);\n        }\n      }\n    };\n  });\n  A(c, \"Series/Networkgraph/QuadTree.js\", [c[\"Core/Globals.js\"], c[\"Core/Utilities.js\"]], function (c, b) {\n    b = b.extend;\n\n    var h = c.QuadTreeNode = function (a) {\n      this.box = a;\n      this.boxSize = Math.min(a.width, a.height);\n      this.nodes = [];\n      this.body = this.isInternal = !1;\n      this.isEmpty = !0;\n    };\n\n    b(h.prototype, {\n      insert: function (a, b) {\n        this.isInternal ? this.nodes[this.getBoxPosition(a)].insert(a, b - 1) : (this.isEmpty = !1, this.body ? b ? (this.isInternal = !0, this.divideBox(), !0 !== this.body && (this.nodes[this.getBoxPosition(this.body)].insert(this.body, b - 1), this.body = !0), this.nodes[this.getBoxPosition(a)].insert(a, b - 1)) : (b = new h({\n          top: a.plotX,\n          left: a.plotY,\n          width: .1,\n          height: .1\n        }), b.body = a, b.isInternal = !1, this.nodes.push(b)) : (this.isInternal = !1, this.body = a));\n      },\n      updateMassAndCenter: function () {\n        var a = 0,\n            b = 0,\n            c = 0;\n        this.isInternal ? (this.nodes.forEach(function (f) {\n          f.isEmpty || (a += f.mass, b += f.plotX * f.mass, c += f.plotY * f.mass);\n        }), b /= a, c /= a) : this.body && (a = this.body.mass, b = this.body.plotX, c = this.body.plotY);\n        this.mass = a;\n        this.plotX = b;\n        this.plotY = c;\n      },\n      divideBox: function () {\n        var a = this.box.width / 2,\n            b = this.box.height / 2;\n        this.nodes[0] = new h({\n          left: this.box.left,\n          top: this.box.top,\n          width: a,\n          height: b\n        });\n        this.nodes[1] = new h({\n          left: this.box.left + a,\n          top: this.box.top,\n          width: a,\n          height: b\n        });\n        this.nodes[2] = new h({\n          left: this.box.left + a,\n          top: this.box.top + b,\n          width: a,\n          height: b\n        });\n        this.nodes[3] = new h({\n          left: this.box.left,\n          top: this.box.top + b,\n          width: a,\n          height: b\n        });\n      },\n      getBoxPosition: function (a) {\n        var b = a.plotY < this.box.top + this.box.height / 2;\n        return a.plotX < this.box.left + this.box.width / 2 ? b ? 0 : 3 : b ? 1 : 2;\n      }\n    });\n\n    c = c.QuadTree = function (a, b, c, u) {\n      this.box = {\n        left: a,\n        top: b,\n        width: c,\n        height: u\n      };\n      this.maxDepth = 25;\n      this.root = new h(this.box, \"0\");\n      this.root.isInternal = !0;\n      this.root.isRoot = !0;\n      this.root.divideBox();\n    };\n\n    b(c.prototype, {\n      insertNodes: function (a) {\n        a.forEach(function (a) {\n          this.root.insert(a, this.maxDepth);\n        }, this);\n      },\n      visitNodeRecursive: function (a, b, c) {\n        var f;\n        a || (a = this.root);\n        a === this.root && b && (f = b(a));\n        !1 !== f && (a.nodes.forEach(function (a) {\n          if (a.isInternal) {\n            b && (f = b(a));\n            if (!1 === f) return;\n            this.visitNodeRecursive(a, b, c);\n          } else a.body && b && b(a.body);\n\n          c && c(a);\n        }, this), a === this.root && c && c(a));\n      },\n      calculateMassAndCenter: function () {\n        this.visitNodeRecursive(null, null, function (a) {\n          a.updateMassAndCenter();\n        });\n      }\n    });\n  });\n  A(c, \"Series/Networkgraph/Layouts.js\", [c[\"Core/Chart/Chart.js\"], c[\"Core/Animation/AnimationUtilities.js\"], c[\"Core/Globals.js\"], c[\"Core/Utilities.js\"]], function (c, b, h, a) {\n    var f = b.setAnimation;\n    b = a.addEvent;\n    var q = a.clamp,\n        u = a.defined,\n        z = a.extend,\n        E = a.isFunction,\n        B = a.pick;\n    h.layouts = {\n      \"reingold-fruchterman\": function () {}\n    };\n    z(h.layouts[\"reingold-fruchterman\"].prototype, {\n      init: function (a) {\n        this.options = a;\n        this.nodes = [];\n        this.links = [];\n        this.series = [];\n        this.box = {\n          x: 0,\n          y: 0,\n          width: 0,\n          height: 0\n        };\n        this.setInitialRendering(!0);\n        this.integration = h.networkgraphIntegrations[a.integration];\n        this.enableSimulation = a.enableSimulation;\n        this.attractiveForce = B(a.attractiveForce, this.integration.attractiveForceFunction);\n        this.repulsiveForce = B(a.repulsiveForce, this.integration.repulsiveForceFunction);\n        this.approximation = a.approximation;\n      },\n      updateSimulation: function (a) {\n        this.enableSimulation = B(a, this.options.enableSimulation);\n      },\n      start: function () {\n        var a = this.series,\n            b = this.options;\n        this.currentStep = 0;\n        this.forces = a[0] && a[0].forces || [];\n        this.chart = a[0] && a[0].chart;\n        this.initialRendering && (this.initPositions(), a.forEach(function (a) {\n          a.finishedAnimating = !0;\n          a.render();\n        }));\n        this.setK();\n        this.resetSimulation(b);\n        this.enableSimulation && this.step();\n      },\n      step: function () {\n        var a = this,\n            b = this.series;\n        a.currentStep++;\n        \"barnes-hut\" === a.approximation && (a.createQuadTree(), a.quadTree.calculateMassAndCenter());\n        a.forces.forEach(function (b) {\n          a[b + \"Forces\"](a.temperature);\n        });\n        a.applyLimits(a.temperature);\n        a.temperature = a.coolDown(a.startTemperature, a.diffTemperature, a.currentStep);\n        a.prevSystemTemperature = a.systemTemperature;\n        a.systemTemperature = a.getSystemTemperature();\n        a.enableSimulation && (b.forEach(function (a) {\n          a.chart && a.render();\n        }), a.maxIterations-- && isFinite(a.temperature) && !a.isStable() ? (a.simulation && h.win.cancelAnimationFrame(a.simulation), a.simulation = h.win.requestAnimationFrame(function () {\n          a.step();\n        })) : a.simulation = !1);\n      },\n      stop: function () {\n        this.simulation && h.win.cancelAnimationFrame(this.simulation);\n      },\n      setArea: function (a, b, c, f) {\n        this.box = {\n          left: a,\n          top: b,\n          width: c,\n          height: f\n        };\n      },\n      setK: function () {\n        this.k = this.options.linkLength || this.integration.getK(this);\n      },\n      addElementsToCollection: function (a, b) {\n        a.forEach(function (a) {\n          -1 === b.indexOf(a) && b.push(a);\n        });\n      },\n      removeElementFromCollection: function (a, b) {\n        a = b.indexOf(a);\n        -1 !== a && b.splice(a, 1);\n      },\n      clear: function () {\n        this.nodes.length = 0;\n        this.links.length = 0;\n        this.series.length = 0;\n        this.resetSimulation();\n      },\n      resetSimulation: function () {\n        this.forcedStop = !1;\n        this.systemTemperature = 0;\n        this.setMaxIterations();\n        this.setTemperature();\n        this.setDiffTemperature();\n      },\n      restartSimulation: function () {\n        this.simulation ? this.resetSimulation() : (this.setInitialRendering(!1), this.enableSimulation ? this.start() : this.setMaxIterations(1), this.chart && this.chart.redraw(), this.setInitialRendering(!0));\n      },\n      setMaxIterations: function (a) {\n        this.maxIterations = B(a, this.options.maxIterations);\n      },\n      setTemperature: function () {\n        this.temperature = this.startTemperature = Math.sqrt(this.nodes.length);\n      },\n      setDiffTemperature: function () {\n        this.diffTemperature = this.startTemperature / (this.options.maxIterations + 1);\n      },\n      setInitialRendering: function (a) {\n        this.initialRendering = a;\n      },\n      createQuadTree: function () {\n        this.quadTree = new h.QuadTree(this.box.left, this.box.top, this.box.width, this.box.height);\n        this.quadTree.insertNodes(this.nodes);\n      },\n      initPositions: function () {\n        var a = this.options.initialPositions;\n        E(a) ? (a.call(this), this.nodes.forEach(function (a) {\n          u(a.prevX) || (a.prevX = a.plotX);\n          u(a.prevY) || (a.prevY = a.plotY);\n          a.dispX = 0;\n          a.dispY = 0;\n        })) : \"circle\" === a ? this.setCircularPositions() : this.setRandomPositions();\n      },\n      setCircularPositions: function () {\n        function a(b) {\n          b.linksFrom.forEach(function (d) {\n            p[d.toNode.id] || (p[d.toNode.id] = !0, q.push(d.toNode), a(d.toNode));\n          });\n        }\n\n        var b = this.box,\n            c = this.nodes,\n            f = 2 * Math.PI / (c.length + 1),\n            h = c.filter(function (a) {\n          return 0 === a.linksTo.length;\n        }),\n            q = [],\n            p = {},\n            l = this.options.initialPositionRadius;\n        h.forEach(function (b) {\n          q.push(b);\n          a(b);\n        });\n        q.length ? c.forEach(function (a) {\n          -1 === q.indexOf(a) && q.push(a);\n        }) : q = c;\n        q.forEach(function (a, d) {\n          a.plotX = a.prevX = B(a.plotX, b.width / 2 + l * Math.cos(d * f));\n          a.plotY = a.prevY = B(a.plotY, b.height / 2 + l * Math.sin(d * f));\n          a.dispX = 0;\n          a.dispY = 0;\n        });\n      },\n      setRandomPositions: function () {\n        function a(a) {\n          a = a * a / Math.PI;\n          return a -= Math.floor(a);\n        }\n\n        var b = this.box,\n            c = this.nodes,\n            f = c.length + 1;\n        c.forEach(function (e, c) {\n          e.plotX = e.prevX = B(e.plotX, b.width * a(c));\n          e.plotY = e.prevY = B(e.plotY, b.height * a(f + c));\n          e.dispX = 0;\n          e.dispY = 0;\n        });\n      },\n      force: function (a) {\n        this.integration[a].apply(this, Array.prototype.slice.call(arguments, 1));\n      },\n      barycenterForces: function () {\n        this.getBarycenter();\n        this.force(\"barycenter\");\n      },\n      getBarycenter: function () {\n        var a = 0,\n            b = 0,\n            c = 0;\n        this.nodes.forEach(function (e) {\n          b += e.plotX * e.mass;\n          c += e.plotY * e.mass;\n          a += e.mass;\n        });\n        return this.barycenter = {\n          x: b,\n          y: c,\n          xFactor: b / a,\n          yFactor: c / a\n        };\n      },\n      barnesHutApproximation: function (a, b) {\n        var e = this.getDistXY(a, b),\n            c = this.vectorLength(e);\n        if (a !== b && 0 !== c) if (b.isInternal) {\n          if (b.boxSize / c < this.options.theta && 0 !== c) {\n            var f = this.repulsiveForce(c, this.k);\n            this.force(\"repulsive\", a, f * b.mass, e, c);\n            var h = !1;\n          } else h = !0;\n        } else f = this.repulsiveForce(c, this.k), this.force(\"repulsive\", a, f * b.mass, e, c);\n        return h;\n      },\n      repulsiveForces: function () {\n        var a = this;\n        \"barnes-hut\" === a.approximation ? a.nodes.forEach(function (b) {\n          a.quadTree.visitNodeRecursive(null, function (e) {\n            return a.barnesHutApproximation(b, e);\n          });\n        }) : a.nodes.forEach(function (b) {\n          a.nodes.forEach(function (e) {\n            if (b !== e && !b.fixedPosition) {\n              var c = a.getDistXY(b, e);\n              var f = a.vectorLength(c);\n\n              if (0 !== f) {\n                var h = a.repulsiveForce(f, a.k);\n                a.force(\"repulsive\", b, h * e.mass, c, f);\n              }\n            }\n          });\n        });\n      },\n      attractiveForces: function () {\n        var a = this,\n            b,\n            c,\n            f;\n        a.links.forEach(function (e) {\n          e.fromNode && e.toNode && (b = a.getDistXY(e.fromNode, e.toNode), c = a.vectorLength(b), 0 !== c && (f = a.attractiveForce(c, a.k), a.force(\"attractive\", e, f, b, c)));\n        });\n      },\n      applyLimits: function () {\n        var a = this;\n        a.nodes.forEach(function (b) {\n          b.fixedPosition || (a.integration.integrate(a, b), a.applyLimitBox(b, a.box), b.dispX = 0, b.dispY = 0);\n        });\n      },\n      applyLimitBox: function (a, b) {\n        var c = a.radius;\n        a.plotX = q(a.plotX, b.left + c, b.width - c);\n        a.plotY = q(a.plotY, b.top + c, b.height - c);\n      },\n      coolDown: function (a, b, c) {\n        return a - b * c;\n      },\n      isStable: function () {\n        return .00001 > Math.abs(this.systemTemperature - this.prevSystemTemperature) || 0 >= this.temperature;\n      },\n      getSystemTemperature: function () {\n        return this.nodes.reduce(function (a, b) {\n          return a + b.temperature;\n        }, 0);\n      },\n      vectorLength: function (a) {\n        return Math.sqrt(a.x * a.x + a.y * a.y);\n      },\n      getDistR: function (a, b) {\n        a = this.getDistXY(a, b);\n        return this.vectorLength(a);\n      },\n      getDistXY: function (a, b) {\n        var c = a.plotX - b.plotX;\n        a = a.plotY - b.plotY;\n        return {\n          x: c,\n          y: a,\n          absX: Math.abs(c),\n          absY: Math.abs(a)\n        };\n      }\n    });\n    b(c, \"predraw\", function () {\n      this.graphLayoutsLookup && this.graphLayoutsLookup.forEach(function (a) {\n        a.stop();\n      });\n    });\n    b(c, \"render\", function () {\n      function a(a) {\n        a.maxIterations-- && isFinite(a.temperature) && !a.isStable() && !a.enableSimulation && (a.beforeStep && a.beforeStep(), a.step(), c = !1, b = !0);\n      }\n\n      var b = !1;\n\n      if (this.graphLayoutsLookup) {\n        f(!1, this);\n\n        for (this.graphLayoutsLookup.forEach(function (a) {\n          a.start();\n        }); !c;) {\n          var c = !0;\n          this.graphLayoutsLookup.forEach(a);\n        }\n\n        b && this.series.forEach(function (a) {\n          a && a.layout && a.render();\n        });\n      }\n    });\n    b(c, \"beforePrint\", function () {\n      this.graphLayoutsLookup && (this.graphLayoutsLookup.forEach(function (a) {\n        a.updateSimulation(!1);\n      }), this.redraw());\n    });\n    b(c, \"afterPrint\", function () {\n      this.graphLayoutsLookup && this.graphLayoutsLookup.forEach(function (a) {\n        a.updateSimulation();\n      });\n      this.redraw();\n    });\n  });\n  A(c, \"Series/PackedBubbleSeries.js\", [c[\"Core/Series/Series.js\"], c[\"Core/Chart/Chart.js\"], c[\"Core/Color/Color.js\"], c[\"Core/Globals.js\"], c[\"Core/Series/Point.js\"], c[\"Core/Utilities.js\"]], function (c, b, h, a, f, q) {\n    var u = h.parse,\n        z = q.addEvent,\n        E = q.clamp,\n        B = q.defined,\n        e = q.extend;\n    h = q.extendClass;\n    var x = q.fireEvent,\n        w = q.isArray,\n        m = q.isNumber,\n        C = q.merge,\n        v = q.pick,\n        p = a.Series,\n        l = a.layouts[\"reingold-fruchterman\"],\n        k = a.dragNodesMixin;\n    \"\";\n\n    b.prototype.getSelectedParentNodes = function () {\n      var a = [];\n      this.series.forEach(function (d) {\n        d.parentNode && d.parentNode.selected && a.push(d.parentNode);\n      });\n      return a;\n    };\n\n    a.networkgraphIntegrations.packedbubble = {\n      repulsiveForceFunction: function (a, b, c, e) {\n        return Math.min(a, (c.marker.radius + e.marker.radius) / 2);\n      },\n      barycenter: function () {\n        var a = this,\n            b = a.options.gravitationalConstant,\n            c = a.box,\n            e = a.nodes,\n            f,\n            n;\n        e.forEach(function (d) {\n          a.options.splitSeries && !d.isParentNode ? (f = d.series.parentNode.plotX, n = d.series.parentNode.plotY) : (f = c.width / 2, n = c.height / 2);\n          d.fixedPosition || (d.plotX -= (d.plotX - f) * b / (d.mass * Math.sqrt(e.length)), d.plotY -= (d.plotY - n) * b / (d.mass * Math.sqrt(e.length)));\n        });\n      },\n      repulsive: function (a, b, c, e) {\n        var d = b * this.diffTemperature / a.mass / a.degree;\n        b = c.x * d;\n        c = c.y * d;\n        a.fixedPosition || (a.plotX += b, a.plotY += c);\n        e.fixedPosition || (e.plotX -= b, e.plotY -= c);\n      },\n      integrate: a.networkgraphIntegrations.verlet.integrate,\n      getK: a.noop\n    };\n    a.layouts.packedbubble = h(l, {\n      beforeStep: function () {\n        this.options.marker && this.series.forEach(function (a) {\n          a && a.calculateParentRadius();\n        });\n      },\n      setCircularPositions: function () {\n        var a = this,\n            b = a.box,\n            c = a.nodes,\n            e = 2 * Math.PI / (c.length + 1),\n            f,\n            n,\n            h = a.options.initialPositionRadius;\n        c.forEach(function (d, g) {\n          a.options.splitSeries && !d.isParentNode ? (f = d.series.parentNode.plotX, n = d.series.parentNode.plotY) : (f = b.width / 2, n = b.height / 2);\n          d.plotX = d.prevX = v(d.plotX, f + h * Math.cos(d.index || g * e));\n          d.plotY = d.prevY = v(d.plotY, n + h * Math.sin(d.index || g * e));\n          d.dispX = 0;\n          d.dispY = 0;\n        });\n      },\n      repulsiveForces: function () {\n        var a = this,\n            b,\n            c,\n            e,\n            f = a.options.bubblePadding;\n        a.nodes.forEach(function (d) {\n          d.degree = d.mass;\n          d.neighbours = 0;\n          a.nodes.forEach(function (g) {\n            b = 0;\n            d === g || d.fixedPosition || !a.options.seriesInteraction && d.series !== g.series || (e = a.getDistXY(d, g), c = a.vectorLength(e) - (d.marker.radius + g.marker.radius + f), 0 > c && (d.degree += .01, d.neighbours++, b = a.repulsiveForce(-c / Math.sqrt(d.neighbours), a.k, d, g)), a.force(\"repulsive\", d, b * g.mass, e, g, c));\n          });\n        });\n      },\n      applyLimitBox: function (a) {\n        if (this.options.splitSeries && !a.isParentNode && this.options.parentNodeLimit) {\n          var d = this.getDistXY(a, a.series.parentNode);\n          var b = a.series.parentNodeRadius - a.marker.radius - this.vectorLength(d);\n          0 > b && b > -2 * a.marker.radius && (a.plotX -= .01 * d.x, a.plotY -= .01 * d.y);\n        }\n\n        l.prototype.applyLimitBox.apply(this, arguments);\n      }\n    });\n    c.seriesType(\"packedbubble\", \"bubble\", {\n      minSize: \"10%\",\n      maxSize: \"50%\",\n      sizeBy: \"area\",\n      zoneAxis: \"y\",\n      crisp: !1,\n      tooltip: {\n        pointFormat: \"Value: {point.value}\"\n      },\n      draggable: !0,\n      useSimulation: !0,\n      parentNode: {\n        allowPointSelect: !1\n      },\n      dataLabels: {\n        formatter: function () {\n          return this.point.value;\n        },\n        parentNodeFormatter: function () {\n          return this.name;\n        },\n        parentNodeTextPath: {\n          enabled: !0\n        },\n        padding: 0,\n        style: {\n          transition: \"opacity 2000ms\"\n        }\n      },\n      layoutAlgorithm: {\n        initialPositions: \"circle\",\n        initialPositionRadius: 20,\n        bubblePadding: 5,\n        parentNodeLimit: !1,\n        seriesInteraction: !0,\n        dragBetweenSeries: !1,\n        parentNodeOptions: {\n          maxIterations: 400,\n          gravitationalConstant: .03,\n          maxSpeed: 50,\n          initialPositionRadius: 100,\n          seriesInteraction: !0,\n          marker: {\n            fillColor: null,\n            fillOpacity: 1,\n            lineWidth: 1,\n            lineColor: null,\n            symbol: \"circle\"\n          }\n        },\n        enableSimulation: !0,\n        type: \"packedbubble\",\n        integration: \"packedbubble\",\n        maxIterations: 1E3,\n        splitSeries: !1,\n        maxSpeed: 5,\n        gravitationalConstant: .01,\n        friction: -.981\n      }\n    }, {\n      hasDraggableNodes: !0,\n      forces: [\"barycenter\", \"repulsive\"],\n      pointArrayMap: [\"value\"],\n      trackerGroups: [\"group\", \"dataLabelsGroup\", \"parentNodesGroup\"],\n      pointValKey: \"value\",\n      isCartesian: !1,\n      requireSorting: !1,\n      directTouch: !0,\n      axisTypes: [],\n      noSharedTooltip: !0,\n      searchPoint: a.noop,\n      accumulateAllPoints: function (a) {\n        var d = a.chart,\n            b = [],\n            c,\n            e;\n\n        for (c = 0; c < d.series.length; c++) if (a = d.series[c], a.is(\"packedbubble\") && a.visible || !d.options.chart.ignoreHiddenSeries) for (e = 0; e < a.yData.length; e++) b.push([null, null, a.yData[e], a.index, e, {\n          id: e,\n          marker: {\n            radius: 0\n          }\n        }]);\n\n        return b;\n      },\n      init: function () {\n        p.prototype.init.apply(this, arguments);\n        z(this, \"updatedData\", function () {\n          this.chart.series.forEach(function (a) {\n            a.type === this.type && (a.isDirty = !0);\n          }, this);\n        });\n        return this;\n      },\n      render: function () {\n        var a = [];\n        p.prototype.render.apply(this, arguments);\n        this.options.dataLabels.allowOverlap || (this.data.forEach(function (d) {\n          w(d.dataLabels) && d.dataLabels.forEach(function (d) {\n            a.push(d);\n          });\n        }), this.options.useSimulation && this.chart.hideOverlappingLabels(a));\n      },\n      setVisible: function () {\n        var a = this;\n        p.prototype.setVisible.apply(a, arguments);\n        a.parentNodeLayout && a.graph ? a.visible ? (a.graph.show(), a.parentNode.dataLabel && a.parentNode.dataLabel.show()) : (a.graph.hide(), a.parentNodeLayout.removeElementFromCollection(a.parentNode, a.parentNodeLayout.nodes), a.parentNode.dataLabel && a.parentNode.dataLabel.hide()) : a.layout && (a.visible ? a.layout.addElementsToCollection(a.points, a.layout.nodes) : a.points.forEach(function (d) {\n          a.layout.removeElementFromCollection(d, a.layout.nodes);\n        }));\n      },\n      drawDataLabels: function () {\n        var a = this.options.dataLabels.textPath,\n            b = this.points;\n        p.prototype.drawDataLabels.apply(this, arguments);\n        this.parentNode && (this.parentNode.formatPrefix = \"parentNode\", this.points = [this.parentNode], this.options.dataLabels.textPath = this.options.dataLabels.parentNodeTextPath, p.prototype.drawDataLabels.apply(this, arguments), this.points = b, this.options.dataLabels.textPath = a);\n      },\n      seriesBox: function () {\n        var a = this.chart,\n            b = Math.max,\n            c = Math.min,\n            e,\n            f = [a.plotLeft, a.plotLeft + a.plotWidth, a.plotTop, a.plotTop + a.plotHeight];\n        this.data.forEach(function (a) {\n          B(a.plotX) && B(a.plotY) && a.marker.radius && (e = a.marker.radius, f[0] = c(f[0], a.plotX - e), f[1] = b(f[1], a.plotX + e), f[2] = c(f[2], a.plotY - e), f[3] = b(f[3], a.plotY + e));\n        });\n        return m(f.width / f.height) ? f : null;\n      },\n      calculateParentRadius: function () {\n        var a = this.seriesBox();\n        this.parentNodeRadius = E(Math.sqrt(2 * this.parentNodeMass / Math.PI) + 20, 20, a ? Math.max(Math.sqrt(Math.pow(a.width, 2) + Math.pow(a.height, 2)) / 2 + 20, 20) : Math.sqrt(2 * this.parentNodeMass / Math.PI) + 20);\n        this.parentNode && (this.parentNode.marker.radius = this.parentNode.radius = this.parentNodeRadius);\n      },\n      drawGraph: function () {\n        if (this.layout && this.layout.options.splitSeries) {\n          var a = this.chart,\n              b = this.layout.options.parentNodeOptions.marker;\n          b = {\n            fill: b.fillColor || u(this.color).brighten(.4).get(),\n            opacity: b.fillOpacity,\n            stroke: b.lineColor || this.color,\n            \"stroke-width\": b.lineWidth\n          };\n          var c = this.visible ? \"inherit\" : \"hidden\";\n          this.parentNodesGroup || (this.parentNodesGroup = this.plotGroup(\"parentNodesGroup\", \"parentNode\", c, .1, a.seriesGroup), this.group.attr({\n            zIndex: 2\n          }));\n          this.calculateParentRadius();\n          c = C({\n            x: this.parentNode.plotX - this.parentNodeRadius,\n            y: this.parentNode.plotY - this.parentNodeRadius,\n            width: 2 * this.parentNodeRadius,\n            height: 2 * this.parentNodeRadius\n          }, b);\n          this.parentNode.graphic || (this.graph = this.parentNode.graphic = a.renderer.symbol(b.symbol).add(this.parentNodesGroup));\n          this.parentNode.graphic.attr(c);\n        }\n      },\n      createParentNodes: function () {\n        var a = this,\n            b = a.chart,\n            c = a.parentNodeLayout,\n            e,\n            f = a.parentNode,\n            n = a.pointClass;\n        a.parentNodeMass = 0;\n        a.points.forEach(function (d) {\n          a.parentNodeMass += Math.PI * Math.pow(d.marker.radius, 2);\n        });\n        a.calculateParentRadius();\n        c.nodes.forEach(function (d) {\n          d.seriesIndex === a.index && (e = !0);\n        });\n        c.setArea(0, 0, b.plotWidth, b.plotHeight);\n        e || (f || (f = new n().init(this, {\n          mass: a.parentNodeRadius / 2,\n          marker: {\n            radius: a.parentNodeRadius\n          },\n          dataLabels: {\n            inside: !1\n          },\n          dataLabelOnNull: !0,\n          degree: a.parentNodeRadius,\n          isParentNode: !0,\n          seriesIndex: a.index\n        })), a.parentNode && (f.plotX = a.parentNode.plotX, f.plotY = a.parentNode.plotY), a.parentNode = f, c.addElementsToCollection([a], c.series), c.addElementsToCollection([f], c.nodes));\n      },\n      drawTracker: function () {\n        var d = this.parentNode;\n        a.TrackerMixin.drawTrackerPoint.call(this);\n\n        if (d) {\n          var b = w(d.dataLabels) ? d.dataLabels : d.dataLabel ? [d.dataLabel] : [];\n          d.graphic && (d.graphic.element.point = d);\n          b.forEach(function (a) {\n            a.div ? a.div.point = d : a.element.point = d;\n          });\n        }\n      },\n      addSeriesLayout: function () {\n        var d = this.options.layoutAlgorithm,\n            b = this.chart.graphLayoutsStorage,\n            c = this.chart.graphLayoutsLookup,\n            e = C(d, d.parentNodeOptions, {\n          enableSimulation: this.layout.options.enableSimulation\n        });\n        var f = b[d.type + \"-series\"];\n        f || (b[d.type + \"-series\"] = f = new a.layouts[d.type](), f.init(e), c.splice(f.index, 0, f));\n        this.parentNodeLayout = f;\n        this.createParentNodes();\n      },\n      addLayout: function () {\n        var d = this.options.layoutAlgorithm,\n            b = this.chart.graphLayoutsStorage,\n            c = this.chart.graphLayoutsLookup,\n            e = this.chart.options.chart;\n        b || (this.chart.graphLayoutsStorage = b = {}, this.chart.graphLayoutsLookup = c = []);\n        var f = b[d.type];\n        f || (d.enableSimulation = B(e.forExport) ? !e.forExport : d.enableSimulation, b[d.type] = f = new a.layouts[d.type](), f.init(d), c.splice(f.index, 0, f));\n        this.layout = f;\n        this.points.forEach(function (a) {\n          a.mass = 2;\n          a.degree = 1;\n          a.collisionNmb = 1;\n        });\n        f.setArea(0, 0, this.chart.plotWidth, this.chart.plotHeight);\n        f.addElementsToCollection([this], f.series);\n        f.addElementsToCollection(this.points, f.nodes);\n      },\n      deferLayout: function () {\n        var a = this.options.layoutAlgorithm;\n        this.visible && (this.addLayout(), a.splitSeries && this.addSeriesLayout());\n      },\n      translate: function () {\n        var a = this.chart,\n            b = this.data,\n            c = this.index,\n            f,\n            t = this.options.useSimulation;\n        this.processedXData = this.xData;\n        this.generatePoints();\n        B(a.allDataPoints) || (a.allDataPoints = this.accumulateAllPoints(this), this.getPointRadius());\n        if (t) var n = a.allDataPoints;else n = this.placeBubbles(a.allDataPoints), this.options.draggable = !1;\n\n        for (f = 0; f < n.length; f++) if (n[f][3] === c) {\n          var h = b[n[f][4]];\n          var l = n[f][2];\n          t || (h.plotX = n[f][0] - a.plotLeft + a.diffX, h.plotY = n[f][1] - a.plotTop + a.diffY);\n          h.marker = e(h.marker, {\n            radius: l,\n            width: 2 * l,\n            height: 2 * l\n          });\n          h.radius = l;\n        }\n\n        t && this.deferLayout();\n        x(this, \"afterTranslate\");\n      },\n      checkOverlap: function (a, b) {\n        var d = a[0] - b[0],\n            c = a[1] - b[1];\n        return -.001 > Math.sqrt(d * d + c * c) - Math.abs(a[2] + b[2]);\n      },\n      positionBubble: function (a, b, c) {\n        var d = Math.sqrt,\n            e = Math.asin,\n            g = Math.acos,\n            f = Math.pow,\n            h = Math.abs;\n        d = d(f(a[0] - b[0], 2) + f(a[1] - b[1], 2));\n        g = g((f(d, 2) + f(c[2] + b[2], 2) - f(c[2] + a[2], 2)) / (2 * (c[2] + b[2]) * d));\n        e = e(h(a[0] - b[0]) / d);\n        a = (0 > a[1] - b[1] ? 0 : Math.PI) + g + e * (0 > (a[0] - b[0]) * (a[1] - b[1]) ? 1 : -1);\n        return [b[0] + (b[2] + c[2]) * Math.sin(a), b[1] - (b[2] + c[2]) * Math.cos(a), c[2], c[3], c[4]];\n      },\n      placeBubbles: function (a) {\n        var b = this.checkOverlap,\n            d = this.positionBubble,\n            c = [],\n            e = 1,\n            f = 0,\n            h = 0;\n        var l = [];\n        var k;\n        a = a.sort(function (a, b) {\n          return b[2] - a[2];\n        });\n\n        if (a.length) {\n          c.push([[0, 0, a[0][2], a[0][3], a[0][4]]]);\n          if (1 < a.length) for (c.push([[0, 0 - a[1][2] - a[0][2], a[1][2], a[1][3], a[1][4]]]), k = 2; k < a.length; k++) a[k][2] = a[k][2] || 1, l = d(c[e][f], c[e - 1][h], a[k]), b(l, c[e][0]) ? (c.push([]), h = 0, c[e + 1].push(d(c[e][f], c[e][0], a[k])), e++, f = 0) : 1 < e && c[e - 1][h + 1] && b(l, c[e - 1][h + 1]) ? (h++, c[e].push(d(c[e][f], c[e - 1][h], a[k])), f++) : (f++, c[e].push(l));\n          this.chart.stages = c;\n          this.chart.rawPositions = [].concat.apply([], c);\n          this.resizeRadius();\n          l = this.chart.rawPositions;\n        }\n\n        return l;\n      },\n      resizeRadius: function () {\n        var a = this.chart,\n            b = a.rawPositions,\n            c = Math.min,\n            e = Math.max,\n            f = a.plotLeft,\n            n = a.plotTop,\n            h = a.plotHeight,\n            l = a.plotWidth,\n            k,\n            q,\n            m;\n        var p = k = Number.POSITIVE_INFINITY;\n        var u = q = Number.NEGATIVE_INFINITY;\n\n        for (m = 0; m < b.length; m++) {\n          var v = b[m][2];\n          p = c(p, b[m][0] - v);\n          u = e(u, b[m][0] + v);\n          k = c(k, b[m][1] - v);\n          q = e(q, b[m][1] + v);\n        }\n\n        m = [u - p, q - k];\n        c = c.apply([], [(l - f) / m[0], (h - n) / m[1]]);\n\n        if (1e-10 < Math.abs(c - 1)) {\n          for (m = 0; m < b.length; m++) b[m][2] *= c;\n\n          this.placeBubbles(b);\n        } else a.diffY = h / 2 + n - k - (q - k) / 2, a.diffX = l / 2 + f - p - (u - p) / 2;\n      },\n      calculateZExtremes: function () {\n        var a = this.options.zMin,\n            b = this.options.zMax,\n            c = Infinity,\n            e = -Infinity;\n        if (a && b) return [a, b];\n        this.chart.series.forEach(function (a) {\n          a.yData.forEach(function (a) {\n            B(a) && (a > e && (e = a), a < c && (c = a));\n          });\n        });\n        a = v(a, c);\n        b = v(b, e);\n        return [a, b];\n      },\n      getPointRadius: function () {\n        var a = this,\n            b = a.chart,\n            c = a.options,\n            e = c.useSimulation,\n            f = Math.min(b.plotWidth, b.plotHeight),\n            n = {},\n            h = [],\n            k = b.allDataPoints,\n            l,\n            m,\n            q,\n            p;\n        [\"minSize\", \"maxSize\"].forEach(function (a) {\n          var b = parseInt(c[a], 10),\n              d = /%$/.test(c[a]);\n          n[a] = d ? f * b / 100 : b * Math.sqrt(k.length);\n        });\n        b.minRadius = l = n.minSize / Math.sqrt(k.length);\n        b.maxRadius = m = n.maxSize / Math.sqrt(k.length);\n        var u = e ? a.calculateZExtremes() : [l, m];\n        (k || []).forEach(function (b, d) {\n          q = e ? E(b[2], u[0], u[1]) : b[2];\n          p = a.getRadius(u[0], u[1], l, m, q);\n          0 === p && (p = null);\n          k[d][2] = p;\n          h.push(p);\n        });\n        a.radii = h;\n      },\n      redrawHalo: k.redrawHalo,\n      onMouseDown: k.onMouseDown,\n      onMouseMove: k.onMouseMove,\n      onMouseUp: function (a) {\n        if (a.fixedPosition && !a.removed) {\n          var b,\n              d,\n              c = this.layout,\n              e = this.parentNodeLayout;\n          e && c.options.dragBetweenSeries && e.nodes.forEach(function (e) {\n            a && a.marker && e !== a.series.parentNode && (b = c.getDistXY(a, e), d = c.vectorLength(b) - e.marker.radius - a.marker.radius, 0 > d && (e.series.addPoint(C(a.options, {\n              plotX: a.plotX,\n              plotY: a.plotY\n            }), !1), c.removeElementFromCollection(a, c.nodes), a.remove()));\n          });\n          k.onMouseUp.apply(this, arguments);\n        }\n      },\n      destroy: function () {\n        this.chart.graphLayoutsLookup && this.chart.graphLayoutsLookup.forEach(function (a) {\n          a.removeElementFromCollection(this, a.series);\n        }, this);\n        this.parentNode && (this.parentNodeLayout.removeElementFromCollection(this.parentNode, this.parentNodeLayout.nodes), this.parentNode.dataLabel && (this.parentNode.dataLabel = this.parentNode.dataLabel.destroy()));\n        a.Series.prototype.destroy.apply(this, arguments);\n      },\n      alignDataLabel: a.Series.prototype.alignDataLabel\n    }, {\n      destroy: function () {\n        this.series.layout && this.series.layout.removeElementFromCollection(this, this.series.layout.nodes);\n        return f.prototype.destroy.apply(this, arguments);\n      },\n      firePointEvent: function (a, b, c) {\n        var d = this.series.options;\n\n        if (this.isParentNode && d.parentNode) {\n          var e = d.allowPointSelect;\n          d.allowPointSelect = d.parentNode.allowPointSelect;\n          f.prototype.firePointEvent.apply(this, arguments);\n          d.allowPointSelect = e;\n        } else f.prototype.firePointEvent.apply(this, arguments);\n      },\n      select: function (a, c) {\n        var d = this.series.chart;\n        this.isParentNode ? (d.getSelectedPoints = d.getSelectedParentNodes, f.prototype.select.apply(this, arguments), d.getSelectedPoints = b.prototype.getSelectedPoints) : f.prototype.select.apply(this, arguments);\n      }\n    });\n    z(b, \"beforeRedraw\", function () {\n      this.allDataPoints && delete this.allDataPoints;\n    });\n    \"\";\n  });\n  A(c, \"Extensions/Polar.js\", [c[\"Core/Animation/AnimationUtilities.js\"], c[\"Core/Chart/Chart.js\"], c[\"Core/Globals.js\"], c[\"Extensions/Pane.js\"], c[\"Core/Pointer.js\"], c[\"Core/Renderer/SVG/SVGRenderer.js\"], c[\"Core/Utilities.js\"]], function (c, b, h, a, f, q, u) {\n    var z = c.animObject,\n        E = u.addEvent,\n        B = u.defined,\n        e = u.find,\n        x = u.isNumber,\n        w = u.pick,\n        m = u.splat,\n        C = u.uniqueKey;\n    c = u.wrap;\n    var v = h.Series,\n        p = h.seriesTypes,\n        l = v.prototype;\n    f = f.prototype;\n\n    l.searchPointByAngle = function (a) {\n      var b = this.chart,\n          d = this.xAxis.pane.center;\n      return this.searchKDTree({\n        clientX: 180 + -180 / Math.PI * Math.atan2(a.chartX - d[0] - b.plotLeft, a.chartY - d[1] - b.plotTop)\n      });\n    };\n\n    l.getConnectors = function (a, b, c, e) {\n      var d = e ? 1 : 0;\n      var f = 0 <= b && b <= a.length - 1 ? b : 0 > b ? a.length - 1 + b : 0;\n      b = 0 > f - 1 ? a.length - (1 + d) : f - 1;\n      d = f + 1 > a.length - 1 ? d : f + 1;\n      var g = a[b];\n      d = a[d];\n      var h = g.plotX;\n      g = g.plotY;\n      var k = d.plotX;\n      var l = d.plotY;\n      d = a[f].plotX;\n      f = a[f].plotY;\n      h = (1.5 * d + h) / 2.5;\n      g = (1.5 * f + g) / 2.5;\n      k = (1.5 * d + k) / 2.5;\n      var r = (1.5 * f + l) / 2.5;\n      l = Math.sqrt(Math.pow(h - d, 2) + Math.pow(g - f, 2));\n      var m = Math.sqrt(Math.pow(k - d, 2) + Math.pow(r - f, 2));\n      h = Math.atan2(g - f, h - d);\n      r = Math.PI / 2 + (h + Math.atan2(r - f, k - d)) / 2;\n      Math.abs(h - r) > Math.PI / 2 && (r -= Math.PI);\n      h = d + Math.cos(r) * l;\n      g = f + Math.sin(r) * l;\n      k = d + Math.cos(Math.PI + r) * m;\n      r = f + Math.sin(Math.PI + r) * m;\n      d = {\n        rightContX: k,\n        rightContY: r,\n        leftContX: h,\n        leftContY: g,\n        plotX: d,\n        plotY: f\n      };\n      c && (d.prevPointCont = this.getConnectors(a, b, !1, e));\n      return d;\n    };\n\n    l.toXY = function (a) {\n      var b = this.chart,\n          d = this.xAxis;\n      var c = this.yAxis;\n      var e = a.plotX,\n          f = a.plotY,\n          h = a.series,\n          k = b.inverted,\n          l = a.y,\n          m = k ? e : c.len - f;\n      k && h && !h.isRadialBar && (a.plotY = f = \"number\" === typeof l ? c.translate(l) || 0 : 0);\n      a.rectPlotX = e;\n      a.rectPlotY = f;\n      c.center && (m += c.center[3] / 2);\n      c = k ? c.postTranslate(f, m) : d.postTranslate(e, m);\n      a.plotX = a.polarPlotX = c.x - b.plotLeft;\n      a.plotY = a.polarPlotY = c.y - b.plotTop;\n      this.kdByAngle ? (b = (e / Math.PI * 180 + d.pane.options.startAngle) % 360, 0 > b && (b += 360), a.clientX = b) : a.clientX = a.plotX;\n    };\n\n    p.spline && (c(p.spline.prototype, \"getPointSpline\", function (a, b, c, e) {\n      this.chart.polar ? e ? (a = this.getConnectors(b, e, !0, this.connectEnds), a = [\"C\", a.prevPointCont.rightContX, a.prevPointCont.rightContY, a.leftContX, a.leftContY, a.plotX, a.plotY]) : a = [\"M\", c.plotX, c.plotY] : a = a.call(this, b, c, e);\n      return a;\n    }), p.areasplinerange && (p.areasplinerange.prototype.getPointSpline = p.spline.prototype.getPointSpline));\n    E(v, \"afterTranslate\", function () {\n      var a = this.chart;\n\n      if (a.polar && this.xAxis) {\n        (this.kdByAngle = a.tooltip && a.tooltip.shared) ? this.searchPoint = this.searchPointByAngle : this.options.findNearestPointBy = \"xy\";\n        if (!this.preventPostTranslate) for (var b = this.points, c = b.length; c--;) this.toXY(b[c]), !a.hasParallelCoordinates && !this.yAxis.reversed && b[c].y < this.yAxis.min && (b[c].isNull = !0);\n        this.hasClipCircleSetter || (this.hasClipCircleSetter = !!this.eventsToUnbind.push(E(this, \"afterRender\", function () {\n          if (a.polar) {\n            var b = this.yAxis.pane.center;\n            this.clipCircle ? this.clipCircle.animate({\n              x: b[0],\n              y: b[1],\n              r: b[2] / 2,\n              innerR: b[3] / 2\n            }) : this.clipCircle = a.renderer.clipCircle(b[0], b[1], b[2] / 2, b[3] / 2);\n            this.group.clip(this.clipCircle);\n            this.setClip = h.noop;\n          }\n        })));\n      }\n    }, {\n      order: 2\n    });\n    c(l, \"getGraphPath\", function (a, b) {\n      var c = this,\n          d;\n\n      if (this.chart.polar) {\n        b = b || this.points;\n\n        for (d = 0; d < b.length; d++) if (!b[d].isNull) {\n          var e = d;\n          break;\n        }\n\n        if (!1 !== this.options.connectEnds && \"undefined\" !== typeof e) {\n          this.connectEnds = !0;\n          b.splice(b.length, 0, b[e]);\n          var f = !0;\n        }\n\n        b.forEach(function (a) {\n          \"undefined\" === typeof a.polarPlotY && c.toXY(a);\n        });\n      }\n\n      d = a.apply(this, [].slice.call(arguments, 1));\n      f && b.pop();\n      return d;\n    });\n\n    var k = function (a, b) {\n      var c = this,\n          d = this.chart,\n          e = this.options.animation,\n          f = this.group,\n          g = this.markerGroup,\n          k = this.xAxis.center,\n          l = d.plotLeft,\n          m = d.plotTop,\n          p,\n          q,\n          u,\n          v;\n      if (d.polar) {\n        if (c.isRadialBar) b || (c.startAngleRad = w(c.translatedThreshold, c.xAxis.startAngleRad), h.seriesTypes.pie.prototype.animate.call(c, b));else {\n          if (d.renderer.isSVG) if (e = z(e), c.is(\"column\")) {\n            if (!b) {\n              var x = k[3] / 2;\n              c.points.forEach(function (a) {\n                p = a.graphic;\n                u = (q = a.shapeArgs) && q.r;\n                v = q && q.innerR;\n                p && q && (p.attr({\n                  r: x,\n                  innerR: x\n                }), p.animate({\n                  r: u,\n                  innerR: v\n                }, c.options.animation));\n              });\n            }\n          } else b ? (a = {\n            translateX: k[0] + l,\n            translateY: k[1] + m,\n            scaleX: .001,\n            scaleY: .001\n          }, f.attr(a), g && g.attr(a)) : (a = {\n            translateX: l,\n            translateY: m,\n            scaleX: 1,\n            scaleY: 1\n          }, f.animate(a, e), g && g.animate(a, e));\n        }\n      } else a.call(this, b);\n    };\n\n    c(l, \"animate\", k);\n    p.column && (v = p.arearange.prototype, p = p.column.prototype, p.polarArc = function (a, b, c, e) {\n      var d = this.xAxis.center,\n          f = this.yAxis.len,\n          g = d[3] / 2;\n      b = f - b + g;\n      a = f - w(a, f) + g;\n      this.yAxis.reversed && (0 > b && (b = g), 0 > a && (a = g));\n      return {\n        x: d[0],\n        y: d[1],\n        r: b,\n        innerR: a,\n        start: c,\n        end: e\n      };\n    }, c(p, \"animate\", k), c(p, \"translate\", function (a) {\n      var b = this.options,\n          c = b.stacking,\n          d = this.chart,\n          e = this.xAxis,\n          f = this.yAxis,\n          h = f.reversed,\n          k = f.center,\n          l = e.startAngleRad,\n          m = e.endAngleRad - l;\n      this.preventPostTranslate = !0;\n      a.call(this);\n\n      if (e.isRadial) {\n        a = this.points;\n        e = a.length;\n        var p = f.translate(f.min);\n        var q = f.translate(f.max);\n        b = b.threshold || 0;\n\n        if (d.inverted && x(b)) {\n          var v = f.translate(b);\n          B(v) && (0 > v ? v = 0 : v > m && (v = m), this.translatedThreshold = v + l);\n        }\n\n        for (; e--;) {\n          b = a[e];\n          var w = b.barX;\n          var z = b.x;\n          var E = b.y;\n          b.shapeType = \"arc\";\n\n          if (d.inverted) {\n            b.plotY = f.translate(E);\n\n            if (c && f.stacking) {\n              if (E = f.stacking.stacks[(0 > E ? \"-\" : \"\") + this.stackKey], this.visible && E && E[z] && !b.isNull) {\n                var C = E[z].points[this.getStackIndicator(void 0, z, this.index).key];\n                var A = f.translate(C[0]);\n                C = f.translate(C[1]);\n                B(A) && (A = u.clamp(A, 0, m));\n              }\n            } else A = v, C = b.plotY;\n\n            A > C && (C = [A, A = C][0]);\n            if (!h) {\n              if (A < p) A = p;else if (C > q) C = q;else {\n                if (C < p || A > q) A = C = 0;\n              }\n            } else if (C > p) C = p;else if (A < q) A = q;else if (A > p || C < q) A = C = m;\n            f.min > f.max && (A = C = h ? m : 0);\n            A += l;\n            C += l;\n            k && (b.barX = w += k[3] / 2);\n            z = Math.max(w, 0);\n            E = Math.max(w + b.pointWidth, 0);\n            b.shapeArgs = {\n              x: k && k[0],\n              y: k && k[1],\n              r: E,\n              innerR: z,\n              start: A,\n              end: C\n            };\n            b.opacity = A === C ? 0 : void 0;\n            b.plotY = (B(this.translatedThreshold) && (A < this.translatedThreshold ? A : C)) - l;\n          } else A = w + l, b.shapeArgs = this.polarArc(b.yBottom, b.plotY, A, A + b.pointWidth);\n\n          this.toXY(b);\n          d.inverted ? (w = f.postTranslate(b.rectPlotY, w + b.pointWidth / 2), b.tooltipPos = [w.x - d.plotLeft, w.y - d.plotTop]) : b.tooltipPos = [b.plotX, b.plotY];\n          k && (b.ttBelow = b.plotY > k[1]);\n        }\n      }\n    }), p.findAlignments = function (a, b) {\n      null === b.align && (b.align = 20 < a && 160 > a ? \"left\" : 200 < a && 340 > a ? \"right\" : \"center\");\n      null === b.verticalAlign && (b.verticalAlign = 45 > a || 315 < a ? \"bottom\" : 135 < a && 225 > a ? \"top\" : \"middle\");\n      return b;\n    }, v && (v.findAlignments = p.findAlignments), c(p, \"alignDataLabel\", function (a, b, c, e, f, h) {\n      var d = this.chart,\n          g = w(e.inside, !!this.options.stacking);\n      d.polar ? (a = b.rectPlotX / Math.PI * 180, d.inverted ? (this.forceDL = d.isInsidePlot(b.plotX, Math.round(b.plotY), !1), g && b.shapeArgs ? (f = b.shapeArgs, f = this.yAxis.postTranslate((f.start + f.end) / 2 - this.xAxis.startAngleRad, b.barX + b.pointWidth / 2), f = {\n        x: f.x - d.plotLeft,\n        y: f.y - d.plotTop\n      }) : b.tooltipPos && (f = {\n        x: b.tooltipPos[0],\n        y: b.tooltipPos[1]\n      }), e.align = w(e.align, \"center\"), e.verticalAlign = w(e.verticalAlign, \"middle\")) : this.findAlignments && (e = this.findAlignments(a, e)), l.alignDataLabel.call(this, b, c, e, f, h), this.isRadialBar && b.shapeArgs && b.shapeArgs.start === b.shapeArgs.end && c.hide(!0)) : a.call(this, b, c, e, f, h);\n    }));\n    c(f, \"getCoordinates\", function (a, b) {\n      var c = this.chart,\n          d = {\n        xAxis: [],\n        yAxis: []\n      };\n      c.polar ? c.axes.forEach(function (a) {\n        var e = a.isXAxis,\n            f = a.center;\n\n        if (\"colorAxis\" !== a.coll) {\n          var g = b.chartX - f[0] - c.plotLeft;\n          f = b.chartY - f[1] - c.plotTop;\n          d[e ? \"xAxis\" : \"yAxis\"].push({\n            axis: a,\n            value: a.translate(e ? Math.PI - Math.atan2(g, f) : Math.sqrt(Math.pow(g, 2) + Math.pow(f, 2)), !0)\n          });\n        }\n      }) : d = a.call(this, b);\n      return d;\n    });\n\n    q.prototype.clipCircle = function (a, b, c, e) {\n      var d = C(),\n          f = this.createElement(\"clipPath\").attr({\n        id: d\n      }).add(this.defs);\n      a = e ? this.arc(a, b, c, e, 0, 2 * Math.PI).add(f) : this.circle(a, b, c).add(f);\n      a.id = d;\n      a.clipPath = f;\n      return a;\n    };\n\n    E(b, \"getAxes\", function () {\n      this.pane || (this.pane = []);\n      m(this.options.pane).forEach(function (b) {\n        new a(b, this);\n      }, this);\n    });\n    E(b, \"afterDrawChartBox\", function () {\n      this.pane.forEach(function (a) {\n        a.render();\n      });\n    });\n    E(h.Series, \"afterInit\", function () {\n      var a = this.chart;\n      a.inverted && a.polar && (this.isRadialSeries = !0, this.is(\"column\") && (this.isRadialBar = !0));\n    });\n    c(b.prototype, \"get\", function (a, b) {\n      return e(this.pane, function (a) {\n        return a.options.id === b;\n      }) || a.call(this, b);\n    });\n  });\n  A(c, \"masters/highcharts-more.src.js\", [], function () {});\n}); //# sourceMappingURL=highcharts-more.js.map","map":null,"metadata":{},"sourceType":"script"}