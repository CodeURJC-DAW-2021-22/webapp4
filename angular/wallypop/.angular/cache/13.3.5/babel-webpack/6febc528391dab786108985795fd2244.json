{"ast":null,"code":"/*\n Highcharts JS v8.2.2 (2020-10-22)\n\n (c) 2009-2018 Torstein Honsi\n\n License: www.highcharts.com/license\n*/\n(function (X, N) {\n  \"object\" === typeof module && module.exports ? (N[\"default\"] = N, module.exports = X.document ? N(X) : N) : \"function\" === typeof define && define.amd ? define(\"highcharts/highcharts\", function () {\n    return N(X);\n  }) : (X.Highcharts && X.Highcharts.error(16, !0), X.Highcharts = N(X));\n})(\"undefined\" !== typeof window ? window : this, function (X) {\n  function N(f, h, m, z) {\n    f.hasOwnProperty(h) || (f[h] = z.apply(null, m));\n  }\n\n  var m = {};\n  N(m, \"Core/Globals.js\", [], function () {\n    var f = \"undefined\" !== typeof X ? X : \"undefined\" !== typeof window ? window : {},\n        h = f.document,\n        m = f.navigator && f.navigator.userAgent || \"\",\n        z = h && h.createElementNS && !!h.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\").createSVGRect,\n        F = /(edge|msie|trident)/i.test(m) && !f.opera,\n        L = -1 !== m.indexOf(\"Firefox\"),\n        K = -1 !== m.indexOf(\"Chrome\"),\n        C = L && 4 > parseInt(m.split(\"Firefox/\")[1], 10);\n    return {\n      product: \"Highcharts\",\n      version: \"8.2.2\",\n      deg2rad: 2 * Math.PI / 360,\n      doc: h,\n      hasBidiBug: C,\n      hasTouch: !!f.TouchEvent,\n      isMS: F,\n      isWebKit: -1 !== m.indexOf(\"AppleWebKit\"),\n      isFirefox: L,\n      isChrome: K,\n      isSafari: !K && -1 !== m.indexOf(\"Safari\"),\n      isTouchDevice: /(Mobile|Android|Windows Phone)/.test(m),\n      SVG_NS: \"http://www.w3.org/2000/svg\",\n      chartCount: 0,\n      seriesTypes: {},\n      symbolSizes: {},\n      svg: z,\n      win: f,\n      marginNames: [\"plotTop\", \"marginRight\", \"marginBottom\", \"plotLeft\"],\n      noop: function () {},\n      charts: [],\n      dateFormats: {}\n    };\n  });\n  N(m, \"Core/Utilities.js\", [m[\"Core/Globals.js\"]], function (f) {\n    function h(b, k, t, a) {\n      var u = k ? \"Highcharts error\" : \"Highcharts warning\";\n      32 === b && (b = u + \": Deprecated member\");\n      var c = l(b),\n          H = c ? u + \" #\" + b + \": www.highcharts.com/errors/\" + b + \"/\" : b.toString();\n\n      u = function () {\n        if (k) throw Error(H);\n        e.console && -1 === h.messages.indexOf(H) && console.log(H);\n      };\n\n      if (\"undefined\" !== typeof a) {\n        var d = \"\";\n        c && (H += \"?\");\n        S(a, function (b, k) {\n          d += \"\\n - \" + k + \": \" + b;\n          c && (H += encodeURI(k) + \"=\" + encodeURI(b));\n        });\n        H += d;\n      }\n\n      t ? ca(t, \"displayError\", {\n        code: b,\n        message: H,\n        params: a\n      }, u) : u();\n      h.messages.push(H);\n    }\n\n    function m() {\n      var b,\n          k = arguments,\n          t = {},\n          a = function (b, k) {\n        \"object\" !== typeof b && (b = {});\n        S(k, function (t, u) {\n          !z(t, !0) || n(t) || D(t) ? b[u] = k[u] : b[u] = a(b[u] || {}, t);\n        });\n        return b;\n      };\n\n      !0 === k[0] && (t = k[1], k = Array.prototype.slice.call(k, 2));\n      var u = k.length;\n\n      for (b = 0; b < u; b++) t = a(t, k[b]);\n\n      return t;\n    }\n\n    function z(b, k) {\n      return !!b && \"object\" === typeof b && (!k || !x(b));\n    }\n\n    function F(b, k, t) {\n      var a;\n      v(k) ? w(t) ? b.setAttribute(k, t) : b && b.getAttribute && ((a = b.getAttribute(k)) || \"class\" !== k || (a = b.getAttribute(k + \"Name\"))) : S(k, function (k, t) {\n        b.setAttribute(t, k);\n      });\n      return a;\n    }\n\n    function L() {\n      for (var b = arguments, k = b.length, t = 0; t < k; t++) {\n        var a = b[t];\n        if (\"undefined\" !== typeof a && null !== a) return a;\n      }\n    }\n\n    function K(b, k) {\n      if (!b) return k;\n      var t = b.split(\".\").reverse();\n      if (1 === t.length) return k[b];\n\n      for (b = t.pop(); \"undefined\" !== typeof b && \"undefined\" !== typeof k && null !== k;) k = k[b], b = t.pop();\n\n      return k;\n    }\n\n    f.timers = [];\n    var C = f.charts,\n        y = f.doc,\n        e = f.win;\n    (h || (h = {})).messages = [];\n    f.error = h;\n    f.merge = m;\n\n    var I = f.pInt = function (b, k) {\n      return parseInt(b, k || 10);\n    },\n        v = f.isString = function (b) {\n      return \"string\" === typeof b;\n    },\n        x = f.isArray = function (b) {\n      b = Object.prototype.toString.call(b);\n      return \"[object Array]\" === b || \"[object Array Iterator]\" === b;\n    };\n\n    f.isObject = z;\n\n    var D = f.isDOMElement = function (b) {\n      return z(b) && \"number\" === typeof b.nodeType;\n    },\n        n = f.isClass = function (b) {\n      var k = b && b.constructor;\n      return !(!z(b, !0) || D(b) || !k || !k.name || \"Object\" === k.name);\n    },\n        l = f.isNumber = function (b) {\n      return \"number\" === typeof b && !isNaN(b) && Infinity > b && -Infinity < b;\n    },\n        J = f.erase = function (b, k) {\n      for (var t = b.length; t--;) if (b[t] === k) {\n        b.splice(t, 1);\n        break;\n      }\n    },\n        w = f.defined = function (b) {\n      return \"undefined\" !== typeof b && null !== b;\n    };\n\n    f.attr = F;\n\n    var r = f.splat = function (b) {\n      return x(b) ? b : [b];\n    },\n        d = f.syncTimeout = function (b, k, t) {\n      if (0 < k) return setTimeout(b, k, t);\n      b.call(0, t);\n      return -1;\n    },\n        g = f.clearTimeout = function (b) {\n      w(b) && clearTimeout(b);\n    },\n        c = f.extend = function (b, k) {\n      var t;\n      b || (b = {});\n\n      for (t in k) b[t] = k[t];\n\n      return b;\n    };\n\n    f.pick = L;\n\n    var a = f.css = function (b, k) {\n      f.isMS && !f.svg && k && \"undefined\" !== typeof k.opacity && (k.filter = \"alpha(opacity=\" + 100 * k.opacity + \")\");\n      c(b.style, k);\n    },\n        q = f.createElement = function (b, k, t, u, H) {\n      b = y.createElement(b);\n      k && c(b, k);\n      H && a(b, {\n        padding: \"0\",\n        border: \"none\",\n        margin: \"0\"\n      });\n      t && a(b, t);\n      u && u.appendChild(b);\n      return b;\n    },\n        p = f.extendClass = function (b, k) {\n      var t = function () {};\n\n      t.prototype = new b();\n      c(t.prototype, k);\n      return t;\n    },\n        B = f.pad = function (b, k, t) {\n      return Array((k || 2) + 1 - String(b).replace(\"-\", \"\").length).join(t || \"0\") + b;\n    },\n        A = f.relativeLength = function (b, k, t) {\n      return /%$/.test(b) ? k * parseFloat(b) / 100 + (t || 0) : parseFloat(b);\n    },\n        G = f.wrap = function (b, k, t) {\n      var a = b[k];\n\n      b[k] = function () {\n        var b = Array.prototype.slice.call(arguments),\n            k = arguments,\n            u = this;\n\n        u.proceed = function () {\n          a.apply(u, arguments.length ? arguments : k);\n        };\n\n        b.unshift(a);\n        b = t.apply(this, b);\n        u.proceed = null;\n        return b;\n      };\n    },\n        M = f.format = function (b, k, t) {\n      var a = \"{\",\n          u = !1,\n          H = [],\n          c = /f$/,\n          d = /\\.([0-9])/,\n          g = f.defaultOptions.lang,\n          p = t && t.time || f.time;\n\n      for (t = t && t.numberFormatter || R; b;) {\n        var q = b.indexOf(a);\n        if (-1 === q) break;\n        var U = b.slice(0, q);\n\n        if (u) {\n          U = U.split(\":\");\n          a = K(U.shift() || \"\", k);\n          if (U.length && \"number\" === typeof a) if (U = U.join(\":\"), c.test(U)) {\n            var r = parseInt((U.match(d) || [\"\", \"-1\"])[1], 10);\n            null !== a && (a = t(a, r, g.decimalPoint, -1 < U.indexOf(\",\") ? g.thousandsSep : \"\"));\n          } else a = p.dateFormat(U, a);\n          H.push(a);\n        } else H.push(U);\n\n        b = b.slice(q + 1);\n        a = (u = !u) ? \"}\" : \"{\";\n      }\n\n      H.push(b);\n      return H.join(\"\");\n    },\n        T = f.getMagnitude = function (b) {\n      return Math.pow(10, Math.floor(Math.log(b) / Math.LN10));\n    },\n        Q = f.normalizeTickInterval = function (b, k, a, u, H) {\n      var c = b;\n      a = L(a, 1);\n      var d = b / a;\n      k || (k = H ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === u && (1 === a ? k = k.filter(function (b) {\n        return 0 === b % 1;\n      }) : .1 >= a && (k = [1 / a])));\n\n      for (u = 0; u < k.length && !(c = k[u], H && c * a >= b || !H && d <= (k[u] + (k[u + 1] || k[u])) / 2); u++);\n\n      return c = t(c * a, -Math.round(Math.log(.001) / Math.LN10));\n    },\n        O = f.stableSort = function (b, k) {\n      var t = b.length,\n          a,\n          u;\n\n      for (u = 0; u < t; u++) b[u].safeI = u;\n\n      b.sort(function (b, t) {\n        a = k(b, t);\n        return 0 === a ? b.safeI - t.safeI : a;\n      });\n\n      for (u = 0; u < t; u++) delete b[u].safeI;\n    },\n        E = f.arrayMin = function (b) {\n      for (var k = b.length, t = b[0]; k--;) b[k] < t && (t = b[k]);\n\n      return t;\n    },\n        u = f.arrayMax = function (b) {\n      for (var k = b.length, t = b[0]; k--;) b[k] > t && (t = b[k]);\n\n      return t;\n    },\n        b = f.destroyObjectProperties = function (b, k) {\n      S(b, function (t, a) {\n        t && t !== k && t.destroy && t.destroy();\n        delete b[a];\n      });\n    },\n        k = f.discardElement = function (b) {\n      var k = f.garbageBin;\n      k || (k = q(\"div\"));\n      b && k.appendChild(b);\n      k.innerHTML = \"\";\n    },\n        t = f.correctFloat = function (b, k) {\n      return parseFloat(b.toPrecision(k || 14));\n    },\n        H = f.timeUnits = {\n      millisecond: 1,\n      second: 1E3,\n      minute: 6E4,\n      hour: 36E5,\n      day: 864E5,\n      week: 6048E5,\n      month: 24192E5,\n      year: 314496E5\n    },\n        R = f.numberFormat = function (b, k, t, a) {\n      b = +b || 0;\n      k = +k;\n      var u = f.defaultOptions.lang,\n          H = (b.toString().split(\".\")[1] || \"\").split(\"e\")[0].length,\n          c = b.toString().split(\"e\");\n      if (-1 === k) k = Math.min(H, 20);else if (!l(k)) k = 2;else if (k && c[1] && 0 > c[1]) {\n        var d = k + +c[1];\n        0 <= d ? (c[0] = (+c[0]).toExponential(d).split(\"e\")[0], k = d) : (c[0] = c[0].split(\".\")[0] || 0, b = 20 > k ? (c[0] * Math.pow(10, c[1])).toFixed(k) : 0, c[1] = 0);\n      }\n      var g = (Math.abs(c[1] ? c[0] : b) + Math.pow(10, -Math.max(k, H) - 1)).toFixed(k);\n      H = String(I(g));\n      d = 3 < H.length ? H.length % 3 : 0;\n      t = L(t, u.decimalPoint);\n      a = L(a, u.thousandsSep);\n      b = (0 > b ? \"-\" : \"\") + (d ? H.substr(0, d) + a : \"\");\n      b += H.substr(d).replace(/(\\d{3})(?=\\d)/g, \"$1\" + a);\n      k && (b += t + g.slice(-k));\n      c[1] && 0 !== +b && (b += \"e\" + c[1]);\n      return b;\n    };\n\n    Math.easeInOutSine = function (b) {\n      return -.5 * (Math.cos(Math.PI * b) - 1);\n    };\n\n    var U = f.getStyle = function (b, k, t) {\n      if (\"width\" === k) return k = Math.min(b.offsetWidth, b.scrollWidth), t = b.getBoundingClientRect && b.getBoundingClientRect().width, t < k && t >= k - 1 && (k = Math.floor(t)), Math.max(0, k - f.getStyle(b, \"padding-left\") - f.getStyle(b, \"padding-right\"));\n      if (\"height\" === k) return Math.max(0, Math.min(b.offsetHeight, b.scrollHeight) - f.getStyle(b, \"padding-top\") - f.getStyle(b, \"padding-bottom\"));\n      e.getComputedStyle || h(27, !0);\n      if (b = e.getComputedStyle(b, void 0)) b = b.getPropertyValue(k), L(t, \"opacity\" !== k) && (b = I(b));\n      return b;\n    },\n        Z = f.inArray = function (b, k, t) {\n      h(32, !1, void 0, {\n        \"Highcharts.inArray\": \"use Array.indexOf\"\n      });\n      return k.indexOf(b, t);\n    },\n        aa = f.find = Array.prototype.find ? function (b, k) {\n      return b.find(k);\n    } : function (b, k) {\n      var t,\n          a = b.length;\n\n      for (t = 0; t < a; t++) if (k(b[t], t)) return b[t];\n    };\n\n    f.keys = function (b) {\n      h(32, !1, void 0, {\n        \"Highcharts.keys\": \"use Object.keys\"\n      });\n      return Object.keys(b);\n    };\n\n    var ba = f.offset = function (b) {\n      var k = y.documentElement;\n      b = b.parentElement || b.parentNode ? b.getBoundingClientRect() : {\n        top: 0,\n        left: 0\n      };\n      return {\n        top: b.top + (e.pageYOffset || k.scrollTop) - (k.clientTop || 0),\n        left: b.left + (e.pageXOffset || k.scrollLeft) - (k.clientLeft || 0)\n      };\n    },\n        S = f.objectEach = function (b, k, t) {\n      for (var a in b) Object.hasOwnProperty.call(b, a) && k.call(t || b[a], b[a], a, b);\n    };\n\n    S({\n      map: \"map\",\n      each: \"forEach\",\n      grep: \"filter\",\n      reduce: \"reduce\",\n      some: \"some\"\n    }, function (b, k) {\n      f[k] = function (t) {\n        var a;\n        h(32, !1, void 0, (a = {}, a[\"Highcharts.\" + k] = \"use Array.\" + b, a));\n        return Array.prototype[b].apply(t, [].slice.call(arguments, 1));\n      };\n    });\n\n    var Y = f.addEvent = function (b, k, t, a) {\n      void 0 === a && (a = {});\n      var u = b.addEventListener || f.addEventListenerPolyfill;\n      var c = \"function\" === typeof b && b.prototype ? b.prototype.protoEvents = b.prototype.protoEvents || {} : b.hcEvents = b.hcEvents || {};\n      f.Point && b instanceof f.Point && b.series && b.series.chart && (b.series.chart.runTrackerClick = !0);\n      u && u.call(b, k, t, !1);\n      c[k] || (c[k] = []);\n      c[k].push({\n        fn: t,\n        order: \"number\" === typeof a.order ? a.order : Infinity\n      });\n      c[k].sort(function (b, k) {\n        return b.order - k.order;\n      });\n      return function () {\n        W(b, k, t);\n      };\n    },\n        W = f.removeEvent = function (b, k, t) {\n      function a(k, t) {\n        var a = b.removeEventListener || f.removeEventListenerPolyfill;\n        a && a.call(b, k, t, !1);\n      }\n\n      function u(t) {\n        var u;\n\n        if (b.nodeName) {\n          if (k) {\n            var c = {};\n            c[k] = !0;\n          } else c = t;\n\n          S(c, function (b, k) {\n            if (t[k]) for (u = t[k].length; u--;) a(k, t[k][u].fn);\n          });\n        }\n      }\n\n      var c;\n      [\"protoEvents\", \"hcEvents\"].forEach(function (H, d) {\n        var g = (d = d ? b : b.prototype) && d[H];\n        g && (k ? (c = g[k] || [], t ? (g[k] = c.filter(function (b) {\n          return t !== b.fn;\n        }), a(k, t)) : (u(g), g[k] = [])) : (u(g), d[H] = {}));\n      });\n    },\n        ca = f.fireEvent = function (b, k, t, a) {\n      var u;\n      t = t || {};\n\n      if (y.createEvent && (b.dispatchEvent || b.fireEvent)) {\n        var H = y.createEvent(\"Events\");\n        H.initEvent(k, !0, !0);\n        c(H, t);\n        b.dispatchEvent ? b.dispatchEvent(H) : b.fireEvent(k, H);\n      } else t.target || c(t, {\n        preventDefault: function () {\n          t.defaultPrevented = !0;\n        },\n        target: b,\n        type: k\n      }), function (k, a) {\n        void 0 === k && (k = []);\n        void 0 === a && (a = []);\n        var c = 0,\n            H = 0,\n            d = k.length + a.length;\n\n        for (u = 0; u < d; u++) !1 === (k[c] ? a[H] ? k[c].order <= a[H].order ? k[c++] : a[H++] : k[c++] : a[H++]).fn.call(b, t) && t.preventDefault();\n      }(b.protoEvents && b.protoEvents[k], b.hcEvents && b.hcEvents[k]);\n\n      a && !t.defaultPrevented && a.call(b, t);\n    },\n        V,\n        da = f.uniqueKey = function () {\n      var b = Math.random().toString(36).substring(2, 9) + \"-\",\n          k = 0;\n      return function () {\n        return \"highcharts-\" + (V ? \"\" : b) + k++;\n      };\n    }(),\n        ea = f.useSerialIds = function (b) {\n      return V = L(b, V);\n    },\n        fa = f.isFunction = function (b) {\n      return \"function\" === typeof b;\n    },\n        ha = f.getOptions = function () {\n      return f.defaultOptions;\n    },\n        ia = f.setOptions = function (b) {\n      f.defaultOptions = m(!0, f.defaultOptions, b);\n      (b.time || b.global) && f.time.update(m(f.defaultOptions.global, f.defaultOptions.time, b.global, b.time));\n      return f.defaultOptions;\n    };\n\n    e.jQuery && (e.jQuery.fn.highcharts = function () {\n      var b = [].slice.call(arguments);\n      if (this[0]) return b[0] ? (new f[v(b[0]) ? b.shift() : \"Chart\"](this[0], b[0], b[1]), this) : C[F(this[0], \"data-highcharts-chart\")];\n    });\n    return {\n      addEvent: Y,\n      arrayMax: u,\n      arrayMin: E,\n      attr: F,\n      clamp: function (b, k, t) {\n        return b > k ? b < t ? b : t : k;\n      },\n      clearTimeout: g,\n      correctFloat: t,\n      createElement: q,\n      css: a,\n      defined: w,\n      destroyObjectProperties: b,\n      discardElement: k,\n      erase: J,\n      error: h,\n      extend: c,\n      extendClass: p,\n      find: aa,\n      fireEvent: ca,\n      format: M,\n      getMagnitude: T,\n      getNestedProperty: K,\n      getOptions: ha,\n      getStyle: U,\n      inArray: Z,\n      isArray: x,\n      isClass: n,\n      isDOMElement: D,\n      isFunction: fa,\n      isNumber: l,\n      isObject: z,\n      isString: v,\n      merge: m,\n      normalizeTickInterval: Q,\n      numberFormat: R,\n      objectEach: S,\n      offset: ba,\n      pad: B,\n      pick: L,\n      pInt: I,\n      relativeLength: A,\n      removeEvent: W,\n      setOptions: ia,\n      splat: r,\n      stableSort: O,\n      syncTimeout: d,\n      timeUnits: H,\n      uniqueKey: da,\n      useSerialIds: ea,\n      wrap: G\n    };\n  });\n  N(m, \"Core/Color/Color.js\", [m[\"Core/Globals.js\"], m[\"Core/Utilities.js\"]], function (f, h) {\n    var m = h.isNumber,\n        z = h.merge,\n        F = h.pInt;\n    \"\";\n\n    h = function () {\n      function h(K) {\n        this.parsers = [{\n          regex: /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]?(?:\\.[0-9]+)?)\\s*\\)/,\n          parse: function (h) {\n            return [F(h[1]), F(h[2]), F(h[3]), parseFloat(h[4], 10)];\n          }\n        }, {\n          regex: /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/,\n          parse: function (h) {\n            return [F(h[1]), F(h[2]), F(h[3]), 1];\n          }\n        }];\n        this.rgba = [];\n        if (f.Color !== h) return new f.Color(K);\n        if (!(this instanceof h)) return new h(K);\n        this.init(K);\n      }\n\n      h.parse = function (f) {\n        return new h(f);\n      };\n\n      h.prototype.init = function (f) {\n        var C, y;\n        if ((this.input = f = h.names[f && f.toLowerCase ? f.toLowerCase() : \"\"] || f) && f.stops) this.stops = f.stops.map(function (v) {\n          return new h(v[1]);\n        });else {\n          if (f && f.charAt && \"#\" === f.charAt()) {\n            var e = f.length;\n            f = parseInt(f.substr(1), 16);\n            7 === e ? C = [(f & 16711680) >> 16, (f & 65280) >> 8, f & 255, 1] : 4 === e && (C = [(f & 3840) >> 4 | (f & 3840) >> 8, (f & 240) >> 4 | f & 240, (f & 15) << 4 | f & 15, 1]);\n          }\n\n          if (!C) for (y = this.parsers.length; y-- && !C;) {\n            var I = this.parsers[y];\n            (e = I.regex.exec(f)) && (C = I.parse(e));\n          }\n        }\n        this.rgba = C || [];\n      };\n\n      h.prototype.get = function (f) {\n        var h = this.input,\n            y = this.rgba;\n\n        if (\"undefined\" !== typeof this.stops) {\n          var e = z(h);\n          e.stops = [].concat(e.stops);\n          this.stops.forEach(function (I, v) {\n            e.stops[v] = [e.stops[v][0], I.get(f)];\n          });\n        } else e = y && m(y[0]) ? \"rgb\" === f || !f && 1 === y[3] ? \"rgb(\" + y[0] + \",\" + y[1] + \",\" + y[2] + \")\" : \"a\" === f ? y[3] : \"rgba(\" + y.join(\",\") + \")\" : h;\n\n        return e;\n      };\n\n      h.prototype.brighten = function (f) {\n        var h,\n            y = this.rgba;\n        if (this.stops) this.stops.forEach(function (e) {\n          e.brighten(f);\n        });else if (m(f) && 0 !== f) for (h = 0; 3 > h; h++) y[h] += F(255 * f), 0 > y[h] && (y[h] = 0), 255 < y[h] && (y[h] = 255);\n        return this;\n      };\n\n      h.prototype.setOpacity = function (f) {\n        this.rgba[3] = f;\n        return this;\n      };\n\n      h.prototype.tweenTo = function (f, h) {\n        var y = this.rgba,\n            e = f.rgba;\n        e.length && y && y.length ? (f = 1 !== e[3] || 1 !== y[3], h = (f ? \"rgba(\" : \"rgb(\") + Math.round(e[0] + (y[0] - e[0]) * (1 - h)) + \",\" + Math.round(e[1] + (y[1] - e[1]) * (1 - h)) + \",\" + Math.round(e[2] + (y[2] - e[2]) * (1 - h)) + (f ? \",\" + (e[3] + (y[3] - e[3]) * (1 - h)) : \"\") + \")\") : h = f.input || \"none\";\n        return h;\n      };\n\n      h.names = {\n        white: \"#ffffff\",\n        black: \"#000000\"\n      };\n      return h;\n    }();\n\n    f.Color = h;\n    f.color = h.parse;\n    return h;\n  });\n  N(m, \"Core/Animation/Fx.js\", [m[\"Core/Globals.js\"], m[\"Core/Utilities.js\"]], function (f, h) {\n    var m = f.win,\n        z = h.isNumber,\n        F = h.objectEach;\n\n    h = function () {\n      function h(f, h, y) {\n        this.pos = NaN;\n        this.options = h;\n        this.elem = f;\n        this.prop = y;\n      }\n\n      h.prototype.dSetter = function () {\n        var f = this.paths,\n            h = f && f[0];\n        f = f && f[1];\n        var y = [],\n            e = this.now || 0;\n        if (1 !== e && h && f) {\n          if (h.length === f.length && 1 > e) for (var I = 0; I < f.length; I++) {\n            for (var v = h[I], x = f[I], D = [], n = 0; n < x.length; n++) {\n              var l = v[n],\n                  J = x[n];\n              D[n] = \"number\" === typeof l && \"number\" === typeof J && (\"A\" !== x[0] || 4 !== n && 5 !== n) ? l + e * (J - l) : J;\n            }\n\n            y.push(D);\n          } else y = f;\n        } else y = this.toD || [];\n        this.elem.attr(\"d\", y, void 0, !0);\n      };\n\n      h.prototype.update = function () {\n        var f = this.elem,\n            h = this.prop,\n            y = this.now,\n            e = this.options.step;\n        if (this[h + \"Setter\"]) this[h + \"Setter\"]();else f.attr ? f.element && f.attr(h, y, null, !0) : f.style[h] = y + this.unit;\n        e && e.call(f, y, this);\n      };\n\n      h.prototype.run = function (h, C, y) {\n        var e = this,\n            I = e.options,\n            v = function (n) {\n          return v.stopped ? !1 : e.step(n);\n        },\n            x = m.requestAnimationFrame || function (n) {\n          setTimeout(n, 13);\n        },\n            D = function () {\n          for (var n = 0; n < f.timers.length; n++) f.timers[n]() || f.timers.splice(n--, 1);\n\n          f.timers.length && x(D);\n        };\n\n        h !== C || this.elem[\"forceAnimate:\" + this.prop] ? (this.startTime = +new Date(), this.start = h, this.end = C, this.unit = y, this.now = this.start, this.pos = 0, v.elem = this.elem, v.prop = this.prop, v() && 1 === f.timers.push(v) && x(D)) : (delete I.curAnim[this.prop], I.complete && 0 === Object.keys(I.curAnim).length && I.complete.call(this.elem));\n      };\n\n      h.prototype.step = function (f) {\n        var h = +new Date(),\n            y = this.options,\n            e = this.elem,\n            I = y.complete,\n            v = y.duration,\n            x = y.curAnim;\n        if (e.attr && !e.element) f = !1;else if (f || h >= v + this.startTime) {\n          this.now = this.end;\n          this.pos = 1;\n          this.update();\n          var D = x[this.prop] = !0;\n          F(x, function (n) {\n            !0 !== n && (D = !1);\n          });\n          D && I && I.call(e);\n          f = !1;\n        } else this.pos = y.easing((h - this.startTime) / v), this.now = this.start + (this.end - this.start) * this.pos, this.update(), f = !0;\n        return f;\n      };\n\n      h.prototype.initPath = function (f, h, y) {\n        function e(r, d) {\n          for (; r.length < w;) {\n            var g = r[0],\n                c = d[w - r.length];\n            c && \"M\" === g[0] && (r[0] = \"C\" === c[0] ? [\"C\", g[1], g[2], g[1], g[2], g[1], g[2]] : [\"L\", g[1], g[2]]);\n            r.unshift(g);\n            D && r.push(r[r.length - 1]);\n          }\n        }\n\n        function I(r, d) {\n          for (; r.length < w;) if (d = r[r.length / n - 1].slice(), \"C\" === d[0] && (d[1] = d[5], d[2] = d[6]), D) {\n            var g = r[r.length / n].slice();\n            r.splice(r.length / 2, 0, d, g);\n          } else r.push(d);\n        }\n\n        var v = f.startX,\n            x = f.endX;\n        h = h && h.slice();\n        y = y.slice();\n        var D = f.isArea,\n            n = D ? 2 : 1;\n        if (!h) return [y, y];\n\n        if (v && x) {\n          for (f = 0; f < v.length; f++) if (v[f] === x[0]) {\n            var l = f;\n            break;\n          } else if (v[0] === x[x.length - v.length + f]) {\n            l = f;\n            var J = !0;\n            break;\n          } else if (v[v.length - 1] === x[x.length - v.length + f]) {\n            l = v.length - f;\n            break;\n          }\n\n          \"undefined\" === typeof l && (h = []);\n        }\n\n        if (h.length && z(l)) {\n          var w = y.length + l * n;\n          J ? (e(h, y), I(y, h)) : (e(y, h), I(h, y));\n        }\n\n        return [h, y];\n      };\n\n      h.prototype.fillSetter = function () {\n        h.prototype.strokeSetter.apply(this, arguments);\n      };\n\n      h.prototype.strokeSetter = function () {\n        this.elem.attr(this.prop, f.color(this.start).tweenTo(f.color(this.end), this.pos), null, !0);\n      };\n\n      return h;\n    }();\n\n    return f.Fx = h;\n  });\n  N(m, \"Core/Animation/AnimationUtilities.js\", [m[\"Core/Animation/Fx.js\"], m[\"Core/Globals.js\"], m[\"Core/Utilities.js\"]], function (f, h, m) {\n    var z = m.defined,\n        P = m.getStyle,\n        L = m.isArray,\n        K = m.isNumber,\n        C = m.isObject,\n        y = m.merge,\n        e = m.objectEach,\n        I = m.pick;\n\n    m = h.setAnimation = function (l, n) {\n      n.renderer.globalAnimation = I(l, n.options.chart.animation, !0);\n    };\n\n    var v = h.animObject = function (l) {\n      return C(l) ? h.merge({\n        duration: 500,\n        defer: 0\n      }, l) : {\n        duration: l ? 500 : 0,\n        defer: 0\n      };\n    },\n        x = h.getDeferredAnimation = function (l, n, w) {\n      var r = v(n),\n          d = 0,\n          g = 0;\n      (w ? [w] : l.series).forEach(function (c) {\n        c = v(c.options.animation);\n        d = n && z(n.defer) ? r.defer : Math.max(d, c.duration + c.defer);\n        g = Math.min(r.duration, c.duration);\n      });\n      l.renderer.forExport && (d = 0);\n      return {\n        defer: Math.max(0, d - g),\n        duration: Math.min(d, g)\n      };\n    },\n        D = h.animate = function (l, v, w) {\n      var r,\n          d = \"\",\n          g,\n          c;\n\n      if (!C(w)) {\n        var a = arguments;\n        w = {\n          duration: a[2],\n          easing: a[3],\n          complete: a[4]\n        };\n      }\n\n      K(w.duration) || (w.duration = 400);\n      w.easing = \"function\" === typeof w.easing ? w.easing : Math[w.easing] || Math.easeInOutSine;\n      w.curAnim = y(v);\n      e(v, function (a, p) {\n        n(l, p);\n        c = new f(l, w, p);\n        g = null;\n        \"d\" === p && L(v.d) ? (c.paths = c.initPath(l, l.pathArray, v.d), c.toD = v.d, r = 0, g = 1) : l.attr ? r = l.attr(p) : (r = parseFloat(P(l, p)) || 0, \"opacity\" !== p && (d = \"px\"));\n        g || (g = a);\n        g && g.match && g.match(\"px\") && (g = g.replace(/px/g, \"\"));\n        c.run(r, g, d);\n      });\n    },\n        n = h.stop = function (l, n) {\n      for (var w = h.timers.length; w--;) h.timers[w].elem !== l || n && n !== h.timers[w].prop || (h.timers[w].stopped = !0);\n    };\n\n    return {\n      animate: D,\n      animObject: v,\n      getDeferredAnimation: x,\n      setAnimation: m,\n      stop: n\n    };\n  });\n  N(m, \"Core/Renderer/SVG/SVGElement.js\", [m[\"Core/Animation/AnimationUtilities.js\"], m[\"Core/Color/Color.js\"], m[\"Core/Globals.js\"], m[\"Core/Utilities.js\"]], function (f, h, m, z) {\n    var F = f.animate,\n        P = f.animObject,\n        K = f.stop,\n        C = m.deg2rad,\n        y = m.doc,\n        e = m.hasTouch,\n        I = m.isFirefox,\n        v = m.noop,\n        x = m.svg,\n        D = m.SVG_NS,\n        n = m.win,\n        l = z.attr,\n        J = z.createElement,\n        w = z.css,\n        r = z.defined,\n        d = z.erase,\n        g = z.extend,\n        c = z.fireEvent,\n        a = z.isArray,\n        q = z.isFunction,\n        p = z.isNumber,\n        B = z.isString,\n        A = z.merge,\n        G = z.objectEach,\n        M = z.pick,\n        T = z.pInt,\n        Q = z.syncTimeout,\n        O = z.uniqueKey;\n    \"\";\n\n    f = function () {\n      function E() {\n        this.height = this.element = void 0;\n        this.opacity = 1;\n        this.renderer = void 0;\n        this.SVG_NS = D;\n        this.symbolCustomAttribs = \"x y width height r start end innerR anchorX anchorY rounded\".split(\" \");\n        this.width = void 0;\n      }\n\n      E.prototype._defaultGetter = function (a) {\n        a = M(this[a + \"Value\"], this[a], this.element ? this.element.getAttribute(a) : null, 0);\n        /^[\\-0-9\\.]+$/.test(a) && (a = parseFloat(a));\n        return a;\n      };\n\n      E.prototype._defaultSetter = function (a, b, k) {\n        k.setAttribute(b, a);\n      };\n\n      E.prototype.add = function (a) {\n        var b = this.renderer,\n            k = this.element;\n        a && (this.parentGroup = a);\n        this.parentInverted = a && a.inverted;\n        \"undefined\" !== typeof this.textStr && \"text\" === this.element.nodeName && b.buildText(this);\n        this.added = !0;\n        if (!a || a.handleZ || this.zIndex) var t = this.zIndexSetter();\n        t || (a ? a.element : b.box).appendChild(k);\n        if (this.onAdd) this.onAdd();\n        return this;\n      };\n\n      E.prototype.addClass = function (a, b) {\n        var k = b ? \"\" : this.attr(\"class\") || \"\";\n        a = (a || \"\").split(/ /g).reduce(function (b, a) {\n          -1 === k.indexOf(a) && b.push(a);\n          return b;\n        }, k ? [k] : []).join(\" \");\n        a !== k && this.attr(\"class\", a);\n        return this;\n      };\n\n      E.prototype.afterSetters = function () {\n        this.doTransform && (this.updateTransform(), this.doTransform = !1);\n      };\n\n      E.prototype.align = function (a, b, k) {\n        var t,\n            c = {};\n        var u = this.renderer;\n        var g = u.alignedObjects;\n        var p, q;\n\n        if (a) {\n          if (this.alignOptions = a, this.alignByTranslate = b, !k || B(k)) this.alignTo = t = k || \"renderer\", d(g, this), g.push(this), k = void 0;\n        } else a = this.alignOptions, b = this.alignByTranslate, t = this.alignTo;\n\n        k = M(k, u[t], u);\n        t = a.align;\n        u = a.verticalAlign;\n        g = (k.x || 0) + (a.x || 0);\n        var r = (k.y || 0) + (a.y || 0);\n        \"right\" === t ? p = 1 : \"center\" === t && (p = 2);\n        p && (g += (k.width - (a.width || 0)) / p);\n        c[b ? \"translateX\" : \"x\"] = Math.round(g);\n        \"bottom\" === u ? q = 1 : \"middle\" === u && (q = 2);\n        q && (r += (k.height - (a.height || 0)) / q);\n        c[b ? \"translateY\" : \"y\"] = Math.round(r);\n        this[this.placed ? \"animate\" : \"attr\"](c);\n        this.placed = !0;\n        this.alignAttr = c;\n        return this;\n      };\n\n      E.prototype.alignSetter = function (a) {\n        var b = {\n          left: \"start\",\n          center: \"middle\",\n          right: \"end\"\n        };\n        b[a] && (this.alignValue = a, this.element.setAttribute(\"text-anchor\", b[a]));\n      };\n\n      E.prototype.animate = function (a, b, k) {\n        var t = this,\n            c = P(M(b, this.renderer.globalAnimation, !0));\n        b = c.defer;\n        M(y.hidden, y.msHidden, y.webkitHidden, !1) && (c.duration = 0);\n        0 !== c.duration ? (k && (c.complete = k), Q(function () {\n          t.element && F(t, a, c);\n        }, b)) : (this.attr(a, void 0, k), G(a, function (b, k) {\n          c.step && c.step.call(this, b, {\n            prop: k,\n            pos: 1\n          });\n        }, this));\n        return this;\n      };\n\n      E.prototype.applyTextOutline = function (a) {\n        var b = this.element,\n            k;\n        -1 !== a.indexOf(\"contrast\") && (a = a.replace(/contrast/g, this.renderer.getContrast(b.style.fill)));\n        a = a.split(\" \");\n        var t = a[a.length - 1];\n\n        if ((k = a[0]) && \"none\" !== k && m.svg) {\n          this.fakeTS = !0;\n          a = [].slice.call(b.getElementsByTagName(\"tspan\"));\n          this.ySetter = this.xSetter;\n          k = k.replace(/(^[\\d\\.]+)(.*?)$/g, function (b, k, t) {\n            return 2 * k + t;\n          });\n          this.removeTextOutline(a);\n          var c = b.textContent ? /^[\\u0591-\\u065F\\u066A-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC]/.test(b.textContent) : !1;\n          var u = b.firstChild;\n          a.forEach(function (a, H) {\n            0 === H && (a.setAttribute(\"x\", b.getAttribute(\"x\")), H = b.getAttribute(\"y\"), a.setAttribute(\"y\", H || 0), null === H && b.setAttribute(\"y\", 0));\n            H = a.cloneNode(!0);\n            l(c && !I ? a : H, {\n              \"class\": \"highcharts-text-outline\",\n              fill: t,\n              stroke: t,\n              \"stroke-width\": k,\n              \"stroke-linejoin\": \"round\"\n            });\n            b.insertBefore(H, u);\n          });\n          c && I && a[0] && (a = a[0].cloneNode(!0), a.textContent = \" \", b.insertBefore(a, u));\n        }\n      };\n\n      E.prototype.attr = function (a, b, k, t) {\n        var c = this.element,\n            u,\n            d = this,\n            g,\n            p,\n            q = this.symbolCustomAttribs;\n\n        if (\"string\" === typeof a && \"undefined\" !== typeof b) {\n          var r = a;\n          a = {};\n          a[r] = b;\n        }\n\n        \"string\" === typeof a ? d = (this[a + \"Getter\"] || this._defaultGetter).call(this, a, c) : (G(a, function (b, k) {\n          g = !1;\n          t || K(this, k);\n          this.symbolName && -1 !== q.indexOf(k) && (u || (this.symbolAttr(a), u = !0), g = !0);\n          !this.rotation || \"x\" !== k && \"y\" !== k || (this.doTransform = !0);\n          g || (p = this[k + \"Setter\"] || this._defaultSetter, p.call(this, b, k, c), !this.styledMode && this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(k) && this.updateShadows(k, b, p));\n        }, this), this.afterSetters());\n        k && k.call(this);\n        return d;\n      };\n\n      E.prototype.clip = function (a) {\n        return this.attr(\"clip-path\", a ? \"url(\" + this.renderer.url + \"#\" + a.id + \")\" : \"none\");\n      };\n\n      E.prototype.crisp = function (a, b) {\n        b = b || a.strokeWidth || 0;\n        var k = Math.round(b) % 2 / 2;\n        a.x = Math.floor(a.x || this.x || 0) + k;\n        a.y = Math.floor(a.y || this.y || 0) + k;\n        a.width = Math.floor((a.width || this.width || 0) - 2 * k);\n        a.height = Math.floor((a.height || this.height || 0) - 2 * k);\n        r(a.strokeWidth) && (a.strokeWidth = b);\n        return a;\n      };\n\n      E.prototype.complexColor = function (u, b, k) {\n        var t = this.renderer,\n            H,\n            d,\n            g,\n            p,\n            q,\n            B,\n            l,\n            n,\n            w,\n            E,\n            V = [],\n            v;\n        c(this.renderer, \"complexColor\", {\n          args: arguments\n        }, function () {\n          u.radialGradient ? d = \"radialGradient\" : u.linearGradient && (d = \"linearGradient\");\n\n          if (d) {\n            g = u[d];\n            q = t.gradients;\n            B = u.stops;\n            w = k.radialReference;\n            a(g) && (u[d] = g = {\n              x1: g[0],\n              y1: g[1],\n              x2: g[2],\n              y2: g[3],\n              gradientUnits: \"userSpaceOnUse\"\n            });\n            \"radialGradient\" === d && w && !r(g.gradientUnits) && (p = g, g = A(g, t.getRadialAttr(w, p), {\n              gradientUnits: \"userSpaceOnUse\"\n            }));\n            G(g, function (b, k) {\n              \"id\" !== k && V.push(k, b);\n            });\n            G(B, function (b) {\n              V.push(b);\n            });\n            V = V.join(\",\");\n            if (q[V]) E = q[V].attr(\"id\");else {\n              g.id = E = O();\n              var c = q[V] = t.createElement(d).attr(g).add(t.defs);\n              c.radAttr = p;\n              c.stops = [];\n              B.forEach(function (b) {\n                0 === b[1].indexOf(\"rgba\") ? (H = h.parse(b[1]), l = H.get(\"rgb\"), n = H.get(\"a\")) : (l = b[1], n = 1);\n                b = t.createElement(\"stop\").attr({\n                  offset: b[0],\n                  \"stop-color\": l,\n                  \"stop-opacity\": n\n                }).add(c);\n                c.stops.push(b);\n              });\n            }\n            v = \"url(\" + t.url + \"#\" + E + \")\";\n            k.setAttribute(b, v);\n            k.gradient = V;\n\n            u.toString = function () {\n              return v;\n            };\n          }\n        });\n      };\n\n      E.prototype.css = function (a) {\n        var b = this.styles,\n            k = {},\n            t = this.element,\n            c = \"\",\n            d = !b,\n            u = [\"textOutline\", \"textOverflow\", \"width\"];\n        a && a.color && (a.fill = a.color);\n        b && G(a, function (a, t) {\n          b && b[t] !== a && (k[t] = a, d = !0);\n        });\n\n        if (d) {\n          b && (a = g(b, k));\n          if (a) if (null === a.width || \"auto\" === a.width) delete this.textWidth;else if (\"text\" === t.nodeName.toLowerCase() && a.width) var p = this.textWidth = T(a.width);\n          this.styles = a;\n          p && !x && this.renderer.forExport && delete a.width;\n\n          if (t.namespaceURI === this.SVG_NS) {\n            var q = function (b, k) {\n              return \"-\" + k.toLowerCase();\n            };\n\n            G(a, function (b, k) {\n              -1 === u.indexOf(k) && (c += k.replace(/([A-Z])/g, q) + \":\" + b + \";\");\n            });\n            c && l(t, \"style\", c);\n          } else w(t, a);\n\n          this.added && (\"text\" === this.element.nodeName && this.renderer.buildText(this), a && a.textOutline && this.applyTextOutline(a.textOutline));\n        }\n\n        return this;\n      };\n\n      E.prototype.dashstyleSetter = function (a) {\n        var b = this[\"stroke-width\"];\n        \"inherit\" === b && (b = 1);\n\n        if (a = a && a.toLowerCase()) {\n          var k = a.replace(\"shortdashdotdot\", \"3,1,1,1,1,1,\").replace(\"shortdashdot\", \"3,1,1,1\").replace(\"shortdot\", \"1,1,\").replace(\"shortdash\", \"3,1,\").replace(\"longdash\", \"8,3,\").replace(/dot/g, \"1,3,\").replace(\"dash\", \"4,3,\").replace(/,$/, \"\").split(\",\");\n\n          for (a = k.length; a--;) k[a] = \"\" + T(k[a]) * M(b, NaN);\n\n          a = k.join(\",\").replace(/NaN/g, \"none\");\n          this.element.setAttribute(\"stroke-dasharray\", a);\n        }\n      };\n\n      E.prototype.destroy = function () {\n        var a = this,\n            b = a.element || {},\n            k = a.renderer,\n            t = k.isSVG && \"SPAN\" === b.nodeName && a.parentGroup || void 0,\n            c = b.ownerSVGElement;\n        b.onclick = b.onmouseout = b.onmouseover = b.onmousemove = b.point = null;\n        K(a);\n\n        if (a.clipPath && c) {\n          var g = a.clipPath;\n          [].forEach.call(c.querySelectorAll(\"[clip-path],[CLIP-PATH]\"), function (b) {\n            -1 < b.getAttribute(\"clip-path\").indexOf(g.element.id) && b.removeAttribute(\"clip-path\");\n          });\n          a.clipPath = g.destroy();\n        }\n\n        if (a.stops) {\n          for (c = 0; c < a.stops.length; c++) a.stops[c].destroy();\n\n          a.stops.length = 0;\n          a.stops = void 0;\n        }\n\n        a.safeRemoveChild(b);\n\n        for (k.styledMode || a.destroyShadows(); t && t.div && 0 === t.div.childNodes.length;) b = t.parentGroup, a.safeRemoveChild(t.div), delete t.div, t = b;\n\n        a.alignTo && d(k.alignedObjects, a);\n        G(a, function (b, k) {\n          a[k] && a[k].parentGroup === a && a[k].destroy && a[k].destroy();\n          delete a[k];\n        });\n      };\n\n      E.prototype.destroyShadows = function () {\n        (this.shadows || []).forEach(function (a) {\n          this.safeRemoveChild(a);\n        }, this);\n        this.shadows = void 0;\n      };\n\n      E.prototype.destroyTextPath = function (a, b) {\n        var k = a.getElementsByTagName(\"text\")[0];\n\n        if (k) {\n          if (k.removeAttribute(\"dx\"), k.removeAttribute(\"dy\"), b.element.setAttribute(\"id\", \"\"), this.textPathWrapper && k.getElementsByTagName(\"textPath\").length) {\n            for (a = this.textPathWrapper.element.childNodes; a.length;) k.appendChild(a[0]);\n\n            k.removeChild(this.textPathWrapper.element);\n          }\n        } else if (a.getAttribute(\"dx\") || a.getAttribute(\"dy\")) a.removeAttribute(\"dx\"), a.removeAttribute(\"dy\");\n\n        this.textPathWrapper && (this.textPathWrapper = this.textPathWrapper.destroy());\n      };\n\n      E.prototype.dSetter = function (c, b, k) {\n        a(c) && (\"string\" === typeof c[0] && (c = this.renderer.pathToSegments(c)), this.pathArray = c, c = c.reduce(function (b, k, a) {\n          return k && k.join ? (a ? b + \" \" : \"\") + k.join(\" \") : (k || \"\").toString();\n        }, \"\"));\n        /(NaN| {2}|^$)/.test(c) && (c = \"M 0 0\");\n        this[b] !== c && (k.setAttribute(b, c), this[b] = c);\n      };\n\n      E.prototype.fadeOut = function (a) {\n        var b = this;\n        b.animate({\n          opacity: 0\n        }, {\n          duration: M(a, 150),\n          complete: function () {\n            b.attr({\n              y: -9999\n            }).hide();\n          }\n        });\n      };\n\n      E.prototype.fillSetter = function (a, b, k) {\n        \"string\" === typeof a ? k.setAttribute(b, a) : a && this.complexColor(a, b, k);\n      };\n\n      E.prototype.getBBox = function (a, b) {\n        var k,\n            t = this.renderer,\n            c = this.element,\n            d = this.styles,\n            p = this.textStr,\n            u = t.cache,\n            B = t.cacheKeys,\n            A = c.namespaceURI === this.SVG_NS;\n        b = M(b, this.rotation, 0);\n        var l = t.styledMode ? c && E.prototype.getStyle.call(c, \"font-size\") : d && d.fontSize;\n\n        if (r(p)) {\n          var n = p.toString();\n          -1 === n.indexOf(\"<\") && (n = n.replace(/[0-9]/g, \"0\"));\n          n += [\"\", b, l, this.textWidth, d && d.textOverflow, d && d.fontWeight].join();\n        }\n\n        n && !a && (k = u[n]);\n\n        if (!k) {\n          if (A || t.forExport) {\n            try {\n              var w = this.fakeTS && function (b) {\n                [].forEach.call(c.querySelectorAll(\".highcharts-text-outline\"), function (k) {\n                  k.style.display = b;\n                });\n              };\n\n              q(w) && w(\"none\");\n              k = c.getBBox ? g({}, c.getBBox()) : {\n                width: c.offsetWidth,\n                height: c.offsetHeight\n              };\n              q(w) && w(\"\");\n            } catch (ca) {\n              \"\";\n            }\n\n            if (!k || 0 > k.width) k = {\n              width: 0,\n              height: 0\n            };\n          } else k = this.htmlGetBBox();\n\n          t.isSVG && (a = k.width, t = k.height, A && (k.height = t = {\n            \"11px,17\": 14,\n            \"13px,20\": 16\n          }[d && d.fontSize + \",\" + Math.round(t)] || t), b && (d = b * C, k.width = Math.abs(t * Math.sin(d)) + Math.abs(a * Math.cos(d)), k.height = Math.abs(t * Math.cos(d)) + Math.abs(a * Math.sin(d))));\n\n          if (n && 0 < k.height) {\n            for (; 250 < B.length;) delete u[B.shift()];\n\n            u[n] || B.push(n);\n            u[n] = k;\n          }\n        }\n\n        return k;\n      };\n\n      E.prototype.getStyle = function (a) {\n        return n.getComputedStyle(this.element || this, \"\").getPropertyValue(a);\n      };\n\n      E.prototype.hasClass = function (a) {\n        return -1 !== (\"\" + this.attr(\"class\")).split(\" \").indexOf(a);\n      };\n\n      E.prototype.hide = function (a) {\n        a ? this.attr({\n          y: -9999\n        }) : this.attr({\n          visibility: \"hidden\"\n        });\n        return this;\n      };\n\n      E.prototype.htmlGetBBox = function () {\n        return {\n          height: 0,\n          width: 0,\n          x: 0,\n          y: 0\n        };\n      };\n\n      E.prototype.init = function (a, b) {\n        this.element = \"span\" === b ? J(b) : y.createElementNS(this.SVG_NS, b);\n        this.renderer = a;\n        c(this, \"afterInit\");\n      };\n\n      E.prototype.invert = function (a) {\n        this.inverted = a;\n        this.updateTransform();\n        return this;\n      };\n\n      E.prototype.on = function (a, b) {\n        var k,\n            t,\n            c = this.element,\n            d;\n        e && \"click\" === a ? (c.ontouchstart = function (b) {\n          k = b.touches[0].clientX;\n          t = b.touches[0].clientY;\n        }, c.ontouchend = function (a) {\n          k && 4 <= Math.sqrt(Math.pow(k - a.changedTouches[0].clientX, 2) + Math.pow(t - a.changedTouches[0].clientY, 2)) || b.call(c, a);\n          d = !0;\n          !1 !== a.cancelable && a.preventDefault();\n        }, c.onclick = function (k) {\n          d || b.call(c, k);\n        }) : c[\"on\" + a] = b;\n        return this;\n      };\n\n      E.prototype.opacitySetter = function (a, b, k) {\n        this.opacity = a = Number(Number(a).toFixed(3));\n        k.setAttribute(b, a);\n      };\n\n      E.prototype.removeClass = function (a) {\n        return this.attr(\"class\", (\"\" + this.attr(\"class\")).replace(B(a) ? new RegExp(\"(^| )\" + a + \"( |$)\") : a, \" \").replace(/ +/g, \" \").trim());\n      };\n\n      E.prototype.removeTextOutline = function (a) {\n        for (var b = a.length, k; b--;) k = a[b], \"highcharts-text-outline\" === k.getAttribute(\"class\") && d(a, this.element.removeChild(k));\n      };\n\n      E.prototype.safeRemoveChild = function (a) {\n        var b = a.parentNode;\n        b && b.removeChild(a);\n      };\n\n      E.prototype.setRadialReference = function (a) {\n        var b = this.element.gradient && this.renderer.gradients[this.element.gradient];\n        this.element.radialReference = a;\n        b && b.radAttr && b.animate(this.renderer.getRadialAttr(a, b.radAttr));\n        return this;\n      };\n\n      E.prototype.setTextPath = function (a, b) {\n        var k = this.element,\n            t = {\n          textAnchor: \"text-anchor\"\n        },\n            c = !1,\n            d = this.textPathWrapper,\n            g = !d;\n        b = A(!0, {\n          enabled: !0,\n          attributes: {\n            dy: -5,\n            startOffset: \"50%\",\n            textAnchor: \"middle\"\n          }\n        }, b);\n        var q = b.attributes;\n\n        if (a && b && b.enabled) {\n          d && null === d.element.parentNode ? (g = !0, d = d.destroy()) : d && this.removeTextOutline.call(d.parentGroup, [].slice.call(k.getElementsByTagName(\"tspan\")));\n          this.options && this.options.padding && (q.dx = -this.options.padding);\n          d || (this.textPathWrapper = d = this.renderer.createElement(\"textPath\"), c = !0);\n          var u = d.element;\n          (b = a.element.getAttribute(\"id\")) || a.element.setAttribute(\"id\", b = O());\n          if (g) for (a = k.getElementsByTagName(\"tspan\"); a.length;) a[0].setAttribute(\"y\", 0), p(q.dx) && a[0].setAttribute(\"x\", -q.dx), u.appendChild(a[0]);\n          c && d && d.add({\n            element: this.text ? this.text.element : k\n          });\n          u.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", this.renderer.url + \"#\" + b);\n          r(q.dy) && (u.parentNode.setAttribute(\"dy\", q.dy), delete q.dy);\n          r(q.dx) && (u.parentNode.setAttribute(\"dx\", q.dx), delete q.dx);\n          G(q, function (b, k) {\n            u.setAttribute(t[k] || k, b);\n          });\n          k.removeAttribute(\"transform\");\n          this.removeTextOutline.call(d, [].slice.call(k.getElementsByTagName(\"tspan\")));\n          this.text && !this.renderer.styledMode && this.attr({\n            fill: \"none\",\n            \"stroke-width\": 0\n          });\n          this.applyTextOutline = this.updateTransform = v;\n        } else d && (delete this.updateTransform, delete this.applyTextOutline, this.destroyTextPath(k, a), this.updateTransform(), this.options && this.options.rotation && this.applyTextOutline(this.options.style.textOutline));\n\n        return this;\n      };\n\n      E.prototype.shadow = function (a, b, k) {\n        var t = [],\n            c = this.element,\n            d = !1,\n            p = this.oldShadowOptions;\n        var q = {\n          color: \"#000000\",\n          offsetX: 1,\n          offsetY: 1,\n          opacity: .15,\n          width: 3\n        };\n        var u;\n        !0 === a ? u = q : \"object\" === typeof a && (u = g(q, a));\n        u && (u && p && G(u, function (b, k) {\n          b !== p[k] && (d = !0);\n        }), d && this.destroyShadows(), this.oldShadowOptions = u);\n        if (!u) this.destroyShadows();else if (!this.shadows) {\n          var r = u.opacity / u.width;\n          var B = this.parentInverted ? \"translate(-1,-1)\" : \"translate(\" + u.offsetX + \", \" + u.offsetY + \")\";\n\n          for (q = 1; q <= u.width; q++) {\n            var A = c.cloneNode(!1);\n            var n = 2 * u.width + 1 - 2 * q;\n            l(A, {\n              stroke: a.color || \"#000000\",\n              \"stroke-opacity\": r * q,\n              \"stroke-width\": n,\n              transform: B,\n              fill: \"none\"\n            });\n            A.setAttribute(\"class\", (A.getAttribute(\"class\") || \"\") + \" highcharts-shadow\");\n            k && (l(A, \"height\", Math.max(l(A, \"height\") - n, 0)), A.cutHeight = n);\n            b ? b.element.appendChild(A) : c.parentNode && c.parentNode.insertBefore(A, c);\n            t.push(A);\n          }\n\n          this.shadows = t;\n        }\n        return this;\n      };\n\n      E.prototype.show = function (a) {\n        return this.attr({\n          visibility: a ? \"inherit\" : \"visible\"\n        });\n      };\n\n      E.prototype.strokeSetter = function (a, b, k) {\n        this[b] = a;\n        this.stroke && this[\"stroke-width\"] ? (E.prototype.fillSetter.call(this, this.stroke, \"stroke\", k), k.setAttribute(\"stroke-width\", this[\"stroke-width\"]), this.hasStroke = !0) : \"stroke-width\" === b && 0 === a && this.hasStroke ? (k.removeAttribute(\"stroke\"), this.hasStroke = !1) : this.renderer.styledMode && this[\"stroke-width\"] && (k.setAttribute(\"stroke-width\", this[\"stroke-width\"]), this.hasStroke = !0);\n      };\n\n      E.prototype.strokeWidth = function () {\n        if (!this.renderer.styledMode) return this[\"stroke-width\"] || 0;\n        var a = this.getStyle(\"stroke-width\"),\n            b = 0;\n        if (a.indexOf(\"px\") === a.length - 2) b = T(a);else if (\"\" !== a) {\n          var k = y.createElementNS(D, \"rect\");\n          l(k, {\n            width: a,\n            \"stroke-width\": 0\n          });\n          this.element.parentNode.appendChild(k);\n          b = k.getBBox().width;\n          k.parentNode.removeChild(k);\n        }\n        return b;\n      };\n\n      E.prototype.symbolAttr = function (a) {\n        var b = this;\n        \"x y r start end width height innerR anchorX anchorY clockwise\".split(\" \").forEach(function (k) {\n          b[k] = M(a[k], b[k]);\n        });\n        b.attr({\n          d: b.renderer.symbols[b.symbolName](b.x, b.y, b.width, b.height, b)\n        });\n      };\n\n      E.prototype.textSetter = function (a) {\n        a !== this.textStr && (delete this.textPxLength, this.textStr = a, this.added && this.renderer.buildText(this));\n      };\n\n      E.prototype.titleSetter = function (a) {\n        var b = this.element.getElementsByTagName(\"title\")[0];\n        b || (b = y.createElementNS(this.SVG_NS, \"title\"), this.element.appendChild(b));\n        b.firstChild && b.removeChild(b.firstChild);\n        b.appendChild(y.createTextNode(String(M(a, \"\")).replace(/<[^>]*>/g, \"\").replace(/&lt;/g, \"<\").replace(/&gt;/g, \">\")));\n      };\n\n      E.prototype.toFront = function () {\n        var a = this.element;\n        a.parentNode.appendChild(a);\n        return this;\n      };\n\n      E.prototype.translate = function (a, b) {\n        return this.attr({\n          translateX: a,\n          translateY: b\n        });\n      };\n\n      E.prototype.updateShadows = function (a, b, k) {\n        var t = this.shadows;\n        if (t) for (var c = t.length; c--;) k.call(t[c], \"height\" === a ? Math.max(b - (t[c].cutHeight || 0), 0) : \"d\" === a ? this.d : b, a, t[c]);\n      };\n\n      E.prototype.updateTransform = function () {\n        var a = this.translateX || 0,\n            b = this.translateY || 0,\n            k = this.scaleX,\n            t = this.scaleY,\n            c = this.inverted,\n            d = this.rotation,\n            g = this.matrix,\n            p = this.element;\n        c && (a += this.width, b += this.height);\n        a = [\"translate(\" + a + \",\" + b + \")\"];\n        r(g) && a.push(\"matrix(\" + g.join(\",\") + \")\");\n        c ? a.push(\"rotate(90) scale(-1,1)\") : d && a.push(\"rotate(\" + d + \" \" + M(this.rotationOriginX, p.getAttribute(\"x\"), 0) + \" \" + M(this.rotationOriginY, p.getAttribute(\"y\") || 0) + \")\");\n        (r(k) || r(t)) && a.push(\"scale(\" + M(k, 1) + \" \" + M(t, 1) + \")\");\n        a.length && p.setAttribute(\"transform\", a.join(\" \"));\n      };\n\n      E.prototype.visibilitySetter = function (a, b, k) {\n        \"inherit\" === a ? k.removeAttribute(b) : this[b] !== a && k.setAttribute(b, a);\n        this[b] = a;\n      };\n\n      E.prototype.xGetter = function (a) {\n        \"circle\" === this.element.nodeName && (\"x\" === a ? a = \"cx\" : \"y\" === a && (a = \"cy\"));\n        return this._defaultGetter(a);\n      };\n\n      E.prototype.zIndexSetter = function (a, b) {\n        var k = this.renderer,\n            t = this.parentGroup,\n            c = (t || k).element || k.box,\n            d = this.element,\n            g = !1;\n        k = c === k.box;\n        var p = this.added;\n        var q;\n        r(a) ? (d.setAttribute(\"data-z-index\", a), a = +a, this[b] === a && (p = !1)) : r(this[b]) && d.removeAttribute(\"data-z-index\");\n        this[b] = a;\n\n        if (p) {\n          (a = this.zIndex) && t && (t.handleZ = !0);\n          b = c.childNodes;\n\n          for (q = b.length - 1; 0 <= q && !g; q--) {\n            t = b[q];\n            p = t.getAttribute(\"data-z-index\");\n            var u = !r(p);\n            if (t !== d) if (0 > a && u && !k && !q) c.insertBefore(d, b[q]), g = !0;else if (T(p) <= a || u && (!r(a) || 0 <= a)) c.insertBefore(d, b[q + 1] || null), g = !0;\n          }\n\n          g || (c.insertBefore(d, b[k ? 3 : 0] || null), g = !0);\n        }\n\n        return g;\n      };\n\n      return E;\n    }();\n\n    f.prototype[\"stroke-widthSetter\"] = f.prototype.strokeSetter;\n    f.prototype.yGetter = f.prototype.xGetter;\n\n    f.prototype.matrixSetter = f.prototype.rotationOriginXSetter = f.prototype.rotationOriginYSetter = f.prototype.rotationSetter = f.prototype.scaleXSetter = f.prototype.scaleYSetter = f.prototype.translateXSetter = f.prototype.translateYSetter = f.prototype.verticalAlignSetter = function (a, c) {\n      this[c] = a;\n      this.doTransform = !0;\n    };\n\n    m.SVGElement = f;\n    return m.SVGElement;\n  });\n  N(m, \"Core/Renderer/SVG/SVGLabel.js\", [m[\"Core/Renderer/SVG/SVGElement.js\"], m[\"Core/Utilities.js\"]], function (f, h) {\n    var m = this && this.__extends || function () {\n      var f = function (e, I) {\n        f = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (v, e) {\n          v.__proto__ = e;\n        } || function (v, e) {\n          for (var f in e) e.hasOwnProperty(f) && (v[f] = e[f]);\n        };\n\n        return f(e, I);\n      };\n\n      return function (e, I) {\n        function v() {\n          this.constructor = e;\n        }\n\n        f(e, I);\n        e.prototype = null === I ? Object.create(I) : (v.prototype = I.prototype, new v());\n      };\n    }(),\n        z = h.defined,\n        F = h.extend,\n        L = h.isNumber,\n        K = h.merge,\n        C = h.removeEvent;\n\n    return function (h) {\n      function e(f, v, x, D, n, l, J, w, r, d) {\n        var g = h.call(this) || this;\n        g.init(f, \"g\");\n        g.textStr = v;\n        g.x = x;\n        g.y = D;\n        g.anchorX = l;\n        g.anchorY = J;\n        g.baseline = r;\n        g.className = d;\n        \"button\" !== d && g.addClass(\"highcharts-label\");\n        d && g.addClass(\"highcharts-\" + d);\n        g.text = f.text(\"\", 0, 0, w).attr({\n          zIndex: 1\n        });\n\n        if (\"string\" === typeof n) {\n          var c = /^url\\((.*?)\\)$/.test(n);\n          if (g.renderer.symbols[n] || c) g.symbolKey = n;\n        }\n\n        g.bBox = e.emptyBBox;\n        g.padding = 3;\n        g.paddingLeft = 0;\n        g.baselineOffset = 0;\n        g.needsBox = f.styledMode || c;\n        g.deferredAttr = {};\n        g.alignFactor = 0;\n        return g;\n      }\n\n      m(e, h);\n\n      e.prototype.alignSetter = function (e) {\n        e = {\n          left: 0,\n          center: .5,\n          right: 1\n        }[e];\n        e !== this.alignFactor && (this.alignFactor = e, this.bBox && L(this.xSetting) && this.attr({\n          x: this.xSetting\n        }));\n      };\n\n      e.prototype.anchorXSetter = function (e, v) {\n        this.anchorX = e;\n        this.boxAttr(v, Math.round(e) - this.getCrispAdjust() - this.xSetting);\n      };\n\n      e.prototype.anchorYSetter = function (e, v) {\n        this.anchorY = e;\n        this.boxAttr(v, e - this.ySetting);\n      };\n\n      e.prototype.boxAttr = function (e, v) {\n        this.box ? this.box.attr(e, v) : this.deferredAttr[e] = v;\n      };\n\n      e.prototype.css = function (h) {\n        if (h) {\n          var v = {};\n          h = K(h);\n          e.textProps.forEach(function (e) {\n            \"undefined\" !== typeof h[e] && (v[e] = h[e], delete h[e]);\n          });\n          this.text.css(v);\n          var I = \"fontSize\" in v || \"fontWeight\" in v;\n          if (\"width\" in v || I) this.updateBoxSize(), I && this.updateTextPadding();\n        }\n\n        return f.prototype.css.call(this, h);\n      };\n\n      e.prototype.destroy = function () {\n        C(this.element, \"mouseenter\");\n        C(this.element, \"mouseleave\");\n        this.text && this.text.destroy();\n        this.box && (this.box = this.box.destroy());\n        f.prototype.destroy.call(this);\n      };\n\n      e.prototype.fillSetter = function (e, v) {\n        e && (this.needsBox = !0);\n        this.fill = e;\n        this.boxAttr(v, e);\n      };\n\n      e.prototype.getBBox = function () {\n        var e = this.bBox,\n            v = this.padding;\n        return {\n          width: e.width + 2 * v,\n          height: e.height + 2 * v,\n          x: e.x - v,\n          y: e.y - v\n        };\n      };\n\n      e.prototype.getCrispAdjust = function () {\n        return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this[\"stroke-width\"] ? parseInt(this[\"stroke-width\"], 10) : 0) % 2 / 2;\n      };\n\n      e.prototype.heightSetter = function (e) {\n        this.heightSetting = e;\n      };\n\n      e.prototype.on = function (e, v) {\n        var h = this,\n            D = h.text,\n            n = D && \"SPAN\" === D.element.tagName ? D : void 0;\n\n        if (n) {\n          var l = function (l) {\n            (\"mouseenter\" === e || \"mouseleave\" === e) && l.relatedTarget instanceof Element && (h.element.contains(l.relatedTarget) || n.element.contains(l.relatedTarget)) || v.call(h.element, l);\n          };\n\n          n.on(e, l);\n        }\n\n        f.prototype.on.call(h, e, l || v);\n        return h;\n      };\n\n      e.prototype.onAdd = function () {\n        var e = this.textStr;\n        this.text.add(this);\n        this.attr({\n          text: z(e) ? e : \"\",\n          x: this.x,\n          y: this.y\n        });\n        this.box && z(this.anchorX) && this.attr({\n          anchorX: this.anchorX,\n          anchorY: this.anchorY\n        });\n      };\n\n      e.prototype.paddingSetter = function (e) {\n        z(e) && e !== this.padding && (this.padding = e, this.updateTextPadding());\n      };\n\n      e.prototype.paddingLeftSetter = function (e) {\n        z(e) && e !== this.paddingLeft && (this.paddingLeft = e, this.updateTextPadding());\n      };\n\n      e.prototype.rSetter = function (e, v) {\n        this.boxAttr(v, e);\n      };\n\n      e.prototype.shadow = function (e) {\n        e && !this.renderer.styledMode && (this.updateBoxSize(), this.box && this.box.shadow(e));\n        return this;\n      };\n\n      e.prototype.strokeSetter = function (e, v) {\n        this.stroke = e;\n        this.boxAttr(v, e);\n      };\n\n      e.prototype[\"stroke-widthSetter\"] = function (e, v) {\n        e && (this.needsBox = !0);\n        this[\"stroke-width\"] = e;\n        this.boxAttr(v, e);\n      };\n\n      e.prototype[\"text-alignSetter\"] = function (e) {\n        this.textAlign = e;\n      };\n\n      e.prototype.textSetter = function (e) {\n        \"undefined\" !== typeof e && this.text.attr({\n          text: e\n        });\n        this.updateBoxSize();\n        this.updateTextPadding();\n      };\n\n      e.prototype.updateBoxSize = function () {\n        var f = this.text.element.style,\n            v = {},\n            h = this.padding,\n            D = this.paddingLeft,\n            n = L(this.widthSetting) && L(this.heightSetting) && !this.textAlign || !z(this.text.textStr) ? e.emptyBBox : this.text.getBBox();\n        this.width = (this.widthSetting || n.width || 0) + 2 * h + D;\n        this.height = (this.heightSetting || n.height || 0) + 2 * h;\n        this.baselineOffset = h + Math.min(this.renderer.fontMetrics(f && f.fontSize, this.text).b, n.height || Infinity);\n        this.needsBox && (this.box || (f = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect(), f.addClass((\"button\" === this.className ? \"\" : \"highcharts-label-box\") + (this.className ? \" highcharts-\" + this.className + \"-box\" : \"\")), f.add(this), f = this.getCrispAdjust(), v.x = f, v.y = (this.baseline ? -this.baselineOffset : 0) + f), v.width = Math.round(this.width), v.height = Math.round(this.height), this.box.attr(F(v, this.deferredAttr)), this.deferredAttr = {});\n        this.bBox = n;\n      };\n\n      e.prototype.updateTextPadding = function () {\n        var e = this.text,\n            f = this.baseline ? 0 : this.baselineOffset,\n            h = this.paddingLeft + this.padding;\n        z(this.widthSetting) && this.bBox && (\"center\" === this.textAlign || \"right\" === this.textAlign) && (h += {\n          center: .5,\n          right: 1\n        }[this.textAlign] * (this.widthSetting - this.bBox.width));\n        if (h !== e.x || f !== e.y) e.attr(\"x\", h), e.hasBoxWidthChanged && (this.bBox = e.getBBox(!0), this.updateBoxSize()), \"undefined\" !== typeof f && e.attr(\"y\", f);\n        e.x = h;\n        e.y = f;\n      };\n\n      e.prototype.widthSetter = function (e) {\n        this.widthSetting = L(e) ? e : void 0;\n      };\n\n      e.prototype.xSetter = function (e) {\n        this.x = e;\n        this.alignFactor && (e -= this.alignFactor * ((this.widthSetting || this.bBox.width) + 2 * this.padding), this[\"forceAnimate:x\"] = !0);\n        this.xSetting = Math.round(e);\n        this.attr(\"translateX\", this.xSetting);\n      };\n\n      e.prototype.ySetter = function (e) {\n        this.ySetting = this.y = Math.round(e);\n        this.attr(\"translateY\", this.ySetting);\n      };\n\n      e.emptyBBox = {\n        width: 0,\n        height: 0,\n        x: 0,\n        y: 0\n      };\n      e.textProps = \"color cursor direction fontFamily fontSize fontStyle fontWeight lineHeight textAlign textDecoration textOutline textOverflow width\".split(\" \");\n      return e;\n    }(f);\n  });\n  N(m, \"Core/Renderer/SVG/SVGRenderer.js\", [m[\"Core/Color/Color.js\"], m[\"Core/Globals.js\"], m[\"Core/Renderer/SVG/SVGElement.js\"], m[\"Core/Renderer/SVG/SVGLabel.js\"], m[\"Core/Utilities.js\"]], function (f, h, m, z, F) {\n    var P = F.addEvent,\n        K = F.attr,\n        C = F.createElement,\n        y = F.css,\n        e = F.defined,\n        I = F.destroyObjectProperties,\n        v = F.extend,\n        x = F.isArray,\n        D = F.isNumber,\n        n = F.isObject,\n        l = F.isString,\n        J = F.merge,\n        w = F.objectEach,\n        r = F.pick,\n        d = F.pInt,\n        g = F.splat,\n        c = F.uniqueKey,\n        a = h.charts,\n        q = h.deg2rad,\n        p = h.doc,\n        B = h.isFirefox,\n        A = h.isMS,\n        G = h.isWebKit;\n    F = h.noop;\n\n    var M = h.svg,\n        T = h.SVG_NS,\n        Q = h.symbolSizes,\n        O = h.win,\n        E = function () {\n      function u(b, k, a, c, d, g, p) {\n        this.width = this.url = this.style = this.isSVG = this.imgCount = this.height = this.gradients = this.globalAnimation = this.defs = this.chartIndex = this.cacheKeys = this.cache = this.boxWrapper = this.box = this.alignedObjects = void 0;\n        this.init(b, k, a, c, d, g, p);\n      }\n\n      u.prototype.init = function (b, k, a, c, d, g, q) {\n        var t = this.createElement(\"svg\").attr({\n          version: \"1.1\",\n          \"class\": \"highcharts-root\"\n        });\n        q || t.css(this.getStyle(c));\n        c = t.element;\n        b.appendChild(c);\n        K(b, \"dir\", \"ltr\");\n        -1 === b.innerHTML.indexOf(\"xmlns\") && K(c, \"xmlns\", this.SVG_NS);\n        this.isSVG = !0;\n        this.box = c;\n        this.boxWrapper = t;\n        this.alignedObjects = [];\n        this.url = (B || G) && p.getElementsByTagName(\"base\").length ? O.location.href.split(\"#\")[0].replace(/<[^>]*>/g, \"\").replace(/([\\('\\)])/g, \"\\\\$1\").replace(/ /g, \"%20\") : \"\";\n        this.createElement(\"desc\").add().element.appendChild(p.createTextNode(\"Created with Highcharts 8.2.2\"));\n        this.defs = this.createElement(\"defs\").add();\n        this.allowHTML = g;\n        this.forExport = d;\n        this.styledMode = q;\n        this.gradients = {};\n        this.cache = {};\n        this.cacheKeys = [];\n        this.imgCount = 0;\n        this.setSize(k, a, !1);\n        var H;\n        B && b.getBoundingClientRect && (k = function () {\n          y(b, {\n            left: 0,\n            top: 0\n          });\n          H = b.getBoundingClientRect();\n          y(b, {\n            left: Math.ceil(H.left) - H.left + \"px\",\n            top: Math.ceil(H.top) - H.top + \"px\"\n          });\n        }, k(), this.unSubPixelFix = P(O, \"resize\", k));\n      };\n\n      u.prototype.definition = function (b) {\n        function k(b, t) {\n          var c;\n          g(b).forEach(function (b) {\n            var d = a.createElement(b.tagName),\n                g = {};\n            w(b, function (b, k) {\n              \"tagName\" !== k && \"children\" !== k && \"textContent\" !== k && (g[k] = b);\n            });\n            d.attr(g);\n            d.add(t || a.defs);\n            b.textContent && d.element.appendChild(p.createTextNode(b.textContent));\n            k(b.children || [], d);\n            c = d;\n          });\n          return c;\n        }\n\n        var a = this;\n        return k(b);\n      };\n\n      u.prototype.getStyle = function (b) {\n        return this.style = v({\n          fontFamily: '\"Lucida Grande\", \"Lucida Sans Unicode\", Arial, Helvetica, sans-serif',\n          fontSize: \"12px\"\n        }, b);\n      };\n\n      u.prototype.setStyle = function (b) {\n        this.boxWrapper.css(this.getStyle(b));\n      };\n\n      u.prototype.isHidden = function () {\n        return !this.boxWrapper.getBBox().width;\n      };\n\n      u.prototype.destroy = function () {\n        var b = this.defs;\n        this.box = null;\n        this.boxWrapper = this.boxWrapper.destroy();\n        I(this.gradients || {});\n        this.gradients = null;\n        b && (this.defs = b.destroy());\n        this.unSubPixelFix && this.unSubPixelFix();\n        return this.alignedObjects = null;\n      };\n\n      u.prototype.createElement = function (b) {\n        var k = new this.Element();\n        k.init(this, b);\n        return k;\n      };\n\n      u.prototype.getRadialAttr = function (b, k) {\n        return {\n          cx: b[0] - b[2] / 2 + k.cx * b[2],\n          cy: b[1] - b[2] / 2 + k.cy * b[2],\n          r: k.r * b[2]\n        };\n      };\n\n      u.prototype.truncate = function (b, k, a, c, d, g, q) {\n        var t = this,\n            H = b.rotation,\n            R,\n            u = c ? 1 : 0,\n            A = (a || c).length,\n            r = A,\n            B = [],\n            n = function (b) {\n          k.firstChild && k.removeChild(k.firstChild);\n          b && k.appendChild(p.createTextNode(b));\n        },\n            l = function (g, p) {\n          p = p || g;\n          if (\"undefined\" === typeof B[p]) if (k.getSubStringLength) try {\n            B[p] = d + k.getSubStringLength(0, c ? p + 1 : p);\n          } catch (ja) {\n            \"\";\n          } else t.getSpanWidth && (n(q(a || c, g)), B[p] = d + t.getSpanWidth(b, k));\n          return B[p];\n        },\n            e;\n\n        b.rotation = 0;\n        var w = l(k.textContent.length);\n\n        if (e = d + w > g) {\n          for (; u <= A;) r = Math.ceil((u + A) / 2), c && (R = q(c, r)), w = l(r, R && R.length - 1), u === A ? u = A + 1 : w > g ? A = r - 1 : u = r;\n\n          0 === A ? n(\"\") : a && A === a.length - 1 || n(R || q(a || c, r));\n        }\n\n        c && c.splice(0, r);\n        b.actualWidth = w;\n        b.rotation = H;\n        return e;\n      };\n\n      u.prototype.buildText = function (b) {\n        var k = b.element,\n            a = this,\n            c = a.forExport,\n            g = r(b.textStr, \"\").toString(),\n            q = -1 !== g.indexOf(\"<\"),\n            u = k.childNodes,\n            A,\n            B = K(k, \"x\"),\n            n = b.styles,\n            e = b.textWidth,\n            G = n && n.lineHeight,\n            f = n && n.textOutline,\n            V = n && \"ellipsis\" === n.textOverflow,\n            E = n && \"nowrap\" === n.whiteSpace,\n            h = n && n.fontSize,\n            v,\n            D = u.length;\n        n = e && !b.added && this.box;\n\n        var O = function (b) {\n          var t;\n          a.styledMode || (t = /(px|em)$/.test(b && b.style.fontSize) ? b.style.fontSize : h || a.style.fontSize || 12);\n          return G ? d(G) : a.fontMetrics(t, b.getAttribute(\"style\") ? b : k).h;\n        },\n            J = function (b, k) {\n          w(a.escapes, function (a, t) {\n            k && -1 !== k.indexOf(a) || (b = b.toString().replace(new RegExp(a, \"g\"), t));\n          });\n          return b;\n        },\n            x = function (b, k) {\n          var a = b.indexOf(\"<\");\n          b = b.substring(a, b.indexOf(\">\") - a);\n          a = b.indexOf(k + \"=\");\n          if (-1 !== a && (a = a + k.length + 1, k = b.charAt(a), '\"' === k || \"'\" === k)) return b = b.substring(a + 1), b.substring(0, b.indexOf(k));\n        },\n            I = /<br.*?>/g;\n\n        var m = [g, V, E, G, f, h, e].join();\n\n        if (m !== b.textCache) {\n          for (b.textCache = m; D--;) k.removeChild(u[D]);\n\n          q || f || V || e || -1 !== g.indexOf(\" \") && (!E || I.test(g)) ? (n && n.appendChild(k), q ? (g = a.styledMode ? g.replace(/<(b|strong)>/g, '<span class=\"highcharts-strong\">').replace(/<(i|em)>/g, '<span class=\"highcharts-emphasized\">') : g.replace(/<(b|strong)>/g, '<span style=\"font-weight:bold\">').replace(/<(i|em)>/g, '<span style=\"font-style:italic\">'), g = g.replace(/<a/g, \"<span\").replace(/<\\/(b|strong|i|em|a)>/g, \"</span>\").split(I)) : g = [g], g = g.filter(function (b) {\n            return \"\" !== b;\n          }), g.forEach(function (t, d) {\n            var g = 0,\n                H = 0;\n            t = t.replace(/^\\s+|\\s+$/g, \"\").replace(/<span/g, \"|||<span\").replace(/<\\/span>/g, \"</span>|||\");\n            var q = t.split(\"|||\");\n            q.forEach(function (t) {\n              if (\"\" !== t || 1 === q.length) {\n                var R = {},\n                    u = p.createElementNS(a.SVG_NS, \"tspan\"),\n                    n,\n                    r;\n                (n = x(t, \"class\")) && K(u, \"class\", n);\n                if (n = x(t, \"style\")) n = n.replace(/(;| |^)color([ :])/, \"$1fill$2\"), K(u, \"style\", n);\n\n                if ((r = x(t, \"href\")) && !c && -1 === r.split(\":\")[0].toLowerCase().indexOf(\"javascript\")) {\n                  var l = p.createElementNS(a.SVG_NS, \"a\");\n                  K(l, \"href\", r);\n                  K(u, \"class\", \"highcharts-anchor\");\n                  l.appendChild(u);\n                  a.styledMode || y(u, {\n                    cursor: \"pointer\"\n                  });\n                }\n\n                t = J(t.replace(/<[a-zA-Z\\/](.|\\n)*?>/g, \"\") || \" \");\n\n                if (\" \" !== t) {\n                  u.appendChild(p.createTextNode(t));\n                  g ? R.dx = 0 : d && null !== B && (R.x = B);\n                  K(u, R);\n                  k.appendChild(l || u);\n                  !g && v && (!M && c && y(u, {\n                    display: \"block\"\n                  }), K(u, \"dy\", O(u)));\n\n                  if (e) {\n                    var w = t.replace(/([^\\^])-/g, \"$1- \").split(\" \");\n                    R = !E && (1 < q.length || d || 1 < w.length);\n                    l = 0;\n                    r = O(u);\n                    if (V) A = a.truncate(b, u, t, void 0, 0, Math.max(0, e - parseInt(h || 12, 10)), function (b, k) {\n                      return b.substring(0, k) + \"\\u2026\";\n                    });else if (R) for (; w.length;) w.length && !E && 0 < l && (u = p.createElementNS(T, \"tspan\"), K(u, {\n                      dy: r,\n                      x: B\n                    }), n && K(u, \"style\", n), u.appendChild(p.createTextNode(w.join(\" \").replace(/- /g, \"-\"))), k.appendChild(u)), a.truncate(b, u, null, w, 0 === l ? H : 0, e, function (b, k) {\n                      return w.slice(0, k).join(\" \").replace(/- /g, \"-\");\n                    }), H = b.actualWidth, l++;\n                  }\n\n                  g++;\n                }\n              }\n            });\n            v = v || k.childNodes.length;\n          }), V && A && b.attr(\"title\", J(b.textStr || \"\", [\"&lt;\", \"&gt;\"])), n && n.removeChild(k), l(f) && b.applyTextOutline && b.applyTextOutline(f)) : k.appendChild(p.createTextNode(J(g)));\n        }\n      };\n\n      u.prototype.getContrast = function (b) {\n        b = f.parse(b).rgba;\n        b[0] *= 1;\n        b[1] *= 1.2;\n        b[2] *= .5;\n        return 459 < b[0] + b[1] + b[2] ? \"#000000\" : \"#FFFFFF\";\n      };\n\n      u.prototype.button = function (b, k, a, c, d, g, p, q, u, n) {\n        var t = this.label(b, k, a, u, void 0, void 0, n, void 0, \"button\"),\n            H = 0,\n            R = this.styledMode;\n        b = (d = d ? J(d) : d) && d.style || {};\n        d && d.style && delete d.style;\n        t.attr(J({\n          padding: 8,\n          r: 2\n        }, d));\n\n        if (!R) {\n          d = J({\n            fill: \"#f7f7f7\",\n            stroke: \"#cccccc\",\n            \"stroke-width\": 1,\n            style: {\n              color: \"#333333\",\n              cursor: \"pointer\",\n              fontWeight: \"normal\"\n            }\n          }, {\n            style: b\n          }, d);\n          var r = d.style;\n          delete d.style;\n          g = J(d, {\n            fill: \"#e6e6e6\"\n          }, g);\n          var B = g.style;\n          delete g.style;\n          p = J(d, {\n            fill: \"#e6ebf5\",\n            style: {\n              color: \"#000000\",\n              fontWeight: \"bold\"\n            }\n          }, p);\n          var l = p.style;\n          delete p.style;\n          q = J(d, {\n            style: {\n              color: \"#cccccc\"\n            }\n          }, q);\n          var e = q.style;\n          delete q.style;\n        }\n\n        P(t.element, A ? \"mouseover\" : \"mouseenter\", function () {\n          3 !== H && t.setState(1);\n        });\n        P(t.element, A ? \"mouseout\" : \"mouseleave\", function () {\n          3 !== H && t.setState(H);\n        });\n\n        t.setState = function (b) {\n          1 !== b && (t.state = H = b);\n          t.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass(\"highcharts-button-\" + [\"normal\", \"hover\", \"pressed\", \"disabled\"][b || 0]);\n          R || t.attr([d, g, p, q][b || 0]).css([r, B, l, e][b || 0]);\n        };\n\n        R || t.attr(d).css(v({\n          cursor: \"default\"\n        }, r));\n        return t.on(\"click\", function (b) {\n          3 !== H && c.call(t, b);\n        });\n      };\n\n      u.prototype.crispLine = function (b, k, a) {\n        void 0 === a && (a = \"round\");\n        var t = b[0],\n            c = b[1];\n        t[1] === c[1] && (t[1] = c[1] = Math[a](t[1]) - k % 2 / 2);\n        t[2] === c[2] && (t[2] = c[2] = Math[a](t[2]) + k % 2 / 2);\n        return b;\n      };\n\n      u.prototype.path = function (b) {\n        var k = this.styledMode ? {} : {\n          fill: \"none\"\n        };\n        x(b) ? k.d = b : n(b) && v(k, b);\n        return this.createElement(\"path\").attr(k);\n      };\n\n      u.prototype.circle = function (b, k, a) {\n        b = n(b) ? b : \"undefined\" === typeof b ? {} : {\n          x: b,\n          y: k,\n          r: a\n        };\n        k = this.createElement(\"circle\");\n\n        k.xSetter = k.ySetter = function (b, k, a) {\n          a.setAttribute(\"c\" + k, b);\n        };\n\n        return k.attr(b);\n      };\n\n      u.prototype.arc = function (b, k, a, c, d, g) {\n        n(b) ? (c = b, k = c.y, a = c.r, b = c.x) : c = {\n          innerR: c,\n          start: d,\n          end: g\n        };\n        b = this.symbol(\"arc\", b, k, a, a, c);\n        b.r = a;\n        return b;\n      };\n\n      u.prototype.rect = function (b, k, a, c, d, g) {\n        d = n(b) ? b.r : d;\n        var t = this.createElement(\"rect\");\n        b = n(b) ? b : \"undefined\" === typeof b ? {} : {\n          x: b,\n          y: k,\n          width: Math.max(a, 0),\n          height: Math.max(c, 0)\n        };\n        this.styledMode || (\"undefined\" !== typeof g && (b.strokeWidth = g, b = t.crisp(b)), b.fill = \"none\");\n        d && (b.r = d);\n\n        t.rSetter = function (b, k, a) {\n          t.r = b;\n          K(a, {\n            rx: b,\n            ry: b\n          });\n        };\n\n        t.rGetter = function () {\n          return t.r;\n        };\n\n        return t.attr(b);\n      };\n\n      u.prototype.setSize = function (b, k, a) {\n        var t = this.alignedObjects,\n            c = t.length;\n        this.width = b;\n        this.height = k;\n\n        for (this.boxWrapper.animate({\n          width: b,\n          height: k\n        }, {\n          step: function () {\n            this.attr({\n              viewBox: \"0 0 \" + this.attr(\"width\") + \" \" + this.attr(\"height\")\n            });\n          },\n          duration: r(a, !0) ? void 0 : 0\n        }); c--;) t[c].align();\n      };\n\n      u.prototype.g = function (b) {\n        var k = this.createElement(\"g\");\n        return b ? k.attr({\n          \"class\": \"highcharts-\" + b\n        }) : k;\n      };\n\n      u.prototype.image = function (b, k, a, c, d, g) {\n        var t = {\n          preserveAspectRatio: \"none\"\n        },\n            p = function (b, k) {\n          b.setAttributeNS ? b.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", k) : b.setAttribute(\"hc-svg-href\", k);\n        },\n            q = function (k) {\n          p(H.element, b);\n          g.call(H, k);\n        };\n\n        1 < arguments.length && v(t, {\n          x: k,\n          y: a,\n          width: c,\n          height: d\n        });\n        var H = this.createElement(\"image\").attr(t);\n        g ? (p(H.element, \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"), t = new O.Image(), P(t, \"load\", q), t.src = b, t.complete && q({})) : p(H.element, b);\n        return H;\n      };\n\n      u.prototype.symbol = function (b, k, t, c, d, g) {\n        var q = this,\n            H = /^url\\((.*?)\\)$/,\n            u = H.test(b),\n            R = !u && (this.symbols[b] ? b : \"circle\"),\n            n = R && this.symbols[R],\n            A;\n\n        if (n) {\n          \"number\" === typeof k && (A = n.call(this.symbols, Math.round(k || 0), Math.round(t || 0), c || 0, d || 0, g));\n          var B = this.path(A);\n          q.styledMode || B.attr(\"fill\", \"none\");\n          v(B, {\n            symbolName: R,\n            x: k,\n            y: t,\n            width: c,\n            height: d\n          });\n          g && v(B, g);\n        } else if (u) {\n          var l = b.match(H)[1];\n          B = this.image(l);\n          B.imgwidth = r(Q[l] && Q[l].width, g && g.width);\n          B.imgheight = r(Q[l] && Q[l].height, g && g.height);\n\n          var w = function () {\n            B.attr({\n              width: B.width,\n              height: B.height\n            });\n          };\n\n          [\"width\", \"height\"].forEach(function (b) {\n            B[b + \"Setter\"] = function (b, k) {\n              var a = {},\n                  t = this[\"img\" + k],\n                  c = \"width\" === k ? \"translateX\" : \"translateY\";\n              this[k] = b;\n              e(t) && (g && \"within\" === g.backgroundSize && this.width && this.height && (t = Math.round(t * Math.min(this.width / this.imgwidth, this.height / this.imgheight))), this.element && this.element.setAttribute(k, t), this.alignByTranslate || (a[c] = ((this[k] || 0) - t) / 2, this.attr(a)));\n            };\n          });\n          e(k) && B.attr({\n            x: k,\n            y: t\n          });\n          B.isImg = !0;\n          e(B.imgwidth) && e(B.imgheight) ? w() : (B.attr({\n            width: 0,\n            height: 0\n          }), C(\"img\", {\n            onload: function () {\n              var b = a[q.chartIndex];\n              0 === this.width && (y(this, {\n                position: \"absolute\",\n                top: \"-999em\"\n              }), p.body.appendChild(this));\n              Q[l] = {\n                width: this.width,\n                height: this.height\n              };\n              B.imgwidth = this.width;\n              B.imgheight = this.height;\n              B.element && w();\n              this.parentNode && this.parentNode.removeChild(this);\n              q.imgCount--;\n              if (!q.imgCount && b && !b.hasLoaded) b.onload();\n            },\n            src: l\n          }), this.imgCount++);\n        }\n\n        return B;\n      };\n\n      u.prototype.clipRect = function (b, k, a, d) {\n        var t = c() + \"-\",\n            g = this.createElement(\"clipPath\").attr({\n          id: t\n        }).add(this.defs);\n        b = this.rect(b, k, a, d, 0).add(g);\n        b.id = t;\n        b.clipPath = g;\n        b.count = 0;\n        return b;\n      };\n\n      u.prototype.text = function (b, k, a, c) {\n        var t = {};\n        if (c && (this.allowHTML || !this.forExport)) return this.html(b, k, a);\n        t.x = Math.round(k || 0);\n        a && (t.y = Math.round(a));\n        e(b) && (t.text = b);\n        b = this.createElement(\"text\").attr(t);\n        c || (b.xSetter = function (b, k, a) {\n          var t = a.getElementsByTagName(\"tspan\"),\n              c = a.getAttribute(k),\n              d;\n\n          for (d = 0; d < t.length; d++) {\n            var g = t[d];\n            g.getAttribute(k) === c && g.setAttribute(k, b);\n          }\n\n          a.setAttribute(k, b);\n        });\n        return b;\n      };\n\n      u.prototype.fontMetrics = function (b, k) {\n        b = !this.styledMode && /px/.test(b) || !O.getComputedStyle ? b || k && k.style && k.style.fontSize || this.style && this.style.fontSize : k && m.prototype.getStyle.call(k, \"font-size\");\n        b = /px/.test(b) ? d(b) : 12;\n        k = 24 > b ? b + 3 : Math.round(1.2 * b);\n        return {\n          h: k,\n          b: Math.round(.8 * k),\n          f: b\n        };\n      };\n\n      u.prototype.rotCorr = function (b, k, a) {\n        var t = b;\n        k && a && (t = Math.max(t * Math.cos(k * q), 4));\n        return {\n          x: -b / 3 * Math.sin(k * q),\n          y: t\n        };\n      };\n\n      u.prototype.pathToSegments = function (b) {\n        for (var k = [], a = [], c = {\n          A: 8,\n          C: 7,\n          H: 2,\n          L: 3,\n          M: 3,\n          Q: 5,\n          S: 5,\n          T: 3,\n          V: 2\n        }, d = 0; d < b.length; d++) l(a[0]) && D(b[d]) && a.length === c[a[0].toUpperCase()] && b.splice(d, 0, a[0].replace(\"M\", \"L\").replace(\"m\", \"l\")), \"string\" === typeof b[d] && (a.length && k.push(a.slice(0)), a.length = 0), a.push(b[d]);\n\n        k.push(a.slice(0));\n        return k;\n      };\n\n      u.prototype.label = function (b, k, a, c, d, g, p, q, u) {\n        return new z(this, b, k, a, c, d, g, p, q, u);\n      };\n\n      return u;\n    }();\n\n    E.prototype.Element = m;\n    E.prototype.SVG_NS = T;\n    E.prototype.draw = F;\n    E.prototype.escapes = {\n      \"&\": \"&amp;\",\n      \"<\": \"&lt;\",\n      \">\": \"&gt;\",\n      \"'\": \"&#39;\",\n      '\"': \"&quot;\"\n    };\n    E.prototype.symbols = {\n      circle: function (a, b, k, t) {\n        return this.arc(a + k / 2, b + t / 2, k / 2, t / 2, {\n          start: .5 * Math.PI,\n          end: 2.5 * Math.PI,\n          open: !1\n        });\n      },\n      square: function (a, b, k, t) {\n        return [[\"M\", a, b], [\"L\", a + k, b], [\"L\", a + k, b + t], [\"L\", a, b + t], [\"Z\"]];\n      },\n      triangle: function (a, b, k, t) {\n        return [[\"M\", a + k / 2, b], [\"L\", a + k, b + t], [\"L\", a, b + t], [\"Z\"]];\n      },\n      \"triangle-down\": function (a, b, k, t) {\n        return [[\"M\", a, b], [\"L\", a + k, b], [\"L\", a + k / 2, b + t], [\"Z\"]];\n      },\n      diamond: function (a, b, k, t) {\n        return [[\"M\", a + k / 2, b], [\"L\", a + k, b + t / 2], [\"L\", a + k / 2, b + t], [\"L\", a, b + t / 2], [\"Z\"]];\n      },\n      arc: function (a, b, k, t, c) {\n        var d = [];\n\n        if (c) {\n          var g = c.start || 0,\n              p = c.end || 0,\n              q = c.r || k;\n          k = c.r || t || k;\n          var H = .001 > Math.abs(p - g - 2 * Math.PI);\n          p -= .001;\n          t = c.innerR;\n          H = r(c.open, H);\n          var u = Math.cos(g),\n              B = Math.sin(g),\n              n = Math.cos(p),\n              A = Math.sin(p);\n          g = r(c.longArc, .001 > p - g - Math.PI ? 0 : 1);\n          d.push([\"M\", a + q * u, b + k * B], [\"A\", q, k, 0, g, r(c.clockwise, 1), a + q * n, b + k * A]);\n          e(t) && d.push(H ? [\"M\", a + t * n, b + t * A] : [\"L\", a + t * n, b + t * A], [\"A\", t, t, 0, g, e(c.clockwise) ? 1 - c.clockwise : 0, a + t * u, b + t * B]);\n          H || d.push([\"Z\"]);\n        }\n\n        return d;\n      },\n      callout: function (a, b, k, t, c) {\n        var d = Math.min(c && c.r || 0, k, t),\n            g = d + 6,\n            p = c && c.anchorX || 0;\n        c = c && c.anchorY || 0;\n        var q = [[\"M\", a + d, b], [\"L\", a + k - d, b], [\"C\", a + k, b, a + k, b, a + k, b + d], [\"L\", a + k, b + t - d], [\"C\", a + k, b + t, a + k, b + t, a + k - d, b + t], [\"L\", a + d, b + t], [\"C\", a, b + t, a, b + t, a, b + t - d], [\"L\", a, b + d], [\"C\", a, b, a, b, a + d, b]];\n        p && p > k ? c > b + g && c < b + t - g ? q.splice(3, 1, [\"L\", a + k, c - 6], [\"L\", a + k + 6, c], [\"L\", a + k, c + 6], [\"L\", a + k, b + t - d]) : q.splice(3, 1, [\"L\", a + k, t / 2], [\"L\", p, c], [\"L\", a + k, t / 2], [\"L\", a + k, b + t - d]) : p && 0 > p ? c > b + g && c < b + t - g ? q.splice(7, 1, [\"L\", a, c + 6], [\"L\", a - 6, c], [\"L\", a, c - 6], [\"L\", a, b + d]) : q.splice(7, 1, [\"L\", a, t / 2], [\"L\", p, c], [\"L\", a, t / 2], [\"L\", a, b + d]) : c && c > t && p > a + g && p < a + k - g ? q.splice(5, 1, [\"L\", p + 6, b + t], [\"L\", p, b + t + 6], [\"L\", p - 6, b + t], [\"L\", a + d, b + t]) : c && 0 > c && p > a + g && p < a + k - g && q.splice(1, 1, [\"L\", p - 6, b], [\"L\", p, b - 6], [\"L\", p + 6, b], [\"L\", k - d, b]);\n        return q;\n      }\n    };\n    h.SVGRenderer = E;\n    h.Renderer = h.SVGRenderer;\n    return h.Renderer;\n  });\n  N(m, \"Core/Renderer/HTML/HTMLElement.js\", [m[\"Core/Globals.js\"], m[\"Core/Renderer/SVG/SVGElement.js\"], m[\"Core/Utilities.js\"]], function (f, h, m) {\n    var z = m.css,\n        F = m.defined,\n        P = m.extend,\n        K = m.pick,\n        C = m.pInt,\n        y = f.isFirefox;\n    P(h.prototype, {\n      htmlCss: function (e) {\n        var f = \"SPAN\" === this.element.tagName && e && \"width\" in e,\n            h = K(f && e.width, void 0);\n\n        if (f) {\n          delete e.width;\n          this.textWidth = h;\n          var x = !0;\n        }\n\n        e && \"ellipsis\" === e.textOverflow && (e.whiteSpace = \"nowrap\", e.overflow = \"hidden\");\n        this.styles = P(this.styles, e);\n        z(this.element, e);\n        x && this.htmlUpdateTransform();\n        return this;\n      },\n      htmlGetBBox: function () {\n        var e = this.element;\n        return {\n          x: e.offsetLeft,\n          y: e.offsetTop,\n          width: e.offsetWidth,\n          height: e.offsetHeight\n        };\n      },\n      htmlUpdateTransform: function () {\n        if (this.added) {\n          var e = this.renderer,\n              f = this.element,\n              h = this.translateX || 0,\n              x = this.translateY || 0,\n              D = this.x || 0,\n              n = this.y || 0,\n              l = this.textAlign || \"left\",\n              J = {\n            left: 0,\n            center: .5,\n            right: 1\n          }[l],\n              w = this.styles,\n              r = w && w.whiteSpace;\n          z(f, {\n            marginLeft: h,\n            marginTop: x\n          });\n          !e.styledMode && this.shadows && this.shadows.forEach(function (a) {\n            z(a, {\n              marginLeft: h + 1,\n              marginTop: x + 1\n            });\n          });\n          this.inverted && [].forEach.call(f.childNodes, function (a) {\n            e.invertChild(a, f);\n          });\n\n          if (\"SPAN\" === f.tagName) {\n            w = this.rotation;\n            var d = this.textWidth && C(this.textWidth),\n                g = [w, l, f.innerHTML, this.textWidth, this.textAlign].join(),\n                c;\n            (c = d !== this.oldTextWidth) && !(c = d > this.oldTextWidth) && ((c = this.textPxLength) || (z(f, {\n              width: \"\",\n              whiteSpace: r || \"nowrap\"\n            }), c = f.offsetWidth), c = c > d);\n            c && (/[ \\-]/.test(f.textContent || f.innerText) || \"ellipsis\" === f.style.textOverflow) ? (z(f, {\n              width: d + \"px\",\n              display: \"block\",\n              whiteSpace: r || \"normal\"\n            }), this.oldTextWidth = d, this.hasBoxWidthChanged = !0) : this.hasBoxWidthChanged = !1;\n            g !== this.cTT && (r = e.fontMetrics(f.style.fontSize, f).b, !F(w) || w === (this.oldRotation || 0) && l === this.oldAlign || this.setSpanRotation(w, J, r), this.getSpanCorrection(!F(w) && this.textPxLength || f.offsetWidth, r, J, w, l));\n            z(f, {\n              left: D + (this.xCorr || 0) + \"px\",\n              top: n + (this.yCorr || 0) + \"px\"\n            });\n            this.cTT = g;\n            this.oldRotation = w;\n            this.oldAlign = l;\n          }\n        } else this.alignOnAdd = !0;\n      },\n      setSpanRotation: function (e, f, h) {\n        var v = {},\n            D = this.renderer.getTransformKey();\n        v[D] = v.transform = \"rotate(\" + e + \"deg)\";\n        v[D + (y ? \"Origin\" : \"-origin\")] = v.transformOrigin = 100 * f + \"% \" + h + \"px\";\n        z(this.element, v);\n      },\n      getSpanCorrection: function (e, f, h) {\n        this.xCorr = -e * h;\n        this.yCorr = -f;\n      }\n    });\n    return h;\n  });\n  N(m, \"Core/Renderer/HTML/HTMLRenderer.js\", [m[\"Core/Globals.js\"], m[\"Core/Renderer/SVG/SVGElement.js\"], m[\"Core/Renderer/SVG/SVGRenderer.js\"], m[\"Core/Utilities.js\"]], function (f, h, m, z) {\n    var F = f.isFirefox,\n        P = f.isMS,\n        K = f.isWebKit,\n        C = f.win,\n        y = z.attr,\n        e = z.createElement,\n        I = z.extend,\n        v = z.pick;\n    I(m.prototype, {\n      getTransformKey: function () {\n        return P && !/Edge/.test(C.navigator.userAgent) ? \"-ms-transform\" : K ? \"-webkit-transform\" : F ? \"MozTransform\" : C.opera ? \"-o-transform\" : \"\";\n      },\n      html: function (f, D, n) {\n        var l = this.createElement(\"span\"),\n            J = l.element,\n            w = l.renderer,\n            r = w.isSVG,\n            d = function (d, c) {\n          [\"opacity\", \"visibility\"].forEach(function (a) {\n            d[a + \"Setter\"] = function (g, p, B) {\n              var q = d.div ? d.div.style : c;\n              h.prototype[a + \"Setter\"].call(this, g, p, B);\n              q && (q[p] = g);\n            };\n          });\n          d.addedSetters = !0;\n        };\n\n        l.textSetter = function (d) {\n          d !== J.innerHTML && (delete this.bBox, delete this.oldTextWidth);\n          this.textStr = d;\n          J.innerHTML = v(d, \"\");\n          l.doTransform = !0;\n        };\n\n        r && d(l, l.element.style);\n\n        l.xSetter = l.ySetter = l.alignSetter = l.rotationSetter = function (d, c) {\n          \"align\" === c ? l.alignValue = l.textAlign = d : l[c] = d;\n          l.doTransform = !0;\n        };\n\n        l.afterSetters = function () {\n          this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);\n        };\n\n        l.attr({\n          text: f,\n          x: Math.round(D),\n          y: Math.round(n)\n        }).css({\n          position: \"absolute\"\n        });\n        w.styledMode || l.css({\n          fontFamily: this.style.fontFamily,\n          fontSize: this.style.fontSize\n        });\n        J.style.whiteSpace = \"nowrap\";\n        l.css = l.htmlCss;\n        r && (l.add = function (g) {\n          var c = w.box.parentNode,\n              a = [];\n\n          if (this.parentGroup = g) {\n            var q = g.div;\n\n            if (!q) {\n              for (; g;) a.push(g), g = g.parentGroup;\n\n              a.reverse().forEach(function (g) {\n                function p(a, c) {\n                  g[c] = a;\n                  \"translateX\" === c ? r.left = a + \"px\" : r.top = a + \"px\";\n                  g.doTransform = !0;\n                }\n\n                var n = y(g.element, \"class\");\n                q = g.div = g.div || e(\"div\", n ? {\n                  className: n\n                } : void 0, {\n                  position: \"absolute\",\n                  left: (g.translateX || 0) + \"px\",\n                  top: (g.translateY || 0) + \"px\",\n                  display: g.display,\n                  opacity: g.opacity,\n                  pointerEvents: g.styles && g.styles.pointerEvents\n                }, q || c);\n                var r = q.style;\n                I(g, {\n                  classSetter: function (a) {\n                    return function (c) {\n                      this.element.setAttribute(\"class\", c);\n                      a.className = c;\n                    };\n                  }(q),\n                  on: function () {\n                    a[0].div && l.on.apply({\n                      element: a[0].div\n                    }, arguments);\n                    return g;\n                  },\n                  translateXSetter: p,\n                  translateYSetter: p\n                });\n                g.addedSetters || d(g);\n              });\n            }\n          } else q = c;\n\n          q.appendChild(J);\n          l.added = !0;\n          l.alignOnAdd && l.htmlUpdateTransform();\n          return l;\n        });\n        return l;\n      }\n    });\n    return m;\n  });\n  N(m, \"Core/Axis/Tick.js\", [m[\"Core/Globals.js\"], m[\"Core/Utilities.js\"]], function (f, h) {\n    var m = h.clamp,\n        z = h.correctFloat,\n        F = h.defined,\n        L = h.destroyObjectProperties,\n        K = h.extend,\n        C = h.fireEvent,\n        y = h.isNumber,\n        e = h.merge,\n        I = h.objectEach,\n        v = h.pick,\n        x = f.deg2rad;\n\n    h = function () {\n      function f(n, l, e, w, r) {\n        this.isNewLabel = this.isNew = !0;\n        this.axis = n;\n        this.pos = l;\n        this.type = e || \"\";\n        this.parameters = r || {};\n        this.tickmarkOffset = this.parameters.tickmarkOffset;\n        this.options = this.parameters.options;\n        C(this, \"init\");\n        e || w || this.addLabel();\n      }\n\n      f.prototype.addLabel = function () {\n        var n = this,\n            l = n.axis,\n            e = l.options,\n            w = l.chart,\n            r = l.categories,\n            d = l.logarithmic,\n            g = l.names,\n            c = n.pos,\n            a = v(n.options && n.options.labels, e.labels),\n            q = l.tickPositions,\n            p = c === q[0],\n            B = c === q[q.length - 1];\n        g = this.parameters.category || (r ? v(r[c], g[c], c) : c);\n        var A = n.label;\n        r = (!a.step || 1 === a.step) && 1 === l.tickInterval;\n        q = q.info;\n        var f, h;\n\n        if (l.dateTime && q) {\n          var D = w.time.resolveDTLFormat(e.dateTimeLabelFormats[!e.grid && q.higherRanks[c] || q.unitName]);\n          var x = D.main;\n        }\n\n        n.isFirst = p;\n        n.isLast = B;\n        n.formatCtx = {\n          axis: l,\n          chart: w,\n          isFirst: p,\n          isLast: B,\n          dateTimeLabelFormat: x,\n          tickPositionInfo: q,\n          value: d ? z(d.lin2log(g)) : g,\n          pos: c\n        };\n        e = l.labelFormatter.call(n.formatCtx, this.formatCtx);\n        if (h = D && D.list) n.shortenLabel = function () {\n          for (f = 0; f < h.length; f++) if (A.attr({\n            text: l.labelFormatter.call(K(n.formatCtx, {\n              dateTimeLabelFormat: h[f]\n            }))\n          }), A.getBBox().width < l.getSlotWidth(n) - 2 * v(a.padding, 5)) return;\n\n          A.attr({\n            text: \"\"\n          });\n        };\n        r && l._addedPlotLB && n.moveLabel(e, a);\n        F(A) || n.movedLabel ? A && A.textStr !== e && !r && (!A.textWidth || a.style && a.style.width || A.styles.width || A.css({\n          width: null\n        }), A.attr({\n          text: e\n        }), A.textPxLength = A.getBBox().width) : (n.label = A = n.createLabel({\n          x: 0,\n          y: 0\n        }, e, a), n.rotation = 0);\n      };\n\n      f.prototype.createLabel = function (n, l, f) {\n        var w = this.axis,\n            r = w.chart;\n        if (n = F(l) && f.enabled ? r.renderer.text(l, n.x, n.y, f.useHTML).add(w.labelGroup) : null) r.styledMode || n.css(e(f.style)), n.textPxLength = n.getBBox().width;\n        return n;\n      };\n\n      f.prototype.destroy = function () {\n        L(this, this.axis);\n      };\n\n      f.prototype.getPosition = function (n, l, e, w) {\n        var r = this.axis,\n            d = r.chart,\n            g = w && d.oldChartHeight || d.chartHeight;\n        n = {\n          x: n ? z(r.translate(l + e, null, null, w) + r.transB) : r.left + r.offset + (r.opposite ? (w && d.oldChartWidth || d.chartWidth) - r.right - r.left : 0),\n          y: n ? g - r.bottom + r.offset - (r.opposite ? r.height : 0) : z(g - r.translate(l + e, null, null, w) - r.transB)\n        };\n        n.y = m(n.y, -1E5, 1E5);\n        C(this, \"afterGetPosition\", {\n          pos: n\n        });\n        return n;\n      };\n\n      f.prototype.getLabelPosition = function (n, l, e, w, r, d, g, c) {\n        var a = this.axis,\n            q = a.transA,\n            p = a.isLinked && a.linkedParent ? a.linkedParent.reversed : a.reversed,\n            B = a.staggerLines,\n            A = a.tickRotCorr || {\n          x: 0,\n          y: 0\n        },\n            f = r.y,\n            h = w || a.reserveSpaceDefault ? 0 : -a.labelOffset * (\"center\" === a.labelAlign ? .5 : 1),\n            v = {};\n        F(f) || (f = 0 === a.side ? e.rotation ? -8 : -e.getBBox().height : 2 === a.side ? A.y + 8 : Math.cos(e.rotation * x) * (A.y - e.getBBox(!1, 0).height / 2));\n        n = n + r.x + h + A.x - (d && w ? d * q * (p ? -1 : 1) : 0);\n        l = l + f - (d && !w ? d * q * (p ? 1 : -1) : 0);\n        B && (e = g / (c || 1) % B, a.opposite && (e = B - e - 1), l += a.labelOffset / B * e);\n        v.x = n;\n        v.y = Math.round(l);\n        C(this, \"afterGetLabelPosition\", {\n          pos: v,\n          tickmarkOffset: d,\n          index: g\n        });\n        return v;\n      };\n\n      f.prototype.getLabelSize = function () {\n        return this.label ? this.label.getBBox()[this.axis.horiz ? \"height\" : \"width\"] : 0;\n      };\n\n      f.prototype.getMarkPath = function (n, e, f, w, r, d) {\n        return d.crispLine([[\"M\", n, e], [\"L\", n + (r ? 0 : -f), e + (r ? f : 0)]], w);\n      };\n\n      f.prototype.handleOverflow = function (n) {\n        var e = this.axis,\n            f = e.options.labels,\n            w = n.x,\n            r = e.chart.chartWidth,\n            d = e.chart.spacing,\n            g = v(e.labelLeft, Math.min(e.pos, d[3]));\n        d = v(e.labelRight, Math.max(e.isRadial ? 0 : e.pos + e.len, r - d[1]));\n        var c = this.label,\n            a = this.rotation,\n            q = {\n          left: 0,\n          center: .5,\n          right: 1\n        }[e.labelAlign || c.attr(\"align\")],\n            p = c.getBBox().width,\n            B = e.getSlotWidth(this),\n            A = B,\n            G = 1,\n            h,\n            D = {};\n        if (a || \"justify\" !== v(f.overflow, \"justify\")) 0 > a && w - q * p < g ? h = Math.round(w / Math.cos(a * x) - g) : 0 < a && w + q * p > d && (h = Math.round((r - w) / Math.cos(a * x)));else if (r = w + (1 - q) * p, w - q * p < g ? A = n.x + A * (1 - q) - g : r > d && (A = d - n.x + A * q, G = -1), A = Math.min(B, A), A < B && \"center\" === e.labelAlign && (n.x += G * (B - A - q * (B - Math.min(p, A)))), p > A || e.autoRotation && (c.styles || {}).width) h = A;\n        h && (this.shortenLabel ? this.shortenLabel() : (D.width = Math.floor(h) + \"px\", (f.style || {}).textOverflow || (D.textOverflow = \"ellipsis\"), c.css(D)));\n      };\n\n      f.prototype.moveLabel = function (n, e) {\n        var l = this,\n            w = l.label,\n            r = !1,\n            d = l.axis,\n            g = d.reversed;\n        w && w.textStr === n ? (l.movedLabel = w, r = !0, delete l.label) : I(d.ticks, function (a) {\n          r || a.isNew || a === l || !a.label || a.label.textStr !== n || (l.movedLabel = a.label, r = !0, a.labelPos = l.movedLabel.xy, delete a.label);\n        });\n\n        if (!r && (l.labelPos || w)) {\n          var c = l.labelPos || w.xy;\n          w = d.horiz ? g ? 0 : d.width + d.left : c.x;\n          d = d.horiz ? c.y : g ? d.width + d.left : 0;\n          l.movedLabel = l.createLabel({\n            x: w,\n            y: d\n          }, n, e);\n          l.movedLabel && l.movedLabel.attr({\n            opacity: 0\n          });\n        }\n      };\n\n      f.prototype.render = function (e, l, f) {\n        var n = this.axis,\n            r = n.horiz,\n            d = this.pos,\n            g = v(this.tickmarkOffset, n.tickmarkOffset);\n        d = this.getPosition(r, d, g, l);\n        g = d.x;\n        var c = d.y;\n        n = r && g === n.pos + n.len || !r && c === n.pos ? -1 : 1;\n        f = v(f, 1);\n        this.isActive = !0;\n        this.renderGridLine(l, f, n);\n        this.renderMark(d, f, n);\n        this.renderLabel(d, l, f, e);\n        this.isNew = !1;\n        C(this, \"afterRender\");\n      };\n\n      f.prototype.renderGridLine = function (n, e, f) {\n        var l = this.axis,\n            r = l.options,\n            d = this.gridLine,\n            g = {},\n            c = this.pos,\n            a = this.type,\n            q = v(this.tickmarkOffset, l.tickmarkOffset),\n            p = l.chart.renderer,\n            B = a ? a + \"Grid\" : \"grid\",\n            A = r[B + \"LineWidth\"],\n            G = r[B + \"LineColor\"];\n        r = r[B + \"LineDashStyle\"];\n        d || (l.chart.styledMode || (g.stroke = G, g[\"stroke-width\"] = A, r && (g.dashstyle = r)), a || (g.zIndex = 1), n && (e = 0), this.gridLine = d = p.path().attr(g).addClass(\"highcharts-\" + (a ? a + \"-\" : \"\") + \"grid-line\").add(l.gridGroup));\n        if (d && (f = l.getPlotLinePath({\n          value: c + q,\n          lineWidth: d.strokeWidth() * f,\n          force: \"pass\",\n          old: n\n        }))) d[n || this.isNew ? \"attr\" : \"animate\"]({\n          d: f,\n          opacity: e\n        });\n      };\n\n      f.prototype.renderMark = function (n, e, f) {\n        var l = this.axis,\n            r = l.options,\n            d = l.chart.renderer,\n            g = this.type,\n            c = g ? g + \"Tick\" : \"tick\",\n            a = l.tickSize(c),\n            q = this.mark,\n            p = !q,\n            B = n.x;\n        n = n.y;\n        var A = v(r[c + \"Width\"], !g && l.isXAxis ? 1 : 0);\n        r = r[c + \"Color\"];\n        a && (l.opposite && (a[0] = -a[0]), p && (this.mark = q = d.path().addClass(\"highcharts-\" + (g ? g + \"-\" : \"\") + \"tick\").add(l.axisGroup), l.chart.styledMode || q.attr({\n          stroke: r,\n          \"stroke-width\": A\n        })), q[p ? \"attr\" : \"animate\"]({\n          d: this.getMarkPath(B, n, a[0], q.strokeWidth() * f, l.horiz, d),\n          opacity: e\n        }));\n      };\n\n      f.prototype.renderLabel = function (e, l, f, w) {\n        var n = this.axis,\n            d = n.horiz,\n            g = n.options,\n            c = this.label,\n            a = g.labels,\n            q = a.step;\n        n = v(this.tickmarkOffset, n.tickmarkOffset);\n        var p = !0,\n            B = e.x;\n        e = e.y;\n        c && y(B) && (c.xy = e = this.getLabelPosition(B, e, c, d, a, n, w, q), this.isFirst && !this.isLast && !v(g.showFirstLabel, 1) || this.isLast && !this.isFirst && !v(g.showLastLabel, 1) ? p = !1 : !d || a.step || a.rotation || l || 0 === f || this.handleOverflow(e), q && w % q && (p = !1), p && y(e.y) ? (e.opacity = f, c[this.isNewLabel ? \"attr\" : \"animate\"](e), this.isNewLabel = !1) : (c.attr(\"y\", -9999), this.isNewLabel = !0));\n      };\n\n      f.prototype.replaceMovedLabel = function () {\n        var e = this.label,\n            l = this.axis,\n            f = l.reversed;\n\n        if (e && !this.isNew) {\n          var w = l.horiz ? f ? l.left : l.width + l.left : e.xy.x;\n          f = l.horiz ? e.xy.y : f ? l.width + l.top : l.top;\n          e.animate({\n            x: w,\n            y: f,\n            opacity: 0\n          }, void 0, e.destroy);\n          delete this.label;\n        }\n\n        l.isDirty = !0;\n        this.label = this.movedLabel;\n        delete this.movedLabel;\n      };\n\n      return f;\n    }();\n\n    f.Tick = h;\n    return f.Tick;\n  });\n  N(m, \"Core/Time.js\", [m[\"Core/Globals.js\"], m[\"Core/Utilities.js\"]], function (f, h) {\n    var m = h.defined,\n        z = h.error,\n        F = h.extend,\n        L = h.isObject,\n        K = h.merge,\n        C = h.objectEach,\n        y = h.pad,\n        e = h.pick,\n        I = h.splat,\n        v = h.timeUnits,\n        x = f.win;\n\n    h = function () {\n      function h(e) {\n        this.options = {};\n        this.variableTimezone = this.useUTC = !1;\n        this.Date = x.Date;\n        this.getTimezoneOffset = this.timezoneOffsetFunction();\n        this.update(e);\n      }\n\n      h.prototype.get = function (e, l) {\n        if (this.variableTimezone || this.timezoneOffset) {\n          var n = l.getTime(),\n              f = n - this.getTimezoneOffset(l);\n          l.setTime(f);\n          e = l[\"getUTC\" + e]();\n          l.setTime(n);\n          return e;\n        }\n\n        return this.useUTC ? l[\"getUTC\" + e]() : l[\"get\" + e]();\n      };\n\n      h.prototype.set = function (e, l, f) {\n        if (this.variableTimezone || this.timezoneOffset) {\n          if (\"Milliseconds\" === e || \"Seconds\" === e || \"Minutes\" === e) return l[\"setUTC\" + e](f);\n          var n = this.getTimezoneOffset(l);\n          n = l.getTime() - n;\n          l.setTime(n);\n          l[\"setUTC\" + e](f);\n          e = this.getTimezoneOffset(l);\n          n = l.getTime() + e;\n          return l.setTime(n);\n        }\n\n        return this.useUTC ? l[\"setUTC\" + e](f) : l[\"set\" + e](f);\n      };\n\n      h.prototype.update = function (n) {\n        var l = e(n && n.useUTC, !0);\n        this.options = n = K(!0, this.options || {}, n);\n        this.Date = n.Date || x.Date || Date;\n        this.timezoneOffset = (this.useUTC = l) && n.timezoneOffset;\n        this.getTimezoneOffset = this.timezoneOffsetFunction();\n        this.variableTimezone = !(l && !n.getTimezoneOffset && !n.timezone);\n      };\n\n      h.prototype.makeTime = function (n, l, h, w, r, d) {\n        if (this.useUTC) {\n          var g = this.Date.UTC.apply(0, arguments);\n          var c = this.getTimezoneOffset(g);\n          g += c;\n          var a = this.getTimezoneOffset(g);\n          c !== a ? g += a - c : c - 36E5 !== this.getTimezoneOffset(g - 36E5) || f.isSafari || (g -= 36E5);\n        } else g = new this.Date(n, l, e(h, 1), e(w, 0), e(r, 0), e(d, 0)).getTime();\n\n        return g;\n      };\n\n      h.prototype.timezoneOffsetFunction = function () {\n        var e = this,\n            l = this.options,\n            f = l.moment || x.moment;\n        if (!this.useUTC) return function (e) {\n          return 6E4 * new Date(e.toString()).getTimezoneOffset();\n        };\n\n        if (l.timezone) {\n          if (f) return function (e) {\n            return 6E4 * -f.tz(e, l.timezone).utcOffset();\n          };\n          z(25);\n        }\n\n        return this.useUTC && l.getTimezoneOffset ? function (e) {\n          return 6E4 * l.getTimezoneOffset(e.valueOf());\n        } : function () {\n          return 6E4 * (e.timezoneOffset || 0);\n        };\n      };\n\n      h.prototype.dateFormat = function (n, l, h) {\n        var w;\n        if (!m(l) || isNaN(l)) return (null === (w = f.defaultOptions.lang) || void 0 === w ? void 0 : w.invalidDate) || \"\";\n        n = e(n, \"%Y-%m-%d %H:%M:%S\");\n        var r = this;\n        w = new this.Date(l);\n        var d = this.get(\"Hours\", w),\n            g = this.get(\"Day\", w),\n            c = this.get(\"Date\", w),\n            a = this.get(\"Month\", w),\n            q = this.get(\"FullYear\", w),\n            p = f.defaultOptions.lang,\n            B = null === p || void 0 === p ? void 0 : p.weekdays,\n            A = null === p || void 0 === p ? void 0 : p.shortWeekdays;\n        w = F({\n          a: A ? A[g] : B[g].substr(0, 3),\n          A: B[g],\n          d: y(c),\n          e: y(c, 2, \" \"),\n          w: g,\n          b: p.shortMonths[a],\n          B: p.months[a],\n          m: y(a + 1),\n          o: a + 1,\n          y: q.toString().substr(2, 2),\n          Y: q,\n          H: y(d),\n          k: d,\n          I: y(d % 12 || 12),\n          l: d % 12 || 12,\n          M: y(this.get(\"Minutes\", w)),\n          p: 12 > d ? \"AM\" : \"PM\",\n          P: 12 > d ? \"am\" : \"pm\",\n          S: y(w.getSeconds()),\n          L: y(Math.floor(l % 1E3), 3)\n        }, f.dateFormats);\n        C(w, function (a, c) {\n          for (; -1 !== n.indexOf(\"%\" + c);) n = n.replace(\"%\" + c, \"function\" === typeof a ? a.call(r, l) : a);\n        });\n        return h ? n.substr(0, 1).toUpperCase() + n.substr(1) : n;\n      };\n\n      h.prototype.resolveDTLFormat = function (e) {\n        return L(e, !0) ? e : (e = I(e), {\n          main: e[0],\n          from: e[1],\n          to: e[2]\n        });\n      };\n\n      h.prototype.getTimeTicks = function (n, l, f, h) {\n        var r = this,\n            d = [],\n            g = {};\n        var c = new r.Date(l);\n        var a = n.unitRange,\n            q = n.count || 1,\n            p;\n        h = e(h, 1);\n\n        if (m(l)) {\n          r.set(\"Milliseconds\", c, a >= v.second ? 0 : q * Math.floor(r.get(\"Milliseconds\", c) / q));\n          a >= v.second && r.set(\"Seconds\", c, a >= v.minute ? 0 : q * Math.floor(r.get(\"Seconds\", c) / q));\n          a >= v.minute && r.set(\"Minutes\", c, a >= v.hour ? 0 : q * Math.floor(r.get(\"Minutes\", c) / q));\n          a >= v.hour && r.set(\"Hours\", c, a >= v.day ? 0 : q * Math.floor(r.get(\"Hours\", c) / q));\n          a >= v.day && r.set(\"Date\", c, a >= v.month ? 1 : Math.max(1, q * Math.floor(r.get(\"Date\", c) / q)));\n\n          if (a >= v.month) {\n            r.set(\"Month\", c, a >= v.year ? 0 : q * Math.floor(r.get(\"Month\", c) / q));\n            var B = r.get(\"FullYear\", c);\n          }\n\n          a >= v.year && r.set(\"FullYear\", c, B - B % q);\n          a === v.week && (B = r.get(\"Day\", c), r.set(\"Date\", c, r.get(\"Date\", c) - B + h + (B < h ? -7 : 0)));\n          B = r.get(\"FullYear\", c);\n          h = r.get(\"Month\", c);\n          var A = r.get(\"Date\", c),\n              w = r.get(\"Hours\", c);\n          l = c.getTime();\n          r.variableTimezone && (p = f - l > 4 * v.month || r.getTimezoneOffset(l) !== r.getTimezoneOffset(f));\n          l = c.getTime();\n\n          for (c = 1; l < f;) d.push(l), l = a === v.year ? r.makeTime(B + c * q, 0) : a === v.month ? r.makeTime(B, h + c * q) : !p || a !== v.day && a !== v.week ? p && a === v.hour && 1 < q ? r.makeTime(B, h, A, w + c * q) : l + a * q : r.makeTime(B, h, A + c * q * (a === v.day ? 1 : 7)), c++;\n\n          d.push(l);\n          a <= v.hour && 1E4 > d.length && d.forEach(function (a) {\n            0 === a % 18E5 && \"000000000\" === r.dateFormat(\"%H%M%S%L\", a) && (g[a] = \"day\");\n          });\n        }\n\n        d.info = F(n, {\n          higherRanks: g,\n          totalRange: a * q\n        });\n        return d;\n      };\n\n      return h;\n    }();\n\n    f.Time = h;\n    return f.Time;\n  });\n  N(m, \"Core/Options.js\", [m[\"Core/Globals.js\"], m[\"Core/Color/Color.js\"], m[\"Core/Time.js\"], m[\"Core/Utilities.js\"]], function (f, h, m, z) {\n    var F = f.isTouchDevice,\n        P = f.svg;\n    h = h.parse;\n    z = z.merge;\n    \"\";\n    f.defaultOptions = {\n      colors: \"#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1\".split(\" \"),\n      symbols: [\"circle\", \"diamond\", \"square\", \"triangle\", \"triangle-down\"],\n      lang: {\n        loading: \"Loading...\",\n        months: \"January February March April May June July August September October November December\".split(\" \"),\n        shortMonths: \"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\".split(\" \"),\n        weekdays: \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),\n        decimalPoint: \".\",\n        numericSymbols: \"kMGTPE\".split(\"\"),\n        resetZoom: \"Reset zoom\",\n        resetZoomTitle: \"Reset zoom level 1:1\",\n        thousandsSep: \" \"\n      },\n      global: {},\n      time: {\n        Date: void 0,\n        getTimezoneOffset: void 0,\n        timezone: void 0,\n        timezoneOffset: 0,\n        useUTC: !0\n      },\n      chart: {\n        styledMode: !1,\n        borderRadius: 0,\n        colorCount: 10,\n        defaultSeriesType: \"line\",\n        ignoreHiddenSeries: !0,\n        spacing: [10, 10, 15, 10],\n        resetZoomButton: {\n          theme: {\n            zIndex: 6\n          },\n          position: {\n            align: \"right\",\n            x: -10,\n            y: 10\n          }\n        },\n        width: null,\n        height: null,\n        borderColor: \"#335cad\",\n        backgroundColor: \"#ffffff\",\n        plotBorderColor: \"#cccccc\"\n      },\n      title: {\n        text: \"Chart title\",\n        align: \"center\",\n        margin: 15,\n        widthAdjust: -44\n      },\n      subtitle: {\n        text: \"\",\n        align: \"center\",\n        widthAdjust: -44\n      },\n      caption: {\n        margin: 15,\n        text: \"\",\n        align: \"left\",\n        verticalAlign: \"bottom\"\n      },\n      plotOptions: {},\n      labels: {\n        style: {\n          position: \"absolute\",\n          color: \"#333333\"\n        }\n      },\n      legend: {\n        enabled: !0,\n        align: \"center\",\n        alignColumns: !0,\n        layout: \"horizontal\",\n        labelFormatter: function () {\n          return this.name;\n        },\n        borderColor: \"#999999\",\n        borderRadius: 0,\n        navigation: {\n          activeColor: \"#003399\",\n          inactiveColor: \"#cccccc\"\n        },\n        itemStyle: {\n          color: \"#333333\",\n          cursor: \"pointer\",\n          fontSize: \"12px\",\n          fontWeight: \"bold\",\n          textOverflow: \"ellipsis\"\n        },\n        itemHoverStyle: {\n          color: \"#000000\"\n        },\n        itemHiddenStyle: {\n          color: \"#cccccc\"\n        },\n        shadow: !1,\n        itemCheckboxStyle: {\n          position: \"absolute\",\n          width: \"13px\",\n          height: \"13px\"\n        },\n        squareSymbol: !0,\n        symbolPadding: 5,\n        verticalAlign: \"bottom\",\n        x: 0,\n        y: 0,\n        title: {\n          style: {\n            fontWeight: \"bold\"\n          }\n        }\n      },\n      loading: {\n        labelStyle: {\n          fontWeight: \"bold\",\n          position: \"relative\",\n          top: \"45%\"\n        },\n        style: {\n          position: \"absolute\",\n          backgroundColor: \"#ffffff\",\n          opacity: .5,\n          textAlign: \"center\"\n        }\n      },\n      tooltip: {\n        enabled: !0,\n        animation: P,\n        borderRadius: 3,\n        dateTimeLabelFormats: {\n          millisecond: \"%A, %b %e, %H:%M:%S.%L\",\n          second: \"%A, %b %e, %H:%M:%S\",\n          minute: \"%A, %b %e, %H:%M\",\n          hour: \"%A, %b %e, %H:%M\",\n          day: \"%A, %b %e, %Y\",\n          week: \"Week from %A, %b %e, %Y\",\n          month: \"%B %Y\",\n          year: \"%Y\"\n        },\n        footerFormat: \"\",\n        padding: 8,\n        snap: F ? 25 : 10,\n        headerFormat: '<span style=\"font-size: 10px\">{point.key}</span><br/>',\n        pointFormat: '<span style=\"color:{point.color}\">\\u25cf</span> {series.name}: <b>{point.y}</b><br/>',\n        backgroundColor: h(\"#f7f7f7\").setOpacity(.85).get(),\n        borderWidth: 1,\n        shadow: !0,\n        style: {\n          color: \"#333333\",\n          cursor: \"default\",\n          fontSize: \"12px\",\n          whiteSpace: \"nowrap\"\n        }\n      },\n      credits: {\n        enabled: !0,\n        href: \"https://www.highcharts.com?credits\",\n        position: {\n          align: \"right\",\n          x: -10,\n          verticalAlign: \"bottom\",\n          y: -5\n        },\n        style: {\n          cursor: \"pointer\",\n          color: \"#999999\",\n          fontSize: \"9px\"\n        },\n        text: \"Highcharts.com\"\n      }\n    };\n    \"\";\n    f.time = new m(z(f.defaultOptions.global, f.defaultOptions.time));\n\n    f.dateFormat = function (h, m, y) {\n      return f.time.dateFormat(h, m, y);\n    };\n\n    return {\n      dateFormat: f.dateFormat,\n      defaultOptions: f.defaultOptions,\n      time: f.time\n    };\n  });\n  N(m, \"Core/Axis/Axis.js\", [m[\"Core/Animation/AnimationUtilities.js\"], m[\"Core/Color/Color.js\"], m[\"Core/Globals.js\"], m[\"Core/Axis/Tick.js\"], m[\"Core/Utilities.js\"], m[\"Core/Options.js\"]], function (f, h, m, z, F, L) {\n    var K = f.animObject,\n        C = F.addEvent,\n        y = F.arrayMax,\n        e = F.arrayMin,\n        I = F.clamp,\n        v = F.correctFloat,\n        x = F.defined,\n        D = F.destroyObjectProperties,\n        n = F.error,\n        l = F.extend,\n        J = F.fireEvent,\n        w = F.format,\n        r = F.getMagnitude,\n        d = F.isArray,\n        g = F.isFunction,\n        c = F.isNumber,\n        a = F.isString,\n        q = F.merge,\n        p = F.normalizeTickInterval,\n        B = F.objectEach,\n        A = F.pick,\n        G = F.relativeLength,\n        M = F.removeEvent,\n        T = F.splat,\n        Q = F.syncTimeout,\n        O = L.defaultOptions,\n        E = m.deg2rad;\n\n    f = function () {\n      function u(b, k) {\n        this.zoomEnabled = this.width = this.visible = this.userOptions = this.translationSlope = this.transB = this.transA = this.top = this.ticks = this.tickRotCorr = this.tickPositions = this.tickmarkOffset = this.tickInterval = this.tickAmount = this.side = this.series = this.right = this.positiveValuesOnly = this.pos = this.pointRangePadding = this.pointRange = this.plotLinesAndBandsGroups = this.plotLinesAndBands = this.paddedTicks = this.overlap = this.options = this.oldMin = this.oldMax = this.offset = this.names = this.minPixelPadding = this.minorTicks = this.minorTickInterval = this.min = this.maxLabelLength = this.max = this.len = this.left = this.labelFormatter = this.labelEdge = this.isLinked = this.height = this.hasVisibleSeries = this.hasNames = this.coll = this.closestPointRange = this.chart = this.categories = this.bottom = this.alternateBands = void 0;\n        this.init(b, k);\n      }\n\n      u.prototype.init = function (b, k) {\n        var a = k.isX,\n            c = this;\n        c.chart = b;\n        c.horiz = b.inverted && !c.isZAxis ? !a : a;\n        c.isXAxis = a;\n        c.coll = c.coll || (a ? \"xAxis\" : \"yAxis\");\n        J(this, \"init\", {\n          userOptions: k\n        });\n        c.opposite = k.opposite;\n        c.side = k.side || (c.horiz ? c.opposite ? 0 : 2 : c.opposite ? 1 : 3);\n        c.setOptions(k);\n        var d = this.options,\n            p = d.type;\n        c.labelFormatter = d.labels.formatter || c.defaultLabelFormatter;\n        c.userOptions = k;\n        c.minPixelPadding = 0;\n        c.reversed = d.reversed;\n        c.visible = !1 !== d.visible;\n        c.zoomEnabled = !1 !== d.zoomEnabled;\n        c.hasNames = \"category\" === p || !0 === d.categories;\n        c.categories = d.categories || c.hasNames;\n        c.names || (c.names = [], c.names.keys = {});\n        c.plotLinesAndBandsGroups = {};\n        c.positiveValuesOnly = !!c.logarithmic;\n        c.isLinked = x(d.linkedTo);\n        c.ticks = {};\n        c.labelEdge = [];\n        c.minorTicks = {};\n        c.plotLinesAndBands = [];\n        c.alternateBands = {};\n        c.len = 0;\n        c.minRange = c.userMinRange = d.minRange || d.maxZoom;\n        c.range = d.range;\n        c.offset = d.offset || 0;\n        c.max = null;\n        c.min = null;\n        c.crosshair = A(d.crosshair, T(b.options.tooltip.crosshairs)[a ? 0 : 1], !1);\n        k = c.options.events;\n        -1 === b.axes.indexOf(c) && (a ? b.axes.splice(b.xAxis.length, 0, c) : b.axes.push(c), b[c.coll].push(c));\n        c.series = c.series || [];\n        b.inverted && !c.isZAxis && a && \"undefined\" === typeof c.reversed && (c.reversed = !0);\n        c.labelRotation = c.options.labels.rotation;\n        B(k, function (b, k) {\n          g(b) && C(c, k, b);\n        });\n        J(this, \"afterInit\");\n      };\n\n      u.prototype.setOptions = function (b) {\n        this.options = q(u.defaultOptions, \"yAxis\" === this.coll && u.defaultYAxisOptions, [u.defaultTopAxisOptions, u.defaultRightAxisOptions, u.defaultBottomAxisOptions, u.defaultLeftAxisOptions][this.side], q(O[this.coll], b));\n        J(this, \"afterSetOptions\", {\n          userOptions: b\n        });\n      };\n\n      u.prototype.defaultLabelFormatter = function () {\n        var b = this.axis,\n            k = c(this.value) ? this.value : NaN,\n            a = b.chart.time,\n            d = b.categories,\n            g = this.dateTimeLabelFormat,\n            p = O.lang,\n            q = p.numericSymbols;\n        p = p.numericSymbolMagnitude || 1E3;\n        var e = q && q.length,\n            u = b.options.labels.format;\n        b = b.logarithmic ? Math.abs(k) : b.tickInterval;\n        var B = this.chart,\n            l = B.numberFormatter;\n        if (u) var A = w(u, this, B);else if (d) A = \"\" + this.value;else if (g) A = a.dateFormat(g, k);else if (e && 1E3 <= b) for (; e-- && \"undefined\" === typeof A;) a = Math.pow(p, e + 1), b >= a && 0 === 10 * k % a && null !== q[e] && 0 !== k && (A = l(k / a, -1) + q[e]);\n        \"undefined\" === typeof A && (A = 1E4 <= Math.abs(k) ? l(k, -1) : l(k, -1, void 0, \"\"));\n        return A;\n      };\n\n      u.prototype.getSeriesExtremes = function () {\n        var b = this,\n            k = b.chart,\n            a;\n        J(this, \"getSeriesExtremes\", null, function () {\n          b.hasVisibleSeries = !1;\n          b.dataMin = b.dataMax = b.threshold = null;\n          b.softThreshold = !b.isXAxis;\n          b.stacking && b.stacking.buildStacks();\n          b.series.forEach(function (t) {\n            if (t.visible || !k.options.chart.ignoreHiddenSeries) {\n              var d = t.options,\n                  g = d.threshold;\n              b.hasVisibleSeries = !0;\n              b.positiveValuesOnly && 0 >= g && (g = null);\n\n              if (b.isXAxis) {\n                if (d = t.xData, d.length) {\n                  d = b.logarithmic ? d.filter(b.validatePositiveValue) : d;\n                  a = t.getXExtremes(d);\n                  var p = a.min;\n                  var q = a.max;\n                  c(p) || p instanceof Date || (d = d.filter(c), a = t.getXExtremes(d), p = a.min, q = a.max);\n                  d.length && (b.dataMin = Math.min(A(b.dataMin, p), p), b.dataMax = Math.max(A(b.dataMax, q), q));\n                }\n              } else if (t = t.applyExtremes(), c(t.dataMin) && (p = t.dataMin, b.dataMin = Math.min(A(b.dataMin, p), p)), c(t.dataMax) && (q = t.dataMax, b.dataMax = Math.max(A(b.dataMax, q), q)), x(g) && (b.threshold = g), !d.softThreshold || b.positiveValuesOnly) b.softThreshold = !1;\n            }\n          });\n        });\n        J(this, \"afterGetSeriesExtremes\");\n      };\n\n      u.prototype.translate = function (b, a, t, d, g, p) {\n        var k = this.linkedParent || this,\n            q = 1,\n            e = 0,\n            H = d ? k.oldTransA : k.transA;\n        d = d ? k.oldMin : k.min;\n        var u = k.minPixelPadding;\n        g = (k.isOrdinal || k.brokenAxis && k.brokenAxis.hasBreaks || k.logarithmic && g) && k.lin2val;\n        H || (H = k.transA);\n        t && (q *= -1, e = k.len);\n        k.reversed && (q *= -1, e -= q * (k.sector || k.len));\n        a ? (b = (b * q + e - u) / H + d, g && (b = k.lin2val(b))) : (g && (b = k.val2lin(b)), b = c(d) ? q * (b - d) * H + e + q * u + (c(p) ? H * p : 0) : void 0);\n        return b;\n      };\n\n      u.prototype.toPixels = function (b, k) {\n        return this.translate(b, !1, !this.horiz, null, !0) + (k ? 0 : this.pos);\n      };\n\n      u.prototype.toValue = function (b, k) {\n        return this.translate(b - (k ? 0 : this.pos), !0, !this.horiz, null, !0);\n      };\n\n      u.prototype.getPlotLinePath = function (b) {\n        function k(b, a, k) {\n          if (\"pass\" !== l && b < a || b > k) l ? b = I(b, a, k) : E = !0;\n          return b;\n        }\n\n        var a = this,\n            d = a.chart,\n            g = a.left,\n            p = a.top,\n            q = b.old,\n            e = b.value,\n            u = b.translatedValue,\n            B = b.lineWidth,\n            l = b.force,\n            r,\n            n,\n            f,\n            h,\n            w = q && d.oldChartHeight || d.chartHeight,\n            G = q && d.oldChartWidth || d.chartWidth,\n            E,\n            v = a.transB;\n        b = {\n          value: e,\n          lineWidth: B,\n          old: q,\n          force: l,\n          acrossPanes: b.acrossPanes,\n          translatedValue: u\n        };\n        J(this, \"getPlotLinePath\", b, function (b) {\n          u = A(u, a.translate(e, null, null, q));\n          u = I(u, -1E5, 1E5);\n          r = f = Math.round(u + v);\n          n = h = Math.round(w - u - v);\n          c(u) ? a.horiz ? (n = p, h = w - a.bottom, r = f = k(r, g, g + a.width)) : (r = g, f = G - a.right, n = h = k(n, p, p + a.height)) : (E = !0, l = !1);\n          b.path = E && !l ? null : d.renderer.crispLine([[\"M\", r, n], [\"L\", f, h]], B || 1);\n        });\n        return b.path;\n      };\n\n      u.prototype.getLinearTickPositions = function (b, a, c) {\n        var k = v(Math.floor(a / b) * b);\n        c = v(Math.ceil(c / b) * b);\n        var t = [],\n            d;\n        v(k + b) === k && (d = 20);\n        if (this.single) return [a];\n\n        for (a = k; a <= c;) {\n          t.push(a);\n          a = v(a + b, d);\n          if (a === g) break;\n          var g = a;\n        }\n\n        return t;\n      };\n\n      u.prototype.getMinorTickInterval = function () {\n        var b = this.options;\n        return !0 === b.minorTicks ? A(b.minorTickInterval, \"auto\") : !1 === b.minorTicks ? null : b.minorTickInterval;\n      };\n\n      u.prototype.getMinorTickPositions = function () {\n        var b = this.options,\n            a = this.tickPositions,\n            c = this.minorTickInterval,\n            d = [],\n            g = this.pointRangePadding || 0,\n            p = this.min - g;\n        g = this.max + g;\n        var q = g - p;\n\n        if (q && q / c < this.len / 3) {\n          var e = this.logarithmic;\n          if (e) this.paddedTicks.forEach(function (b, a, k) {\n            a && d.push.apply(d, e.getLogTickPositions(c, k[a - 1], k[a], !0));\n          });else if (this.dateTime && \"auto\" === this.getMinorTickInterval()) d = d.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(c), p, g, b.startOfWeek));else for (b = p + (a[0] - p) % c; b <= g && b !== d[0]; b += c) d.push(b);\n        }\n\n        0 !== d.length && this.trimTicks(d);\n        return d;\n      };\n\n      u.prototype.adjustForMinRange = function () {\n        var b = this.options,\n            a = this.min,\n            c = this.max,\n            d = this.logarithmic,\n            g,\n            p,\n            q,\n            u,\n            B;\n        this.isXAxis && \"undefined\" === typeof this.minRange && !d && (x(b.min) || x(b.max) ? this.minRange = null : (this.series.forEach(function (b) {\n          u = b.xData;\n\n          for (p = B = b.xIncrement ? 1 : u.length - 1; 0 < p; p--) if (q = u[p] - u[p - 1], \"undefined\" === typeof g || q < g) g = q;\n        }), this.minRange = Math.min(5 * g, this.dataMax - this.dataMin)));\n\n        if (c - a < this.minRange) {\n          var l = this.dataMax - this.dataMin >= this.minRange;\n          var r = this.minRange;\n          var n = (r - c + a) / 2;\n          n = [a - n, A(b.min, a - n)];\n          l && (n[2] = this.logarithmic ? this.logarithmic.log2lin(this.dataMin) : this.dataMin);\n          a = y(n);\n          c = [a + r, A(b.max, a + r)];\n          l && (c[2] = d ? d.log2lin(this.dataMax) : this.dataMax);\n          c = e(c);\n          c - a < r && (n[0] = c - r, n[1] = A(b.min, c - r), a = y(n));\n        }\n\n        this.min = a;\n        this.max = c;\n      };\n\n      u.prototype.getClosest = function () {\n        var b;\n        this.categories ? b = 1 : this.series.forEach(function (a) {\n          var k = a.closestPointRange,\n              c = a.visible || !a.chart.options.chart.ignoreHiddenSeries;\n          !a.noSharedTooltip && x(k) && c && (b = x(b) ? Math.min(b, k) : k);\n        });\n        return b;\n      };\n\n      u.prototype.nameToX = function (b) {\n        var a = d(this.categories),\n            c = a ? this.categories : this.names,\n            g = b.options.x;\n        b.series.requireSorting = !1;\n        x(g) || (g = !1 === this.options.uniqueNames ? b.series.autoIncrement() : a ? c.indexOf(b.name) : A(c.keys[b.name], -1));\n\n        if (-1 === g) {\n          if (!a) var p = c.length;\n        } else p = g;\n\n        \"undefined\" !== typeof p && (this.names[p] = b.name, this.names.keys[b.name] = p);\n        return p;\n      };\n\n      u.prototype.updateNames = function () {\n        var b = this,\n            a = this.names;\n        0 < a.length && (Object.keys(a.keys).forEach(function (b) {\n          delete a.keys[b];\n        }), a.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function (a) {\n          a.xIncrement = null;\n          if (!a.points || a.isDirtyData) b.max = Math.max(b.max, a.xData.length - 1), a.processData(), a.generatePoints();\n          a.data.forEach(function (k, c) {\n            if (k && k.options && \"undefined\" !== typeof k.name) {\n              var d = b.nameToX(k);\n              \"undefined\" !== typeof d && d !== k.x && (k.x = d, a.xData[c] = d);\n            }\n          });\n        }));\n      };\n\n      u.prototype.setAxisTranslation = function (b) {\n        var k = this,\n            c = k.max - k.min,\n            d = k.axisPointRange || 0,\n            g = 0,\n            p = 0,\n            q = k.linkedParent,\n            e = !!k.categories,\n            u = k.transA,\n            B = k.isXAxis;\n\n        if (B || e || d) {\n          var l = k.getClosest();\n          q ? (g = q.minPointOffset, p = q.pointRangePadding) : k.series.forEach(function (b) {\n            var c = e ? 1 : B ? A(b.options.pointRange, l, 0) : k.axisPointRange || 0,\n                t = b.options.pointPlacement;\n            d = Math.max(d, c);\n            if (!k.single || e) b = b.is(\"xrange\") ? !B : B, g = Math.max(g, b && a(t) ? 0 : c / 2), p = Math.max(p, b && \"on\" === t ? 0 : c);\n          });\n          q = k.ordinal && k.ordinal.slope && l ? k.ordinal.slope / l : 1;\n          k.minPointOffset = g *= q;\n          k.pointRangePadding = p *= q;\n          k.pointRange = Math.min(d, k.single && e ? 1 : c);\n          B && (k.closestPointRange = l);\n        }\n\n        b && (k.oldTransA = u);\n        k.translationSlope = k.transA = u = k.staticScale || k.len / (c + p || 1);\n        k.transB = k.horiz ? k.left : k.bottom;\n        k.minPixelPadding = u * g;\n        J(this, \"afterSetAxisTranslation\");\n      };\n\n      u.prototype.minFromRange = function () {\n        return this.max - this.range;\n      };\n\n      u.prototype.setTickInterval = function (b) {\n        var a = this,\n            d = a.chart,\n            g = a.logarithmic,\n            q = a.options,\n            e = a.isXAxis,\n            u = a.isLinked,\n            B = q.maxPadding,\n            l = q.minPadding,\n            f = q.tickInterval,\n            h = q.tickPixelInterval,\n            w = a.categories,\n            G = c(a.threshold) ? a.threshold : null,\n            E = a.softThreshold;\n        a.dateTime || w || u || this.getTickAmount();\n        var O = A(a.userMin, q.min);\n        var D = A(a.userMax, q.max);\n\n        if (u) {\n          a.linkedParent = d[a.coll][q.linkedTo];\n          var M = a.linkedParent.getExtremes();\n          a.min = A(M.min, M.dataMin);\n          a.max = A(M.max, M.dataMax);\n          q.type !== a.linkedParent.options.type && n(11, 1, d);\n        } else {\n          if (E && x(G)) if (a.dataMin >= G) M = G, l = 0;else if (a.dataMax <= G) {\n            var m = G;\n            B = 0;\n          }\n          a.min = A(O, M, a.dataMin);\n          a.max = A(D, m, a.dataMax);\n        }\n\n        g && (a.positiveValuesOnly && !b && 0 >= Math.min(a.min, A(a.dataMin, a.min)) && n(10, 1, d), a.min = v(g.log2lin(a.min), 16), a.max = v(g.log2lin(a.max), 16));\n        a.range && x(a.max) && (a.userMin = a.min = O = Math.max(a.dataMin, a.minFromRange()), a.userMax = D = a.max, a.range = null);\n        J(a, \"foundExtremes\");\n        a.beforePadding && a.beforePadding();\n        a.adjustForMinRange();\n        !(w || a.axisPointRange || a.stacking && a.stacking.usePercentage || u) && x(a.min) && x(a.max) && (d = a.max - a.min) && (!x(O) && l && (a.min -= d * l), !x(D) && B && (a.max += d * B));\n        c(a.userMin) || (c(q.softMin) && q.softMin < a.min && (a.min = O = q.softMin), c(q.floor) && (a.min = Math.max(a.min, q.floor)));\n        c(a.userMax) || (c(q.softMax) && q.softMax > a.max && (a.max = D = q.softMax), c(q.ceiling) && (a.max = Math.min(a.max, q.ceiling)));\n        E && x(a.dataMin) && (G = G || 0, !x(O) && a.min < G && a.dataMin >= G ? a.min = a.options.minRange ? Math.min(G, a.max - a.minRange) : G : !x(D) && a.max > G && a.dataMax <= G && (a.max = a.options.minRange ? Math.max(G, a.min + a.minRange) : G));\n        a.tickInterval = a.min === a.max || \"undefined\" === typeof a.min || \"undefined\" === typeof a.max ? 1 : u && !f && h === a.linkedParent.options.tickPixelInterval ? f = a.linkedParent.tickInterval : A(f, this.tickAmount ? (a.max - a.min) / Math.max(this.tickAmount - 1, 1) : void 0, w ? 1 : (a.max - a.min) * h / Math.max(a.len, h));\n        e && !b && a.series.forEach(function (b) {\n          b.processData(a.min !== a.oldMin || a.max !== a.oldMax);\n        });\n        a.setAxisTranslation(!0);\n        J(this, \"initialAxisTranslation\");\n        a.pointRange && !f && (a.tickInterval = Math.max(a.pointRange, a.tickInterval));\n        b = A(q.minTickInterval, a.dateTime && !a.series.some(function (b) {\n          return b.noSharedTooltip;\n        }) ? a.closestPointRange : 0);\n        !f && a.tickInterval < b && (a.tickInterval = b);\n        a.dateTime || a.logarithmic || f || (a.tickInterval = p(a.tickInterval, void 0, r(a.tickInterval), A(q.allowDecimals, .5 > a.tickInterval || void 0 !== this.tickAmount), !!this.tickAmount));\n        this.tickAmount || (a.tickInterval = a.unsquish());\n        this.setTickPositions();\n      };\n\n      u.prototype.setTickPositions = function () {\n        var b = this.options,\n            a = b.tickPositions;\n        var c = this.getMinorTickInterval();\n        var d = b.tickPositioner,\n            g = this.hasVerticalPanning(),\n            p = \"colorAxis\" === this.coll,\n            q = (p || !g) && b.startOnTick;\n        g = (p || !g) && b.endOnTick;\n        this.tickmarkOffset = this.categories && \"between\" === b.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;\n        this.minorTickInterval = \"auto\" === c && this.tickInterval ? this.tickInterval / 5 : c;\n        this.single = this.min === this.max && x(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== b.allowDecimals);\n        this.tickPositions = c = a && a.slice();\n        !c && (this.ordinal && this.ordinal.positions || !((this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)) ? c = this.dateTime ? this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, b.units), this.min, this.max, b.startOfWeek, this.ordinal && this.ordinal.positions, this.closestPointRange, !0) : this.logarithmic ? this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max) : this.getLinearTickPositions(this.tickInterval, this.min, this.max) : (c = [this.min, this.max], n(19, !1, this.chart)), c.length > this.len && (c = [c[0], c.pop()], c[0] === c[1] && (c.length = 1)), this.tickPositions = c, d && (d = d.apply(this, [this.min, this.max]))) && (this.tickPositions = c = d);\n        this.paddedTicks = c.slice(0);\n        this.trimTicks(c, q, g);\n        this.isLinked || (this.single && 2 > c.length && !this.categories && !this.series.some(function (b) {\n          return b.is(\"heatmap\") && \"between\" === b.options.pointPlacement;\n        }) && (this.min -= .5, this.max += .5), a || d || this.adjustTickAmount());\n        J(this, \"afterSetTickPositions\");\n      };\n\n      u.prototype.trimTicks = function (b, a, c) {\n        var k = b[0],\n            d = b[b.length - 1],\n            t = !this.isOrdinal && this.minPointOffset || 0;\n        J(this, \"trimTicks\");\n\n        if (!this.isLinked) {\n          if (a && -Infinity !== k) this.min = k;else for (; this.min - t > b[0];) b.shift();\n          if (c) this.max = d;else for (; this.max + t < b[b.length - 1];) b.pop();\n          0 === b.length && x(k) && !this.options.tickPositions && b.push((d + k) / 2);\n        }\n      };\n\n      u.prototype.alignToOthers = function () {\n        var b = {},\n            a,\n            c = this.options;\n        !1 === this.chart.options.chart.alignTicks || !1 === c.alignTicks || !1 === c.startOnTick || !1 === c.endOnTick || this.logarithmic || this.chart[this.coll].forEach(function (k) {\n          var c = k.options;\n          c = [k.horiz ? c.left : c.top, c.width, c.height, c.pane].join();\n          k.series.length && (b[c] ? a = !0 : b[c] = 1);\n        });\n        return a;\n      };\n\n      u.prototype.getTickAmount = function () {\n        var b = this.options,\n            a = b.tickAmount,\n            c = b.tickPixelInterval;\n        !x(b.tickInterval) && !a && this.len < c && !this.isRadial && !this.logarithmic && b.startOnTick && b.endOnTick && (a = 2);\n        !a && this.alignToOthers() && (a = Math.ceil(this.len / c) + 1);\n        4 > a && (this.finalTickAmt = a, a = 5);\n        this.tickAmount = a;\n      };\n\n      u.prototype.adjustTickAmount = function () {\n        var b = this.options,\n            a = this.tickInterval,\n            c = this.tickPositions,\n            d = this.tickAmount,\n            g = this.finalTickAmt,\n            p = c && c.length,\n            q = A(this.threshold, this.softThreshold ? 0 : null),\n            e;\n\n        if (this.hasData()) {\n          if (p < d) {\n            for (e = this.min; c.length < d;) c.length % 2 || e === q ? c.push(v(c[c.length - 1] + a)) : c.unshift(v(c[0] - a));\n\n            this.transA *= (p - 1) / (d - 1);\n            this.min = b.startOnTick ? c[0] : Math.min(this.min, c[0]);\n            this.max = b.endOnTick ? c[c.length - 1] : Math.max(this.max, c[c.length - 1]);\n          } else p > d && (this.tickInterval *= 2, this.setTickPositions());\n\n          if (x(g)) {\n            for (a = b = c.length; a--;) (3 === g && 1 === a % 2 || 2 >= g && 0 < a && a < b - 1) && c.splice(a, 1);\n\n            this.finalTickAmt = void 0;\n          }\n        }\n      };\n\n      u.prototype.setScale = function () {\n        var b,\n            a = !1,\n            c = !1;\n        this.series.forEach(function (b) {\n          var k;\n          a = a || b.isDirtyData || b.isDirty;\n          c = c || (null === (k = b.xAxis) || void 0 === k ? void 0 : k.isDirty) || !1;\n        });\n        this.oldMin = this.min;\n        this.oldMax = this.max;\n        this.oldAxisLength = this.len;\n        this.setAxisSize();\n        (b = this.len !== this.oldAxisLength) || a || c || this.isLinked || this.forceRedraw || this.userMin !== this.oldUserMin || this.userMax !== this.oldUserMax || this.alignToOthers() ? (this.stacking && this.stacking.resetStacks(), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.oldUserMin = this.userMin, this.oldUserMax = this.userMax, this.isDirty || (this.isDirty = b || this.min !== this.oldMin || this.max !== this.oldMax)) : this.stacking && this.stacking.cleanStacks();\n        a && this.panningState && (this.panningState.isDirty = !0);\n        J(this, \"afterSetScale\");\n      };\n\n      u.prototype.setExtremes = function (b, a, c, d, g) {\n        var k = this,\n            t = k.chart;\n        c = A(c, !0);\n        k.series.forEach(function (b) {\n          delete b.kdTree;\n        });\n        g = l(g, {\n          min: b,\n          max: a\n        });\n        J(k, \"setExtremes\", g, function () {\n          k.userMin = b;\n          k.userMax = a;\n          k.eventArgs = g;\n          c && t.redraw(d);\n        });\n      };\n\n      u.prototype.zoom = function (b, a) {\n        var k = this,\n            c = this.dataMin,\n            d = this.dataMax,\n            g = this.options,\n            p = Math.min(c, A(g.min, c)),\n            q = Math.max(d, A(g.max, d));\n        b = {\n          newMin: b,\n          newMax: a\n        };\n        J(this, \"zoom\", b, function (b) {\n          var a = b.newMin,\n              g = b.newMax;\n          if (a !== k.min || g !== k.max) k.allowZoomOutside || (x(c) && (a < p && (a = p), a > q && (a = q)), x(d) && (g < p && (g = p), g > q && (g = q))), k.displayBtn = \"undefined\" !== typeof a || \"undefined\" !== typeof g, k.setExtremes(a, g, !1, void 0, {\n            trigger: \"zoom\"\n          });\n          b.zoomed = !0;\n        });\n        return b.zoomed;\n      };\n\n      u.prototype.setAxisSize = function () {\n        var b = this.chart,\n            a = this.options,\n            c = a.offsets || [0, 0, 0, 0],\n            d = this.horiz,\n            g = this.width = Math.round(G(A(a.width, b.plotWidth - c[3] + c[1]), b.plotWidth)),\n            p = this.height = Math.round(G(A(a.height, b.plotHeight - c[0] + c[2]), b.plotHeight)),\n            q = this.top = Math.round(G(A(a.top, b.plotTop + c[0]), b.plotHeight, b.plotTop));\n        a = this.left = Math.round(G(A(a.left, b.plotLeft + c[3]), b.plotWidth, b.plotLeft));\n        this.bottom = b.chartHeight - p - q;\n        this.right = b.chartWidth - g - a;\n        this.len = Math.max(d ? g : p, 0);\n        this.pos = d ? a : q;\n      };\n\n      u.prototype.getExtremes = function () {\n        var b = this.logarithmic;\n        return {\n          min: b ? v(b.lin2log(this.min)) : this.min,\n          max: b ? v(b.lin2log(this.max)) : this.max,\n          dataMin: this.dataMin,\n          dataMax: this.dataMax,\n          userMin: this.userMin,\n          userMax: this.userMax\n        };\n      };\n\n      u.prototype.getThreshold = function (b) {\n        var a = this.logarithmic,\n            c = a ? a.lin2log(this.min) : this.min;\n        a = a ? a.lin2log(this.max) : this.max;\n        null === b || -Infinity === b ? b = c : Infinity === b ? b = a : c > b ? b = c : a < b && (b = a);\n        return this.translate(b, 0, 1, 0, 1);\n      };\n\n      u.prototype.autoLabelAlign = function (b) {\n        var a = (A(b, 0) - 90 * this.side + 720) % 360;\n        b = {\n          align: \"center\"\n        };\n        J(this, \"autoLabelAlign\", b, function (b) {\n          15 < a && 165 > a ? b.align = \"right\" : 195 < a && 345 > a && (b.align = \"left\");\n        });\n        return b.align;\n      };\n\n      u.prototype.tickSize = function (b) {\n        var a = this.options,\n            c = a[\"tick\" === b ? \"tickLength\" : \"minorTickLength\"],\n            d = A(a[\"tick\" === b ? \"tickWidth\" : \"minorTickWidth\"], \"tick\" === b && this.isXAxis && !this.categories ? 1 : 0);\n\n        if (d && c) {\n          \"inside\" === a[b + \"Position\"] && (c = -c);\n          var g = [c, d];\n        }\n\n        b = {\n          tickSize: g\n        };\n        J(this, \"afterTickSize\", b);\n        return b.tickSize;\n      };\n\n      u.prototype.labelMetrics = function () {\n        var b = this.tickPositions && this.tickPositions[0] || 0;\n        return this.chart.renderer.fontMetrics(this.options.labels.style && this.options.labels.style.fontSize, this.ticks[b] && this.ticks[b].label);\n      };\n\n      u.prototype.unsquish = function () {\n        var b = this.options.labels,\n            a = this.horiz,\n            c = this.tickInterval,\n            d = c,\n            g = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / c),\n            p,\n            q = b.rotation,\n            e = this.labelMetrics(),\n            u,\n            B = Number.MAX_VALUE,\n            l,\n            r = this.max - this.min,\n            n = function (b) {\n          var a = b / (g || 1);\n          a = 1 < a ? Math.ceil(a) : 1;\n          a * c > r && Infinity !== b && Infinity !== g && r && (a = Math.ceil(r / c));\n          return v(a * c);\n        };\n\n        a ? (l = !b.staggerLines && !b.step && (x(q) ? [q] : g < A(b.autoRotationLimit, 80) && b.autoRotation)) && l.forEach(function (b) {\n          if (b === q || b && -90 <= b && 90 >= b) {\n            u = n(Math.abs(e.h / Math.sin(E * b)));\n            var a = u + Math.abs(b / 360);\n            a < B && (B = a, p = b, d = u);\n          }\n        }) : b.step || (d = n(e.h));\n        this.autoRotation = l;\n        this.labelRotation = A(p, q);\n        return d;\n      };\n\n      u.prototype.getSlotWidth = function (b) {\n        var a,\n            d = this.chart,\n            g = this.horiz,\n            p = this.options.labels,\n            q = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),\n            e = d.margin[3];\n        if (b && c(b.slotWidth)) return b.slotWidth;\n        if (g && p && 2 > (p.step || 0)) return p.rotation ? 0 : (this.staggerLines || 1) * this.len / q;\n\n        if (!g) {\n          b = null === (a = null === p || void 0 === p ? void 0 : p.style) || void 0 === a ? void 0 : a.width;\n          if (void 0 !== b) return parseInt(b, 10);\n          if (e) return e - d.spacing[3];\n        }\n\n        return .33 * d.chartWidth;\n      };\n\n      u.prototype.renderUnsquish = function () {\n        var b = this.chart,\n            k = b.renderer,\n            c = this.tickPositions,\n            d = this.ticks,\n            g = this.options.labels,\n            p = g && g.style || {},\n            q = this.horiz,\n            e = this.getSlotWidth(),\n            u = Math.max(1, Math.round(e - 2 * (g.padding || 5))),\n            B = {},\n            l = this.labelMetrics(),\n            r = g.style && g.style.textOverflow,\n            n = 0;\n        a(g.rotation) || (B.rotation = g.rotation || 0);\n        c.forEach(function (b) {\n          b = d[b];\n          b.movedLabel && b.replaceMovedLabel();\n          b && b.label && b.label.textPxLength > n && (n = b.label.textPxLength);\n        });\n        this.maxLabelLength = n;\n        if (this.autoRotation) n > u && n > l.h ? B.rotation = this.labelRotation : this.labelRotation = 0;else if (e) {\n          var A = u;\n\n          if (!r) {\n            var f = \"clip\";\n\n            for (u = c.length; !q && u--;) {\n              var h = c[u];\n              if (h = d[h].label) h.styles && \"ellipsis\" === h.styles.textOverflow ? h.css({\n                textOverflow: \"clip\"\n              }) : h.textPxLength > e && h.css({\n                width: e + \"px\"\n              }), h.getBBox().height > this.len / c.length - (l.h - l.f) && (h.specificTextOverflow = \"ellipsis\");\n            }\n          }\n        }\n        B.rotation && (A = n > .5 * b.chartHeight ? .33 * b.chartHeight : n, r || (f = \"ellipsis\"));\n        if (this.labelAlign = g.align || this.autoLabelAlign(this.labelRotation)) B.align = this.labelAlign;\n        c.forEach(function (b) {\n          var a = (b = d[b]) && b.label,\n              k = p.width,\n              c = {};\n          a && (a.attr(B), b.shortenLabel ? b.shortenLabel() : A && !k && \"nowrap\" !== p.whiteSpace && (A < a.textPxLength || \"SPAN\" === a.element.tagName) ? (c.width = A + \"px\", r || (c.textOverflow = a.specificTextOverflow || f), a.css(c)) : a.styles && a.styles.width && !c.width && !k && a.css({\n            width: null\n          }), delete a.specificTextOverflow, b.rotation = B.rotation);\n        }, this);\n        this.tickRotCorr = k.rotCorr(l.b, this.labelRotation || 0, 0 !== this.side);\n      };\n\n      u.prototype.hasData = function () {\n        return this.series.some(function (b) {\n          return b.hasData();\n        }) || this.options.showEmpty && x(this.min) && x(this.max);\n      };\n\n      u.prototype.addTitle = function (b) {\n        var a = this.chart.renderer,\n            c = this.horiz,\n            d = this.opposite,\n            g = this.options.title,\n            p,\n            e = this.chart.styledMode;\n        this.axisTitle || ((p = g.textAlign) || (p = (c ? {\n          low: \"left\",\n          middle: \"center\",\n          high: \"right\"\n        } : {\n          low: d ? \"right\" : \"left\",\n          middle: \"center\",\n          high: d ? \"left\" : \"right\"\n        })[g.align]), this.axisTitle = a.text(g.text, 0, 0, g.useHTML).attr({\n          zIndex: 7,\n          rotation: g.rotation || 0,\n          align: p\n        }).addClass(\"highcharts-axis-title\"), e || this.axisTitle.css(q(g.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0);\n        e || g.style.width || this.isRadial || this.axisTitle.css({\n          width: this.len + \"px\"\n        });\n        this.axisTitle[b ? \"show\" : \"hide\"](b);\n      };\n\n      u.prototype.generateTick = function (b) {\n        var a = this.ticks;\n        a[b] ? a[b].addLabel() : a[b] = new z(this, b);\n      };\n\n      u.prototype.getOffset = function () {\n        var b = this,\n            a = b.chart,\n            c = a.renderer,\n            d = b.options,\n            g = b.tickPositions,\n            p = b.ticks,\n            q = b.horiz,\n            e = b.side,\n            u = a.inverted && !b.isZAxis ? [1, 0, 3, 2][e] : e,\n            l,\n            n = 0,\n            r = 0,\n            f = d.title,\n            h = d.labels,\n            G = 0,\n            w = a.axisOffset;\n        a = a.clipOffset;\n        var E = [-1, 1, 1, -1][e],\n            v = d.className,\n            O = b.axisParent;\n        var D = b.hasData();\n        b.showAxis = l = D || A(d.showEmpty, !0);\n        b.staggerLines = b.horiz && h.staggerLines;\n        b.axisGroup || (b.gridGroup = c.g(\"grid\").attr({\n          zIndex: d.gridZIndex || 1\n        }).addClass(\"highcharts-\" + this.coll.toLowerCase() + \"-grid \" + (v || \"\")).add(O), b.axisGroup = c.g(\"axis\").attr({\n          zIndex: d.zIndex || 2\n        }).addClass(\"highcharts-\" + this.coll.toLowerCase() + \" \" + (v || \"\")).add(O), b.labelGroup = c.g(\"axis-labels\").attr({\n          zIndex: h.zIndex || 7\n        }).addClass(\"highcharts-\" + b.coll.toLowerCase() + \"-labels \" + (v || \"\")).add(O));\n        D || b.isLinked ? (g.forEach(function (a, c) {\n          b.generateTick(a, c);\n        }), b.renderUnsquish(), b.reserveSpaceDefault = 0 === e || 2 === e || {\n          1: \"left\",\n          3: \"right\"\n        }[e] === b.labelAlign, A(h.reserveSpace, \"center\" === b.labelAlign ? !0 : null, b.reserveSpaceDefault) && g.forEach(function (b) {\n          G = Math.max(p[b].getLabelSize(), G);\n        }), b.staggerLines && (G *= b.staggerLines), b.labelOffset = G * (b.opposite ? -1 : 1)) : B(p, function (b, a) {\n          b.destroy();\n          delete p[a];\n        });\n\n        if (f && f.text && !1 !== f.enabled && (b.addTitle(l), l && !1 !== f.reserveSpace)) {\n          b.titleOffset = n = b.axisTitle.getBBox()[q ? \"height\" : \"width\"];\n          var M = f.offset;\n          r = x(M) ? 0 : A(f.margin, q ? 5 : 10);\n        }\n\n        b.renderLine();\n        b.offset = E * A(d.offset, w[e] ? w[e] + (d.margin || 0) : 0);\n        b.tickRotCorr = b.tickRotCorr || {\n          x: 0,\n          y: 0\n        };\n        c = 0 === e ? -b.labelMetrics().h : 2 === e ? b.tickRotCorr.y : 0;\n        r = Math.abs(G) + r;\n        G && (r = r - c + E * (q ? A(h.y, b.tickRotCorr.y + 8 * E) : h.x));\n        b.axisTitleMargin = A(M, r);\n        b.getMaxLabelDimensions && (b.maxLabelDimensions = b.getMaxLabelDimensions(p, g));\n        q = this.tickSize(\"tick\");\n        w[e] = Math.max(w[e], b.axisTitleMargin + n + E * b.offset, r, g && g.length && q ? q[0] + E * b.offset : 0);\n        d = d.offset ? 0 : 2 * Math.floor(b.axisLine.strokeWidth() / 2);\n        a[u] = Math.max(a[u], d);\n        J(this, \"afterGetOffset\");\n      };\n\n      u.prototype.getLinePath = function (b) {\n        var a = this.chart,\n            c = this.opposite,\n            d = this.offset,\n            g = this.horiz,\n            p = this.left + (c ? this.width : 0) + d;\n        d = a.chartHeight - this.bottom - (c ? this.height : 0) + d;\n        c && (b *= -1);\n        return a.renderer.crispLine([[\"M\", g ? this.left : p, g ? d : this.top], [\"L\", g ? a.chartWidth - this.right : p, g ? d : a.chartHeight - this.bottom]], b);\n      };\n\n      u.prototype.renderLine = function () {\n        this.axisLine || (this.axisLine = this.chart.renderer.path().addClass(\"highcharts-axis-line\").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({\n          stroke: this.options.lineColor,\n          \"stroke-width\": this.options.lineWidth,\n          zIndex: 7\n        }));\n      };\n\n      u.prototype.getTitlePosition = function () {\n        var b = this.horiz,\n            a = this.left,\n            c = this.top,\n            d = this.len,\n            g = this.options.title,\n            p = b ? a : c,\n            q = this.opposite,\n            e = this.offset,\n            u = g.x || 0,\n            B = g.y || 0,\n            l = this.axisTitle,\n            r = this.chart.renderer.fontMetrics(g.style && g.style.fontSize, l);\n        l = Math.max(l.getBBox(null, 0).height - r.h - 1, 0);\n        d = {\n          low: p + (b ? 0 : d),\n          middle: p + d / 2,\n          high: p + (b ? d : 0)\n        }[g.align];\n        a = (b ? c + this.height : a) + (b ? 1 : -1) * (q ? -1 : 1) * this.axisTitleMargin + [-l, l, r.f, -l][this.side];\n        b = {\n          x: b ? d + u : a + (q ? this.width : 0) + e + u,\n          y: b ? a + B - (q ? this.height : 0) + e : d + B\n        };\n        J(this, \"afterGetTitlePosition\", {\n          titlePosition: b\n        });\n        return b;\n      };\n\n      u.prototype.renderMinorTick = function (b) {\n        var a = this.chart.hasRendered && c(this.oldMin),\n            d = this.minorTicks;\n        d[b] || (d[b] = new z(this, b, \"minor\"));\n        a && d[b].isNew && d[b].render(null, !0);\n        d[b].render(null, !1, 1);\n      };\n\n      u.prototype.renderTick = function (b, a) {\n        var k,\n            d = this.isLinked,\n            g = this.ticks,\n            p = this.chart.hasRendered && c(this.oldMin);\n        if (!d || b >= this.min && b <= this.max || (null === (k = this.grid) || void 0 === k ? 0 : k.isColumn)) g[b] || (g[b] = new z(this, b)), p && g[b].isNew && g[b].render(a, !0, -1), g[b].render(a);\n      };\n\n      u.prototype.render = function () {\n        var b = this,\n            a = b.chart,\n            d = b.logarithmic,\n            g = b.options,\n            p = b.isLinked,\n            q = b.tickPositions,\n            e = b.axisTitle,\n            u = b.ticks,\n            l = b.minorTicks,\n            r = b.alternateBands,\n            n = g.stackLabels,\n            f = g.alternateGridColor,\n            A = b.tickmarkOffset,\n            h = b.axisLine,\n            G = b.showAxis,\n            w = K(a.renderer.globalAnimation),\n            E,\n            v;\n        b.labelEdge.length = 0;\n        b.overlap = !1;\n        [u, l, r].forEach(function (b) {\n          B(b, function (b) {\n            b.isActive = !1;\n          });\n        });\n        if (b.hasData() || p) b.minorTickInterval && !b.categories && b.getMinorTickPositions().forEach(function (a) {\n          b.renderMinorTick(a);\n        }), q.length && (q.forEach(function (a, c) {\n          b.renderTick(a, c);\n        }), A && (0 === b.min || b.single) && (u[-1] || (u[-1] = new z(b, -1, null, !0)), u[-1].render(-1))), f && q.forEach(function (c, k) {\n          v = \"undefined\" !== typeof q[k + 1] ? q[k + 1] + A : b.max - A;\n          0 === k % 2 && c < b.max && v <= b.max + (a.polar ? -A : A) && (r[c] || (r[c] = new m.PlotLineOrBand(b)), E = c + A, r[c].options = {\n            from: d ? d.lin2log(E) : E,\n            to: d ? d.lin2log(v) : v,\n            color: f,\n            className: \"highcharts-alternate-grid\"\n          }, r[c].render(), r[c].isActive = !0);\n        }), b._addedPlotLB || ((g.plotLines || []).concat(g.plotBands || []).forEach(function (a) {\n          b.addPlotBandOrLine(a);\n        }), b._addedPlotLB = !0);\n        [u, l, r].forEach(function (b) {\n          var c,\n              k = [],\n              d = w.duration;\n          B(b, function (b, a) {\n            b.isActive || (b.render(a, !1, 0), b.isActive = !1, k.push(a));\n          });\n          Q(function () {\n            for (c = k.length; c--;) b[k[c]] && !b[k[c]].isActive && (b[k[c]].destroy(), delete b[k[c]]);\n          }, b !== r && a.hasRendered && d ? d : 0);\n        });\n        h && (h[h.isPlaced ? \"animate\" : \"attr\"]({\n          d: this.getLinePath(h.strokeWidth())\n        }), h.isPlaced = !0, h[G ? \"show\" : \"hide\"](G));\n        e && G && (g = b.getTitlePosition(), c(g.y) ? (e[e.isNew ? \"attr\" : \"animate\"](g), e.isNew = !1) : (e.attr(\"y\", -9999), e.isNew = !0));\n        n && n.enabled && b.stacking && b.stacking.renderStackTotals();\n        b.isDirty = !1;\n        J(this, \"afterRender\");\n      };\n\n      u.prototype.redraw = function () {\n        this.visible && (this.render(), this.plotLinesAndBands.forEach(function (b) {\n          b.render();\n        }));\n        this.series.forEach(function (b) {\n          b.isDirty = !0;\n        });\n      };\n\n      u.prototype.getKeepProps = function () {\n        return this.keepProps || u.keepProps;\n      };\n\n      u.prototype.destroy = function (b) {\n        var a = this,\n            c = a.plotLinesAndBands,\n            d;\n        J(this, \"destroy\", {\n          keepEvents: b\n        });\n        b || M(a);\n        [a.ticks, a.minorTicks, a.alternateBands].forEach(function (b) {\n          D(b);\n        });\n        if (c) for (b = c.length; b--;) c[b].destroy();\n        \"axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar\".split(\" \").forEach(function (b) {\n          a[b] && (a[b] = a[b].destroy());\n        });\n\n        for (d in a.plotLinesAndBandsGroups) a.plotLinesAndBandsGroups[d] = a.plotLinesAndBandsGroups[d].destroy();\n\n        B(a, function (b, c) {\n          -1 === a.getKeepProps().indexOf(c) && delete a[c];\n        });\n      };\n\n      u.prototype.drawCrosshair = function (b, a) {\n        var c = this.crosshair,\n            k = A(c.snap, !0),\n            d,\n            g = this.cross,\n            p = this.chart;\n        J(this, \"drawCrosshair\", {\n          e: b,\n          point: a\n        });\n        b || (b = this.cross && this.cross.e);\n\n        if (this.crosshair && !1 !== (x(a) || !k)) {\n          k ? x(a) && (d = A(\"colorAxis\" !== this.coll ? a.crosshairPos : null, this.isXAxis ? a.plotX : this.len - a.plotY)) : d = b && (this.horiz ? b.chartX - this.pos : this.len - b.chartY + this.pos);\n\n          if (x(d)) {\n            var q = {\n              value: a && (this.isXAxis ? a.x : A(a.stackY, a.y)),\n              translatedValue: d\n            };\n            p.polar && l(q, {\n              isCrosshair: !0,\n              chartX: b && b.chartX,\n              chartY: b && b.chartY,\n              point: a\n            });\n            q = this.getPlotLinePath(q) || null;\n          }\n\n          if (!x(q)) {\n            this.hideCrosshair();\n            return;\n          }\n\n          k = this.categories && !this.isRadial;\n          g || (this.cross = g = p.renderer.path().addClass(\"highcharts-crosshair highcharts-crosshair-\" + (k ? \"category \" : \"thin \") + c.className).attr({\n            zIndex: A(c.zIndex, 2)\n          }).add(), p.styledMode || (g.attr({\n            stroke: c.color || (k ? h.parse(\"#ccd6eb\").setOpacity(.25).get() : \"#cccccc\"),\n            \"stroke-width\": A(c.width, 1)\n          }).css({\n            \"pointer-events\": \"none\"\n          }), c.dashStyle && g.attr({\n            dashstyle: c.dashStyle\n          })));\n          g.show().attr({\n            d: q\n          });\n          k && !c.width && g.attr({\n            \"stroke-width\": this.transA\n          });\n          this.cross.e = b;\n        } else this.hideCrosshair();\n\n        J(this, \"afterDrawCrosshair\", {\n          e: b,\n          point: a\n        });\n      };\n\n      u.prototype.hideCrosshair = function () {\n        this.cross && this.cross.hide();\n        J(this, \"afterHideCrosshair\");\n      };\n\n      u.prototype.hasVerticalPanning = function () {\n        var b, a;\n        return /y/.test((null === (a = null === (b = this.chart.options.chart) || void 0 === b ? void 0 : b.panning) || void 0 === a ? void 0 : a.type) || \"\");\n      };\n\n      u.prototype.validatePositiveValue = function (b) {\n        return c(b) && 0 < b;\n      };\n\n      u.defaultOptions = {\n        dateTimeLabelFormats: {\n          millisecond: {\n            main: \"%H:%M:%S.%L\",\n            range: !1\n          },\n          second: {\n            main: \"%H:%M:%S\",\n            range: !1\n          },\n          minute: {\n            main: \"%H:%M\",\n            range: !1\n          },\n          hour: {\n            main: \"%H:%M\",\n            range: !1\n          },\n          day: {\n            main: \"%e. %b\"\n          },\n          week: {\n            main: \"%e. %b\"\n          },\n          month: {\n            main: \"%b '%y\"\n          },\n          year: {\n            main: \"%Y\"\n          }\n        },\n        endOnTick: !1,\n        labels: {\n          enabled: !0,\n          indentation: 10,\n          x: 0,\n          style: {\n            color: \"#666666\",\n            cursor: \"default\",\n            fontSize: \"11px\"\n          }\n        },\n        maxPadding: .01,\n        minorTickLength: 2,\n        minorTickPosition: \"outside\",\n        minPadding: .01,\n        showEmpty: !0,\n        startOfWeek: 1,\n        startOnTick: !1,\n        tickLength: 10,\n        tickPixelInterval: 100,\n        tickmarkPlacement: \"between\",\n        tickPosition: \"outside\",\n        title: {\n          align: \"middle\",\n          style: {\n            color: \"#666666\"\n          }\n        },\n        type: \"linear\",\n        minorGridLineColor: \"#f2f2f2\",\n        minorGridLineWidth: 1,\n        minorTickColor: \"#999999\",\n        lineColor: \"#ccd6eb\",\n        lineWidth: 1,\n        gridLineColor: \"#e6e6e6\",\n        tickColor: \"#ccd6eb\"\n      };\n      u.defaultYAxisOptions = {\n        endOnTick: !0,\n        maxPadding: .05,\n        minPadding: .05,\n        tickPixelInterval: 72,\n        showLastLabel: !0,\n        labels: {\n          x: -8\n        },\n        startOnTick: !0,\n        title: {\n          rotation: 270,\n          text: \"Values\"\n        },\n        stackLabels: {\n          animation: {},\n          allowOverlap: !1,\n          enabled: !1,\n          crop: !0,\n          overflow: \"justify\",\n          formatter: function () {\n            var b = this.axis.chart.numberFormatter;\n            return b(this.total, -1);\n          },\n          style: {\n            color: \"#000000\",\n            fontSize: \"11px\",\n            fontWeight: \"bold\",\n            textOutline: \"1px contrast\"\n          }\n        },\n        gridLineWidth: 1,\n        lineWidth: 0\n      };\n      u.defaultLeftAxisOptions = {\n        labels: {\n          x: -15\n        },\n        title: {\n          rotation: 270\n        }\n      };\n      u.defaultRightAxisOptions = {\n        labels: {\n          x: 15\n        },\n        title: {\n          rotation: 90\n        }\n      };\n      u.defaultBottomAxisOptions = {\n        labels: {\n          autoRotation: [-45],\n          x: 0\n        },\n        margin: 15,\n        title: {\n          rotation: 0\n        }\n      };\n      u.defaultTopAxisOptions = {\n        labels: {\n          autoRotation: [-45],\n          x: 0\n        },\n        margin: 15,\n        title: {\n          rotation: 0\n        }\n      };\n      u.keepProps = \"extKey hcEvents names series userMax userMin\".split(\" \");\n      return u;\n    }();\n\n    m.Axis = f;\n    return m.Axis;\n  });\n  N(m, \"Core/Axis/DateTimeAxis.js\", [m[\"Core/Axis/Axis.js\"], m[\"Core/Utilities.js\"]], function (f, h) {\n    var m = h.addEvent,\n        z = h.getMagnitude,\n        F = h.normalizeTickInterval,\n        L = h.timeUnits,\n        K = function () {\n      function f(f) {\n        this.axis = f;\n      }\n\n      f.prototype.normalizeTimeTickInterval = function (f, e) {\n        var h = e || [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1, 2]], [\"week\", [1, 2]], [\"month\", [1, 2, 3, 4, 6]], [\"year\", null]];\n        e = h[h.length - 1];\n        var v = L[e[0]],\n            x = e[1],\n            D;\n\n        for (D = 0; D < h.length && !(e = h[D], v = L[e[0]], x = e[1], h[D + 1] && f <= (v * x[x.length - 1] + L[h[D + 1][0]]) / 2); D++);\n\n        v === L.year && f < 5 * v && (x = [1, 2, 5]);\n        f = F(f / v, x, \"year\" === e[0] ? Math.max(z(f / v), 1) : 1);\n        return {\n          unitRange: v,\n          count: f,\n          unitName: e[0]\n        };\n      };\n\n      return f;\n    }();\n\n    h = function () {\n      function f() {}\n\n      f.compose = function (f) {\n        f.keepProps.push(\"dateTime\");\n\n        f.prototype.getTimeTicks = function () {\n          return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);\n        };\n\n        m(f, \"init\", function (e) {\n          \"datetime\" !== e.userOptions.type ? this.dateTime = void 0 : this.dateTime || (this.dateTime = new K(this));\n        });\n      };\n\n      f.AdditionsClass = K;\n      return f;\n    }();\n\n    h.compose(f);\n    return h;\n  });\n  N(m, \"Core/Axis/LogarithmicAxis.js\", [m[\"Core/Axis/Axis.js\"], m[\"Core/Utilities.js\"]], function (f, h) {\n    var m = h.addEvent,\n        z = h.getMagnitude,\n        F = h.normalizeTickInterval,\n        L = h.pick,\n        K = function () {\n      function f(f) {\n        this.axis = f;\n      }\n\n      f.prototype.getLogTickPositions = function (f, e, h, v) {\n        var x = this.axis,\n            D = x.len,\n            n = x.options,\n            l = [];\n        v || (this.minorAutoInterval = void 0);\n        if (.5 <= f) f = Math.round(f), l = x.getLinearTickPositions(f, e, h);else if (.08 <= f) {\n          n = Math.floor(e);\n          var m, w;\n\n          for (D = .3 < f ? [1, 2, 4] : .15 < f ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; n < h + 1 && !w; n++) {\n            var r = D.length;\n\n            for (m = 0; m < r && !w; m++) {\n              var d = this.log2lin(this.lin2log(n) * D[m]);\n              d > e && (!v || g <= h) && \"undefined\" !== typeof g && l.push(g);\n              g > h && (w = !0);\n              var g = d;\n            }\n          }\n        } else e = this.lin2log(e), h = this.lin2log(h), f = v ? x.getMinorTickInterval() : n.tickInterval, f = L(\"auto\" === f ? null : f, this.minorAutoInterval, n.tickPixelInterval / (v ? 5 : 1) * (h - e) / ((v ? D / x.tickPositions.length : D) || 1)), f = F(f, void 0, z(f)), l = x.getLinearTickPositions(f, e, h).map(this.log2lin), v || (this.minorAutoInterval = f / 5);\n        v || (x.tickInterval = f);\n        return l;\n      };\n\n      f.prototype.lin2log = function (f) {\n        return Math.pow(10, f);\n      };\n\n      f.prototype.log2lin = function (f) {\n        return Math.log(f) / Math.LN10;\n      };\n\n      return f;\n    }();\n\n    h = function () {\n      function f() {}\n\n      f.compose = function (f) {\n        f.keepProps.push(\"logarithmic\");\n        var e = f.prototype,\n            h = K.prototype;\n        e.log2lin = h.log2lin;\n        e.lin2log = h.lin2log;\n        m(f, \"init\", function (e) {\n          var f = this.logarithmic;\n          \"logarithmic\" !== e.userOptions.type ? this.logarithmic = void 0 : (f || (f = this.logarithmic = new K(this)), this.log2lin !== f.log2lin && (f.log2lin = this.log2lin.bind(this)), this.lin2log !== f.lin2log && (f.lin2log = this.lin2log.bind(this)));\n        });\n        m(f, \"afterInit\", function () {\n          var e = this.logarithmic;\n          e && (this.lin2val = function (f) {\n            return e.lin2log(f);\n          }, this.val2lin = function (f) {\n            return e.log2lin(f);\n          });\n        });\n      };\n\n      return f;\n    }();\n\n    h.compose(f);\n    return h;\n  });\n  N(m, \"Core/Axis/PlotLineOrBand.js\", [m[\"Core/Axis/Axis.js\"], m[\"Core/Globals.js\"], m[\"Core/Utilities.js\"]], function (f, h, m) {\n    var z = m.arrayMax,\n        F = m.arrayMin,\n        P = m.defined,\n        K = m.destroyObjectProperties,\n        C = m.erase,\n        y = m.extend,\n        e = m.merge,\n        I = m.objectEach,\n        v = m.pick;\n\n    m = function () {\n      function f(e, f) {\n        this.axis = e;\n        f && (this.options = f, this.id = f.id);\n      }\n\n      f.prototype.render = function () {\n        h.fireEvent(this, \"render\");\n        var f = this,\n            n = f.axis,\n            l = n.horiz,\n            m = n.logarithmic,\n            w = f.options,\n            r = w.label,\n            d = f.label,\n            g = w.to,\n            c = w.from,\n            a = w.value,\n            q = P(c) && P(g),\n            p = P(a),\n            B = f.svgElem,\n            A = !B,\n            G = [],\n            M = w.color,\n            x = v(w.zIndex, 0),\n            Q = w.events;\n        G = {\n          \"class\": \"highcharts-plot-\" + (q ? \"band \" : \"line \") + (w.className || \"\")\n        };\n        var O = {},\n            E = n.chart.renderer,\n            u = q ? \"bands\" : \"lines\";\n        m && (c = m.log2lin(c), g = m.log2lin(g), a = m.log2lin(a));\n        n.chart.styledMode || (p ? (G.stroke = M || \"#999999\", G[\"stroke-width\"] = v(w.width, 1), w.dashStyle && (G.dashstyle = w.dashStyle)) : q && (G.fill = M || \"#e6ebf5\", w.borderWidth && (G.stroke = w.borderColor, G[\"stroke-width\"] = w.borderWidth)));\n        O.zIndex = x;\n        u += \"-\" + x;\n        (m = n.plotLinesAndBandsGroups[u]) || (n.plotLinesAndBandsGroups[u] = m = E.g(\"plot-\" + u).attr(O).add());\n        A && (f.svgElem = B = E.path().attr(G).add(m));\n        if (p) G = n.getPlotLinePath({\n          value: a,\n          lineWidth: B.strokeWidth(),\n          acrossPanes: w.acrossPanes\n        });else if (q) G = n.getPlotBandPath(c, g, w);else return;\n        !f.eventsAdded && Q && (I(Q, function (b, a) {\n          B.on(a, function (b) {\n            Q[a].apply(f, [b]);\n          });\n        }), f.eventsAdded = !0);\n        (A || !B.d) && G && G.length ? B.attr({\n          d: G\n        }) : B && (G ? (B.show(!0), B.animate({\n          d: G\n        })) : B.d && (B.hide(), d && (f.label = d = d.destroy())));\n        r && (P(r.text) || P(r.formatter)) && G && G.length && 0 < n.width && 0 < n.height && !G.isFlat ? (r = e({\n          align: l && q && \"center\",\n          x: l ? !q && 4 : 10,\n          verticalAlign: !l && q && \"middle\",\n          y: l ? q ? 16 : 10 : q ? 6 : -4,\n          rotation: l && !q && 90\n        }, r), this.renderLabel(r, G, q, x)) : d && d.hide();\n        return f;\n      };\n\n      f.prototype.renderLabel = function (e, f, l, h) {\n        var n = this.label,\n            r = this.axis.chart.renderer;\n        n || (n = {\n          align: e.textAlign || e.align,\n          rotation: e.rotation,\n          \"class\": \"highcharts-plot-\" + (l ? \"band\" : \"line\") + \"-label \" + (e.className || \"\")\n        }, n.zIndex = h, h = this.getLabelText(e), this.label = n = r.text(h, 0, 0, e.useHTML).attr(n).add(), this.axis.chart.styledMode || n.css(e.style));\n        r = f.xBounds || [f[0][1], f[1][1], l ? f[2][1] : f[0][1]];\n        f = f.yBounds || [f[0][2], f[1][2], l ? f[2][2] : f[0][2]];\n        l = F(r);\n        h = F(f);\n        n.align(e, !1, {\n          x: l,\n          y: h,\n          width: z(r) - l,\n          height: z(f) - h\n        });\n        n.show(!0);\n      };\n\n      f.prototype.getLabelText = function (e) {\n        return P(e.formatter) ? e.formatter.call(this) : e.text;\n      };\n\n      f.prototype.destroy = function () {\n        C(this.axis.plotLinesAndBands, this);\n        delete this.axis;\n        K(this);\n      };\n\n      return f;\n    }();\n\n    y(f.prototype, {\n      getPlotBandPath: function (e, f, n) {\n        void 0 === n && (n = this.options);\n        var l = this.getPlotLinePath({\n          value: f,\n          force: !0,\n          acrossPanes: n.acrossPanes\n        });\n        n = this.getPlotLinePath({\n          value: e,\n          force: !0,\n          acrossPanes: n.acrossPanes\n        });\n        var h = [],\n            w = this.horiz,\n            r = 1;\n        e = e < this.min && f < this.min || e > this.max && f > this.max;\n\n        if (n && l) {\n          if (e) {\n            var d = n.toString() === l.toString();\n            r = 0;\n          }\n\n          for (e = 0; e < n.length; e += 2) {\n            f = n[e];\n            var g = n[e + 1],\n                c = l[e],\n                a = l[e + 1];\n            \"M\" !== f[0] && \"L\" !== f[0] || \"M\" !== g[0] && \"L\" !== g[0] || \"M\" !== c[0] && \"L\" !== c[0] || \"M\" !== a[0] && \"L\" !== a[0] || (w && c[1] === f[1] ? (c[1] += r, a[1] += r) : w || c[2] !== f[2] || (c[2] += r, a[2] += r), h.push([\"M\", f[1], f[2]], [\"L\", g[1], g[2]], [\"L\", a[1], a[2]], [\"L\", c[1], c[2]], [\"Z\"]));\n            h.isFlat = d;\n          }\n        }\n\n        return h;\n      },\n      addPlotBand: function (e) {\n        return this.addPlotBandOrLine(e, \"plotBands\");\n      },\n      addPlotLine: function (e) {\n        return this.addPlotBandOrLine(e, \"plotLines\");\n      },\n      addPlotBandOrLine: function (e, f) {\n        var n = new h.PlotLineOrBand(this, e),\n            l = this.userOptions;\n        this.visible && (n = n.render());\n\n        if (n) {\n          if (f) {\n            var v = l[f] || [];\n            v.push(e);\n            l[f] = v;\n          }\n\n          this.plotLinesAndBands.push(n);\n          this._addedPlotLB = !0;\n        }\n\n        return n;\n      },\n      removePlotBandOrLine: function (e) {\n        for (var f = this.plotLinesAndBands, n = this.options, l = this.userOptions, h = f.length; h--;) f[h].id === e && f[h].destroy();\n\n        [n.plotLines || [], l.plotLines || [], n.plotBands || [], l.plotBands || []].forEach(function (f) {\n          for (h = f.length; h--;) (f[h] || {}).id === e && C(f, f[h]);\n        });\n      },\n      removePlotBand: function (e) {\n        this.removePlotBandOrLine(e);\n      },\n      removePlotLine: function (e) {\n        this.removePlotBandOrLine(e);\n      }\n    });\n    h.PlotLineOrBand = m;\n    return h.PlotLineOrBand;\n  });\n  N(m, \"Core/Tooltip.js\", [m[\"Core/Globals.js\"], m[\"Core/Utilities.js\"]], function (f, h) {\n    var m = f.doc,\n        z = h.clamp,\n        F = h.css,\n        L = h.defined,\n        K = h.discardElement,\n        C = h.extend,\n        y = h.fireEvent,\n        e = h.format,\n        I = h.isNumber,\n        v = h.isString,\n        x = h.merge,\n        D = h.pick,\n        n = h.splat,\n        l = h.syncTimeout,\n        J = h.timeUnits;\n    \"\";\n\n    var w = function () {\n      function r(d, g) {\n        this.container = void 0;\n        this.crosshairs = [];\n        this.distance = 0;\n        this.isHidden = !0;\n        this.isSticky = !1;\n        this.now = {};\n        this.options = {};\n        this.outside = !1;\n        this.chart = d;\n        this.init(d, g);\n      }\n\n      r.prototype.applyFilter = function () {\n        var d = this.chart;\n        d.renderer.definition({\n          tagName: \"filter\",\n          id: \"drop-shadow-\" + d.index,\n          opacity: .5,\n          children: [{\n            tagName: \"feGaussianBlur\",\n            \"in\": \"SourceAlpha\",\n            stdDeviation: 1\n          }, {\n            tagName: \"feOffset\",\n            dx: 1,\n            dy: 1\n          }, {\n            tagName: \"feComponentTransfer\",\n            children: [{\n              tagName: \"feFuncA\",\n              type: \"linear\",\n              slope: .3\n            }]\n          }, {\n            tagName: \"feMerge\",\n            children: [{\n              tagName: \"feMergeNode\"\n            }, {\n              tagName: \"feMergeNode\",\n              \"in\": \"SourceGraphic\"\n            }]\n          }]\n        });\n        d.renderer.definition({\n          tagName: \"style\",\n          textContent: \".highcharts-tooltip-\" + d.index + \"{filter:url(#drop-shadow-\" + d.index + \")}\"\n        });\n      };\n\n      r.prototype.bodyFormatter = function (d) {\n        return d.map(function (d) {\n          var c = d.series.tooltipOptions;\n          return (c[(d.point.formatPrefix || \"point\") + \"Formatter\"] || d.point.tooltipFormatter).call(d.point, c[(d.point.formatPrefix || \"point\") + \"Format\"] || \"\");\n        });\n      };\n\n      r.prototype.cleanSplit = function (d) {\n        this.chart.series.forEach(function (g) {\n          var c = g && g.tt;\n          c && (!c.isActive || d ? g.tt = c.destroy() : c.isActive = !1);\n        });\n      };\n\n      r.prototype.defaultFormatter = function (d) {\n        var g = this.points || n(this);\n        var c = [d.tooltipFooterHeaderFormatter(g[0])];\n        c = c.concat(d.bodyFormatter(g));\n        c.push(d.tooltipFooterHeaderFormatter(g[0], !0));\n        return c;\n      };\n\n      r.prototype.destroy = function () {\n        this.label && (this.label = this.label.destroy());\n        this.split && this.tt && (this.cleanSplit(this.chart, !0), this.tt = this.tt.destroy());\n        this.renderer && (this.renderer = this.renderer.destroy(), K(this.container));\n        h.clearTimeout(this.hideTimer);\n        h.clearTimeout(this.tooltipTimeout);\n      };\n\n      r.prototype.getAnchor = function (d, g) {\n        var c = this.chart,\n            a = c.pointer,\n            q = c.inverted,\n            p = c.plotTop,\n            e = c.plotLeft,\n            f = 0,\n            l = 0,\n            r,\n            h;\n        d = n(d);\n        this.followPointer && g ? (\"undefined\" === typeof g.chartX && (g = a.normalize(g)), d = [g.chartX - e, g.chartY - p]) : d[0].tooltipPos ? d = d[0].tooltipPos : (d.forEach(function (a) {\n          r = a.series.yAxis;\n          h = a.series.xAxis;\n          f += a.plotX + (!q && h ? h.left - e : 0);\n          l += (a.plotLow ? (a.plotLow + a.plotHigh) / 2 : a.plotY) + (!q && r ? r.top - p : 0);\n        }), f /= d.length, l /= d.length, d = [q ? c.plotWidth - l : f, this.shared && !q && 1 < d.length && g ? g.chartY - p : q ? c.plotHeight - f : l]);\n        return d.map(Math.round);\n      };\n\n      r.prototype.getDateFormat = function (d, g, c, a) {\n        var q = this.chart.time,\n            p = q.dateFormat(\"%m-%d %H:%M:%S.%L\", g),\n            e = {\n          millisecond: 15,\n          second: 12,\n          minute: 9,\n          hour: 6,\n          day: 3\n        },\n            f = \"millisecond\";\n\n        for (l in J) {\n          if (d === J.week && +q.dateFormat(\"%w\", g) === c && \"00:00:00.000\" === p.substr(6)) {\n            var l = \"week\";\n            break;\n          }\n\n          if (J[l] > d) {\n            l = f;\n            break;\n          }\n\n          if (e[l] && p.substr(e[l]) !== \"01-01 00:00:00.000\".substr(e[l])) break;\n          \"week\" !== l && (f = l);\n        }\n\n        if (l) var r = q.resolveDTLFormat(a[l]).main;\n        return r;\n      };\n\n      r.prototype.getLabel = function () {\n        var d,\n            g,\n            c = this,\n            a = this.chart.renderer,\n            q = this.chart.styledMode,\n            p = this.options,\n            e = \"tooltip\" + (L(p.className) ? \" \" + p.className : \"\"),\n            l = (null === (d = p.style) || void 0 === d ? void 0 : d.pointerEvents) || (!this.followPointer && p.stickOnContact ? \"auto\" : \"none\"),\n            r;\n\n        d = function () {\n          c.inContact = !0;\n        };\n\n        var n = function () {\n          var a = c.chart.hoverSeries;\n          c.inContact = !1;\n          if (a && a.onMouseOut) a.onMouseOut();\n        };\n\n        if (!this.label) {\n          this.outside && (this.container = r = f.doc.createElement(\"div\"), r.className = \"highcharts-tooltip-container\", F(r, {\n            position: \"absolute\",\n            top: \"1px\",\n            pointerEvents: l,\n            zIndex: 3\n          }), f.doc.body.appendChild(r), this.renderer = a = new f.Renderer(r, 0, 0, null === (g = this.chart.options.chart) || void 0 === g ? void 0 : g.style, void 0, void 0, a.styledMode));\n          this.split ? this.label = a.g(e) : (this.label = a.label(\"\", 0, 0, p.shape || \"callout\", null, null, p.useHTML, null, e).attr({\n            padding: p.padding,\n            r: p.borderRadius\n          }), q || this.label.attr({\n            fill: p.backgroundColor,\n            \"stroke-width\": p.borderWidth\n          }).css(p.style).css({\n            pointerEvents: l\n          }).shadow(p.shadow));\n          q && (this.applyFilter(), this.label.addClass(\"highcharts-tooltip-\" + this.chart.index));\n\n          if (c.outside && !c.split) {\n            var h = this.label,\n                w = h.xSetter,\n                v = h.ySetter;\n\n            h.xSetter = function (a) {\n              w.call(h, c.distance);\n              r.style.left = a + \"px\";\n            };\n\n            h.ySetter = function (a) {\n              v.call(h, c.distance);\n              r.style.top = a + \"px\";\n            };\n          }\n\n          this.label.on(\"mouseenter\", d).on(\"mouseleave\", n).attr({\n            zIndex: 8\n          }).add();\n        }\n\n        return this.label;\n      };\n\n      r.prototype.getPosition = function (d, g, c) {\n        var a = this.chart,\n            q = this.distance,\n            p = {},\n            e = a.inverted && c.h || 0,\n            f,\n            l = this.outside,\n            r = l ? m.documentElement.clientWidth - 2 * q : a.chartWidth,\n            n = l ? Math.max(m.body.scrollHeight, m.documentElement.scrollHeight, m.body.offsetHeight, m.documentElement.offsetHeight, m.documentElement.clientHeight) : a.chartHeight,\n            h = a.pointer.getChartPosition(),\n            w = a.containerScaling,\n            E = function (b) {\n          return w ? b * w.scaleX : b;\n        },\n            u = function (b) {\n          return w ? b * w.scaleY : b;\n        },\n            b = function (b) {\n          var k = \"x\" === b;\n          return [b, k ? r : n, k ? d : g].concat(l ? [k ? E(d) : u(g), k ? h.left - q + E(c.plotX + a.plotLeft) : h.top - q + u(c.plotY + a.plotTop), 0, k ? r : n] : [k ? d : g, k ? c.plotX + a.plotLeft : c.plotY + a.plotTop, k ? a.plotLeft : a.plotTop, k ? a.plotLeft + a.plotWidth : a.plotTop + a.plotHeight]);\n        },\n            k = b(\"y\"),\n            t = b(\"x\"),\n            H = !this.followPointer && D(c.ttBelow, !a.inverted === !!c.negative),\n            v = function (b, a, c, k, d, g, t) {\n          var f = \"y\" === b ? u(q) : E(q),\n              l = (c - k) / 2,\n              r = k < d - q,\n              B = d + q + k < a,\n              n = d - f - c + l;\n          d = d + f - l;\n          if (H && B) p[b] = d;else if (!H && r) p[b] = n;else if (r) p[b] = Math.min(t - k, 0 > n - e ? n : n - e);else if (B) p[b] = Math.max(g, d + e + c > a ? d : d + e);else return !1;\n        },\n            U = function (b, a, c, k, d) {\n          var g;\n          d < q || d > a - q ? g = !1 : p[b] = d < c / 2 ? 1 : d > a - k / 2 ? a - k - 2 : d - c / 2;\n          return g;\n        },\n            x = function (b) {\n          var a = k;\n          k = t;\n          t = a;\n          f = b;\n        },\n            I = function () {\n          !1 !== v.apply(0, k) ? !1 !== U.apply(0, t) || f || (x(!0), I()) : f ? p.x = p.y = 0 : (x(!0), I());\n        };\n\n        (a.inverted || 1 < this.len) && x();\n        I();\n        return p;\n      };\n\n      r.prototype.getXDateFormat = function (d, g, c) {\n        g = g.dateTimeLabelFormats;\n        var a = c && c.closestPointRange;\n        return (a ? this.getDateFormat(a, d.x, c.options.startOfWeek, g) : g.day) || g.year;\n      };\n\n      r.prototype.hide = function (d) {\n        var g = this;\n        h.clearTimeout(this.hideTimer);\n        d = D(d, this.options.hideDelay, 500);\n        this.isHidden || (this.hideTimer = l(function () {\n          g.getLabel().fadeOut(d ? void 0 : d);\n          g.isHidden = !0;\n        }, d));\n      };\n\n      r.prototype.init = function (d, g) {\n        this.chart = d;\n        this.options = g;\n        this.crosshairs = [];\n        this.now = {\n          x: 0,\n          y: 0\n        };\n        this.isHidden = !0;\n        this.split = g.split && !d.inverted && !d.polar;\n        this.shared = g.shared || this.split;\n        this.outside = D(g.outside, !(!d.scrollablePixelsX && !d.scrollablePixelsY));\n      };\n\n      r.prototype.isStickyOnContact = function () {\n        return !(this.followPointer || !this.options.stickOnContact || !this.inContact);\n      };\n\n      r.prototype.move = function (d, g, c, a) {\n        var q = this,\n            p = q.now,\n            e = !1 !== q.options.animation && !q.isHidden && (1 < Math.abs(d - p.x) || 1 < Math.abs(g - p.y)),\n            f = q.followPointer || 1 < q.len;\n        C(p, {\n          x: e ? (2 * p.x + d) / 3 : d,\n          y: e ? (p.y + g) / 2 : g,\n          anchorX: f ? void 0 : e ? (2 * p.anchorX + c) / 3 : c,\n          anchorY: f ? void 0 : e ? (p.anchorY + a) / 2 : a\n        });\n        q.getLabel().attr(p);\n        q.drawTracker();\n        e && (h.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {\n          q && q.move(d, g, c, a);\n        }, 32));\n      };\n\n      r.prototype.refresh = function (d, g) {\n        var c = this.chart,\n            a = this.options,\n            q = d,\n            p = {},\n            e = [],\n            f = a.formatter || this.defaultFormatter;\n        p = this.shared;\n        var l = c.styledMode;\n\n        if (a.enabled) {\n          h.clearTimeout(this.hideTimer);\n          this.followPointer = n(q)[0].series.tooltipOptions.followPointer;\n          var r = this.getAnchor(q, g);\n          g = r[0];\n          var w = r[1];\n          !p || q.series && q.series.noSharedTooltip ? p = q.getLabelConfig() : (c.pointer.applyInactiveState(q), q.forEach(function (a) {\n            a.setState(\"hover\");\n            e.push(a.getLabelConfig());\n          }), p = {\n            x: q[0].category,\n            y: q[0].y\n          }, p.points = e, q = q[0]);\n          this.len = e.length;\n          c = f.call(p, this);\n          f = q.series;\n          this.distance = D(f.tooltipOptions.distance, 16);\n          !1 === c ? this.hide() : (this.split ? this.renderSplit(c, n(d)) : (d = this.getLabel(), a.style.width && !l || d.css({\n            width: this.chart.spacingBox.width + \"px\"\n          }), d.attr({\n            text: c && c.join ? c.join(\"\") : c\n          }), d.removeClass(/highcharts-color-[\\d]+/g).addClass(\"highcharts-color-\" + D(q.colorIndex, f.colorIndex)), l || d.attr({\n            stroke: a.borderColor || q.color || f.color || \"#666666\"\n          }), this.updatePosition({\n            plotX: g,\n            plotY: w,\n            negative: q.negative,\n            ttBelow: q.ttBelow,\n            h: r[2] || 0\n          })), this.isHidden && this.label && this.label.attr({\n            opacity: 1\n          }).show(), this.isHidden = !1);\n          y(this, \"refresh\");\n        }\n      };\n\n      r.prototype.renderSplit = function (d, g) {\n        function c(b, a, c, d, g) {\n          void 0 === g && (g = !0);\n          c ? (a = I ? 0 : F, b = z(b - d / 2, m.left, m.right - d)) : (a -= y, b = g ? b - d - k : b + k, b = z(b, g ? b : m.left, m.right));\n          return {\n            x: b,\n            y: a\n          };\n        }\n\n        var a = this,\n            q = a.chart,\n            p = a.chart,\n            e = p.plotHeight,\n            l = p.plotLeft,\n            r = p.plotTop,\n            n = p.pointer,\n            h = p.renderer,\n            w = p.scrollablePixelsY,\n            O = void 0 === w ? 0 : w;\n        w = p.scrollingContainer;\n        w = void 0 === w ? {\n          scrollLeft: 0,\n          scrollTop: 0\n        } : w;\n        var E = w.scrollLeft,\n            u = w.scrollTop,\n            b = p.styledMode,\n            k = a.distance,\n            t = a.options,\n            H = a.options.positioner,\n            m = {\n          left: E,\n          right: E + p.chartWidth,\n          top: u,\n          bottom: u + p.chartHeight\n        },\n            x = a.getLabel(),\n            I = !(!q.xAxis[0] || !q.xAxis[0].opposite),\n            y = r + u,\n            J = 0,\n            F = e - O;\n        v(d) && (d = [!1, d]);\n        d = d.slice(0, g.length + 1).reduce(function (d, p, q) {\n          if (!1 !== p && \"\" !== p) {\n            q = g[q - 1] || {\n              isHeader: !0,\n              plotX: g[0].plotX,\n              plotY: e,\n              series: {}\n            };\n            var f = q.isHeader,\n                n = f ? a : q.series,\n                B = n.tt,\n                A = q.isHeader;\n            var w = q.series;\n            var E = \"highcharts-color-\" + D(q.colorIndex, w.colorIndex, \"none\");\n            B || (B = {\n              padding: t.padding,\n              r: t.borderRadius\n            }, b || (B.fill = t.backgroundColor, B[\"stroke-width\"] = t.borderWidth), B = h.label(\"\", 0, 0, t[A ? \"headerShape\" : \"shape\"] || \"callout\", void 0, void 0, t.useHTML).addClass((A ? \"highcharts-tooltip-header \" : \"\") + \"highcharts-tooltip-box \" + E).attr(B).add(x));\n            B.isActive = !0;\n            B.attr({\n              text: p\n            });\n            b || B.css(t.style).shadow(t.shadow).attr({\n              stroke: t.borderColor || q.color || w.color || \"#333333\"\n            });\n            p = n.tt = B;\n            A = p.getBBox();\n            n = A.width + p.strokeWidth();\n            f && (J = A.height, F += J, I && (y -= J));\n            w = q.plotX;\n            w = void 0 === w ? 0 : w;\n            E = q.plotY;\n            E = void 0 === E ? 0 : E;\n            var v = q.series;\n\n            if (q.isHeader) {\n              w = l + w;\n              var G = r + e / 2;\n            } else B = v.xAxis, v = v.yAxis, w = B.pos + z(w, -k, B.len + k), v.pos + E >= u + r && v.pos + E <= u + r + e - O && (G = v.pos + E);\n\n            w = z(w, m.left - k, m.right + k);\n            \"number\" === typeof G ? (A = A.height + 1, E = H ? H.call(a, n, A, q) : c(w, G, f, n), d.push({\n              align: H ? 0 : void 0,\n              anchorX: w,\n              anchorY: G,\n              boxWidth: n,\n              point: q,\n              rank: D(E.rank, f ? 1 : 0),\n              size: A,\n              target: E.y,\n              tt: p,\n              x: E.x\n            })) : p.isActive = !1;\n          }\n\n          return d;\n        }, []);\n        !H && d.some(function (b) {\n          return b.x < m.left;\n        }) && (d = d.map(function (b) {\n          var a = c(b.anchorX, b.anchorY, b.point.isHeader, b.boxWidth, !1);\n          return C(b, {\n            target: a.y,\n            x: a.x\n          });\n        }));\n        a.cleanSplit();\n        f.distribute(d, F);\n        d.forEach(function (b) {\n          var a = b.pos;\n          b.tt.attr({\n            visibility: \"undefined\" === typeof a ? \"hidden\" : \"inherit\",\n            x: b.x,\n            y: a + y,\n            anchorX: b.anchorX,\n            anchorY: b.anchorY\n          });\n        });\n        d = a.container;\n        q = a.renderer;\n        a.outside && d && q && (p = x.getBBox(), q.setSize(p.width + p.x, p.height + p.y, !1), n = n.getChartPosition(), d.style.left = n.left + \"px\", d.style.top = n.top + \"px\");\n      };\n\n      r.prototype.drawTracker = function () {\n        if (this.followPointer || !this.options.stickOnContact) this.tracker && this.tracker.destroy();else {\n          var d = this.chart,\n              g = this.label,\n              c = d.hoverPoint;\n\n          if (g && c) {\n            var a = {\n              x: 0,\n              y: 0,\n              width: 0,\n              height: 0\n            };\n            c = this.getAnchor(c);\n            var q = g.getBBox();\n            c[0] += d.plotLeft - g.translateX;\n            c[1] += d.plotTop - g.translateY;\n            a.x = Math.min(0, c[0]);\n            a.y = Math.min(0, c[1]);\n            a.width = 0 > c[0] ? Math.max(Math.abs(c[0]), q.width - c[0]) : Math.max(Math.abs(c[0]), q.width);\n            a.height = 0 > c[1] ? Math.max(Math.abs(c[1]), q.height - Math.abs(c[1])) : Math.max(Math.abs(c[1]), q.height);\n            this.tracker ? this.tracker.attr(a) : (this.tracker = g.renderer.rect(a).addClass(\"highcharts-tracker\").add(g), d.styledMode || this.tracker.attr({\n              fill: \"rgba(0,0,0,0)\"\n            }));\n          }\n        }\n      };\n\n      r.prototype.styledModeFormat = function (d) {\n        return d.replace('style=\"font-size: 10px\"', 'class=\"highcharts-header\"').replace(/style=\"color:{(point|series)\\.color}\"/g, 'class=\"highcharts-color-{$1.colorIndex}\"');\n      };\n\n      r.prototype.tooltipFooterHeaderFormatter = function (d, g) {\n        var c = g ? \"footer\" : \"header\",\n            a = d.series,\n            q = a.tooltipOptions,\n            p = q.xDateFormat,\n            f = a.xAxis,\n            l = f && \"datetime\" === f.options.type && I(d.key),\n            r = q[c + \"Format\"];\n        g = {\n          isFooter: g,\n          labelConfig: d\n        };\n        y(this, \"headerFormatter\", g, function (c) {\n          l && !p && (p = this.getXDateFormat(d, q, f));\n          l && p && (d.point && d.point.tooltipDateKeys || [\"key\"]).forEach(function (a) {\n            r = r.replace(\"{point.\" + a + \"}\", \"{point.\" + a + \":\" + p + \"}\");\n          });\n          a.chart.styledMode && (r = this.styledModeFormat(r));\n          c.text = e(r, {\n            point: d,\n            series: a\n          }, this.chart);\n        });\n        return g.text;\n      };\n\n      r.prototype.update = function (d) {\n        this.destroy();\n        x(!0, this.chart.options.tooltip.userOptions, d);\n        this.init(this.chart, x(!0, this.options, d));\n      };\n\n      r.prototype.updatePosition = function (d) {\n        var g = this.chart,\n            c = g.pointer,\n            a = this.getLabel(),\n            q = d.plotX + g.plotLeft,\n            p = d.plotY + g.plotTop;\n        c = c.getChartPosition();\n        d = (this.options.positioner || this.getPosition).call(this, a.width, a.height, d);\n\n        if (this.outside) {\n          var e = (this.options.borderWidth || 0) + 2 * this.distance;\n          this.renderer.setSize(a.width + e, a.height + e, !1);\n          if (g = g.containerScaling) F(this.container, {\n            transform: \"scale(\" + g.scaleX + \", \" + g.scaleY + \")\"\n          }), q *= g.scaleX, p *= g.scaleY;\n          q += c.left - d.x;\n          p += c.top - d.y;\n        }\n\n        this.move(Math.round(d.x), Math.round(d.y || 0), q, p);\n      };\n\n      return r;\n    }();\n\n    f.Tooltip = w;\n    return f.Tooltip;\n  });\n  N(m, \"Core/Pointer.js\", [m[\"Core/Color/Color.js\"], m[\"Core/Globals.js\"], m[\"Core/Tooltip.js\"], m[\"Core/Utilities.js\"]], function (f, h, m, z) {\n    var F = f.parse,\n        P = h.charts,\n        K = h.noop,\n        C = z.addEvent,\n        y = z.attr,\n        e = z.css,\n        I = z.defined,\n        v = z.extend,\n        x = z.find,\n        D = z.fireEvent,\n        n = z.isNumber,\n        l = z.isObject,\n        J = z.objectEach,\n        w = z.offset,\n        r = z.pick,\n        d = z.splat;\n    \"\";\n\n    f = function () {\n      function g(c, a) {\n        this.lastValidTouch = {};\n        this.pinchDown = [];\n        this.runChartClick = !1;\n        this.chart = c;\n        this.hasDragged = !1;\n        this.options = a;\n\n        this.unbindContainerMouseLeave = function () {};\n\n        this.unbindContainerMouseEnter = function () {};\n\n        this.init(c, a);\n      }\n\n      g.prototype.applyInactiveState = function (c) {\n        var a = [],\n            d;\n        (c || []).forEach(function (c) {\n          d = c.series;\n          a.push(d);\n          d.linkedParent && a.push(d.linkedParent);\n          d.linkedSeries && (a = a.concat(d.linkedSeries));\n          d.navigatorSeries && a.push(d.navigatorSeries);\n        });\n        this.chart.series.forEach(function (c) {\n          -1 === a.indexOf(c) ? c.setState(\"inactive\", !0) : c.options.inactiveOtherPoints && c.setAllPointsToState(\"inactive\");\n        });\n      };\n\n      g.prototype.destroy = function () {\n        var c = this;\n        \"undefined\" !== typeof c.unDocMouseMove && c.unDocMouseMove();\n        this.unbindContainerMouseLeave();\n        h.chartCount || (h.unbindDocumentMouseUp && (h.unbindDocumentMouseUp = h.unbindDocumentMouseUp()), h.unbindDocumentTouchEnd && (h.unbindDocumentTouchEnd = h.unbindDocumentTouchEnd()));\n        clearInterval(c.tooltipTimeout);\n        J(c, function (a, d) {\n          c[d] = void 0;\n        });\n      };\n\n      g.prototype.drag = function (c) {\n        var a = this.chart,\n            d = a.options.chart,\n            g = c.chartX,\n            e = c.chartY,\n            f = this.zoomHor,\n            r = this.zoomVert,\n            n = a.plotLeft,\n            h = a.plotTop,\n            w = a.plotWidth,\n            v = a.plotHeight,\n            E = this.selectionMarker,\n            u = this.mouseDownX || 0,\n            b = this.mouseDownY || 0,\n            k = l(d.panning) ? d.panning && d.panning.enabled : d.panning,\n            t = d.panKey && c[d.panKey + \"Key\"];\n        if (!E || !E.touch) if (g < n ? g = n : g > n + w && (g = n + w), e < h ? e = h : e > h + v && (e = h + v), this.hasDragged = Math.sqrt(Math.pow(u - g, 2) + Math.pow(b - e, 2)), 10 < this.hasDragged) {\n          var H = a.isInsidePlot(u - n, b - h);\n          a.hasCartesianSeries && (this.zoomX || this.zoomY) && H && !t && !E && (this.selectionMarker = E = a.renderer.rect(n, h, f ? 1 : w, r ? 1 : v, 0).attr({\n            \"class\": \"highcharts-selection-marker\",\n            zIndex: 7\n          }).add(), a.styledMode || E.attr({\n            fill: d.selectionMarkerFill || F(\"#335cad\").setOpacity(.25).get()\n          }));\n          E && f && (g -= u, E.attr({\n            width: Math.abs(g),\n            x: (0 < g ? 0 : g) + u\n          }));\n          E && r && (g = e - b, E.attr({\n            height: Math.abs(g),\n            y: (0 < g ? 0 : g) + b\n          }));\n          H && !E && k && a.pan(c, d.panning);\n        }\n      };\n\n      g.prototype.dragStart = function (c) {\n        var a = this.chart;\n        a.mouseIsDown = c.type;\n        a.cancelClick = !1;\n        a.mouseDownX = this.mouseDownX = c.chartX;\n        a.mouseDownY = this.mouseDownY = c.chartY;\n      };\n\n      g.prototype.drop = function (c) {\n        var a = this,\n            d = this.chart,\n            g = this.hasPinched;\n\n        if (this.selectionMarker) {\n          var f = {\n            originalEvent: c,\n            xAxis: [],\n            yAxis: []\n          },\n              l = this.selectionMarker,\n              r = l.attr ? l.attr(\"x\") : l.x,\n              h = l.attr ? l.attr(\"y\") : l.y,\n              w = l.attr ? l.attr(\"width\") : l.width,\n              m = l.attr ? l.attr(\"height\") : l.height,\n              O;\n          if (this.hasDragged || g) d.axes.forEach(function (d) {\n            if (d.zoomEnabled && I(d.min) && (g || a[{\n              xAxis: \"zoomX\",\n              yAxis: \"zoomY\"\n            }[d.coll]]) && n(r) && n(h)) {\n              var p = d.horiz,\n                  b = \"touchend\" === c.type ? d.minPixelPadding : 0,\n                  k = d.toValue((p ? r : h) + b);\n              p = d.toValue((p ? r + w : h + m) - b);\n              f[d.coll].push({\n                axis: d,\n                min: Math.min(k, p),\n                max: Math.max(k, p)\n              });\n              O = !0;\n            }\n          }), O && D(d, \"selection\", f, function (a) {\n            d.zoom(v(a, g ? {\n              animation: !1\n            } : null));\n          });\n          n(d.index) && (this.selectionMarker = this.selectionMarker.destroy());\n          g && this.scaleGroups();\n        }\n\n        d && n(d.index) && (e(d.container, {\n          cursor: d._cursor\n        }), d.cancelClick = 10 < this.hasDragged, d.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);\n      };\n\n      g.prototype.findNearestKDPoint = function (c, a, d) {\n        var g = this.chart,\n            q = g.hoverPoint;\n        g = g.tooltip;\n        if (q && g && g.isStickyOnContact()) return q;\n        var e;\n        c.forEach(function (c) {\n          var g = !(c.noSharedTooltip && a) && 0 > c.options.findNearestPointBy.indexOf(\"y\");\n          c = c.searchPoint(d, g);\n\n          if ((g = l(c, !0)) && !(g = !l(e, !0))) {\n            g = e.distX - c.distX;\n            var p = e.dist - c.dist,\n                q = (c.series.group && c.series.group.zIndex) - (e.series.group && e.series.group.zIndex);\n            g = 0 < (0 !== g && a ? g : 0 !== p ? p : 0 !== q ? q : e.series.index > c.series.index ? -1 : 1);\n          }\n\n          g && (e = c);\n        });\n        return e;\n      };\n\n      g.prototype.getChartCoordinatesFromPoint = function (c, a) {\n        var d = c.series,\n            g = d.xAxis;\n        d = d.yAxis;\n        var e = r(c.clientX, c.plotX),\n            f = c.shapeArgs;\n        if (g && d) return a ? {\n          chartX: g.len + g.pos - e,\n          chartY: d.len + d.pos - c.plotY\n        } : {\n          chartX: e + g.pos,\n          chartY: c.plotY + d.pos\n        };\n        if (f && f.x && f.y) return {\n          chartX: f.x,\n          chartY: f.y\n        };\n      };\n\n      g.prototype.getChartPosition = function () {\n        return this.chartPosition || (this.chartPosition = w(this.chart.container));\n      };\n\n      g.prototype.getCoordinates = function (c) {\n        var a = {\n          xAxis: [],\n          yAxis: []\n        };\n        this.chart.axes.forEach(function (d) {\n          a[d.isXAxis ? \"xAxis\" : \"yAxis\"].push({\n            axis: d,\n            value: d.toValue(c[d.horiz ? \"chartX\" : \"chartY\"])\n          });\n        });\n        return a;\n      };\n\n      g.prototype.getHoverData = function (c, a, d, g, e, f) {\n        var p,\n            q = [];\n        g = !(!g || !c);\n        var n = a && !a.stickyTracking,\n            h = {\n          chartX: f ? f.chartX : void 0,\n          chartY: f ? f.chartY : void 0,\n          shared: e\n        };\n        D(this, \"beforeGetHoverData\", h);\n        n = n ? [a] : d.filter(function (a) {\n          return h.filter ? h.filter(a) : a.visible && !(!e && a.directTouch) && r(a.options.enableMouseTracking, !0) && a.stickyTracking;\n        });\n        a = (p = g || !f ? c : this.findNearestKDPoint(n, e, f)) && p.series;\n        p && (e && !a.noSharedTooltip ? (n = d.filter(function (a) {\n          return h.filter ? h.filter(a) : a.visible && !(!e && a.directTouch) && r(a.options.enableMouseTracking, !0) && !a.noSharedTooltip;\n        }), n.forEach(function (a) {\n          var c = x(a.points, function (a) {\n            return a.x === p.x && !a.isNull;\n          });\n          l(c) && (a.chart.isBoosting && (c = a.getPoint(c)), q.push(c));\n        })) : q.push(p));\n        h = {\n          hoverPoint: p\n        };\n        D(this, \"afterGetHoverData\", h);\n        return {\n          hoverPoint: h.hoverPoint,\n          hoverSeries: a,\n          hoverPoints: q\n        };\n      };\n\n      g.prototype.getPointFromEvent = function (c) {\n        c = c.target;\n\n        for (var a; c && !a;) a = c.point, c = c.parentNode;\n\n        return a;\n      };\n\n      g.prototype.onTrackerMouseOut = function (c) {\n        c = c.relatedTarget || c.toElement;\n        var a = this.chart.hoverSeries;\n        this.isDirectTouch = !1;\n        if (!(!a || !c || a.stickyTracking || this.inClass(c, \"highcharts-tooltip\") || this.inClass(c, \"highcharts-series-\" + a.index) && this.inClass(c, \"highcharts-tracker\"))) a.onMouseOut();\n      };\n\n      g.prototype.inClass = function (c, a) {\n        for (var d; c;) {\n          if (d = y(c, \"class\")) {\n            if (-1 !== d.indexOf(a)) return !0;\n            if (-1 !== d.indexOf(\"highcharts-container\")) return !1;\n          }\n\n          c = c.parentNode;\n        }\n      };\n\n      g.prototype.init = function (c, a) {\n        this.options = a;\n        this.chart = c;\n        this.runChartClick = a.chart.events && !!a.chart.events.click;\n        this.pinchDown = [];\n        this.lastValidTouch = {};\n        m && (c.tooltip = new m(c, a.tooltip), this.followTouchMove = r(a.tooltip.followTouchMove, !0));\n        this.setDOMEvents();\n      };\n\n      g.prototype.normalize = function (c, a) {\n        var d = c.touches,\n            g = d ? d.length ? d.item(0) : r(d.changedTouches, c.changedTouches)[0] : c;\n        a || (a = this.getChartPosition());\n        d = g.pageX - a.left;\n        a = g.pageY - a.top;\n        if (g = this.chart.containerScaling) d /= g.scaleX, a /= g.scaleY;\n        return v(c, {\n          chartX: Math.round(d),\n          chartY: Math.round(a)\n        });\n      };\n\n      g.prototype.onContainerClick = function (c) {\n        var a = this.chart,\n            d = a.hoverPoint;\n        c = this.normalize(c);\n        var g = a.plotLeft,\n            e = a.plotTop;\n        a.cancelClick || (d && this.inClass(c.target, \"highcharts-tracker\") ? (D(d.series, \"click\", v(c, {\n          point: d\n        })), a.hoverPoint && d.firePointEvent(\"click\", c)) : (v(c, this.getCoordinates(c)), a.isInsidePlot(c.chartX - g, c.chartY - e) && D(a, \"click\", c)));\n      };\n\n      g.prototype.onContainerMouseDown = function (c) {\n        var a = 1 === ((c.buttons || c.button) & 1);\n        c = this.normalize(c);\n        if (h.isFirefox && 0 !== c.button) this.onContainerMouseMove(c);\n        if (\"undefined\" === typeof c.button || a) this.zoomOption(c), a && c.preventDefault && c.preventDefault(), this.dragStart(c);\n      };\n\n      g.prototype.onContainerMouseLeave = function (c) {\n        var a = P[r(h.hoverChartIndex, -1)],\n            d = this.chart.tooltip;\n        c = this.normalize(c);\n        a && (c.relatedTarget || c.toElement) && (a.pointer.reset(), a.pointer.chartPosition = void 0);\n        d && !d.isHidden && this.reset();\n      };\n\n      g.prototype.onContainerMouseEnter = function (c) {\n        delete this.chartPosition;\n      };\n\n      g.prototype.onContainerMouseMove = function (c) {\n        var a = this.chart;\n        c = this.normalize(c);\n        this.setHoverChartIndex();\n        c.preventDefault || (c.returnValue = !1);\n        \"mousedown\" === a.mouseIsDown && this.drag(c);\n        a.openMenu || !this.inClass(c.target, \"highcharts-tracker\") && !a.isInsidePlot(c.chartX - a.plotLeft, c.chartY - a.plotTop) || this.runPointActions(c);\n      };\n\n      g.prototype.onDocumentTouchEnd = function (c) {\n        P[h.hoverChartIndex] && P[h.hoverChartIndex].pointer.drop(c);\n      };\n\n      g.prototype.onContainerTouchMove = function (c) {\n        this.touch(c);\n      };\n\n      g.prototype.onContainerTouchStart = function (c) {\n        this.zoomOption(c);\n        this.touch(c, !0);\n      };\n\n      g.prototype.onDocumentMouseMove = function (c) {\n        var a = this.chart,\n            d = this.chartPosition;\n        c = this.normalize(c, d);\n        var g = a.tooltip;\n        !d || g && g.isStickyOnContact() || a.isInsidePlot(c.chartX - a.plotLeft, c.chartY - a.plotTop) || this.inClass(c.target, \"highcharts-tracker\") || this.reset();\n      };\n\n      g.prototype.onDocumentMouseUp = function (c) {\n        var a = P[r(h.hoverChartIndex, -1)];\n        a && a.pointer.drop(c);\n      };\n\n      g.prototype.pinch = function (c) {\n        var a = this,\n            d = a.chart,\n            g = a.pinchDown,\n            e = c.touches || [],\n            f = e.length,\n            l = a.lastValidTouch,\n            n = a.hasZoom,\n            h = a.selectionMarker,\n            w = {},\n            m = 1 === f && (a.inClass(c.target, \"highcharts-tracker\") && d.runTrackerClick || a.runChartClick),\n            E = {};\n        1 < f && (a.initiated = !0);\n        n && a.initiated && !m && !1 !== c.cancelable && c.preventDefault();\n        [].map.call(e, function (c) {\n          return a.normalize(c);\n        });\n        \"touchstart\" === c.type ? ([].forEach.call(e, function (a, b) {\n          g[b] = {\n            chartX: a.chartX,\n            chartY: a.chartY\n          };\n        }), l.x = [g[0].chartX, g[1] && g[1].chartX], l.y = [g[0].chartY, g[1] && g[1].chartY], d.axes.forEach(function (a) {\n          if (a.zoomEnabled) {\n            var b = d.bounds[a.horiz ? \"h\" : \"v\"],\n                c = a.minPixelPadding,\n                g = a.toPixels(Math.min(r(a.options.min, a.dataMin), a.dataMin)),\n                p = a.toPixels(Math.max(r(a.options.max, a.dataMax), a.dataMax)),\n                q = Math.max(g, p);\n            b.min = Math.min(a.pos, Math.min(g, p) - c);\n            b.max = Math.max(a.pos + a.len, q + c);\n          }\n        }), a.res = !0) : a.followTouchMove && 1 === f ? this.runPointActions(a.normalize(c)) : g.length && (h || (a.selectionMarker = h = v({\n          destroy: K,\n          touch: !0\n        }, d.plotBox)), a.pinchTranslate(g, e, w, h, E, l), a.hasPinched = n, a.scaleGroups(w, E), a.res && (a.res = !1, this.reset(!1, 0)));\n      };\n\n      g.prototype.pinchTranslate = function (c, a, d, g, e, f) {\n        this.zoomHor && this.pinchTranslateDirection(!0, c, a, d, g, e, f);\n        this.zoomVert && this.pinchTranslateDirection(!1, c, a, d, g, e, f);\n      };\n\n      g.prototype.pinchTranslateDirection = function (c, a, d, g, e, f, l, r) {\n        var p = this.chart,\n            q = c ? \"x\" : \"y\",\n            n = c ? \"X\" : \"Y\",\n            h = \"chart\" + n,\n            u = c ? \"width\" : \"height\",\n            b = p[\"plot\" + (c ? \"Left\" : \"Top\")],\n            k,\n            t,\n            B = r || 1,\n            w = p.inverted,\n            A = p.bounds[c ? \"h\" : \"v\"],\n            v = 1 === a.length,\n            G = a[0][h],\n            m = d[0][h],\n            D = !v && a[1][h],\n            M = !v && d[1][h];\n\n        d = function () {\n          \"number\" === typeof M && 20 < Math.abs(G - D) && (B = r || Math.abs(m - M) / Math.abs(G - D));\n          t = (b - m) / B + G;\n          k = p[\"plot\" + (c ? \"Width\" : \"Height\")] / B;\n        };\n\n        d();\n        a = t;\n\n        if (a < A.min) {\n          a = A.min;\n          var x = !0;\n        } else a + k > A.max && (a = A.max - k, x = !0);\n\n        x ? (m -= .8 * (m - l[q][0]), \"number\" === typeof M && (M -= .8 * (M - l[q][1])), d()) : l[q] = [m, M];\n        w || (f[q] = t - b, f[u] = k);\n        f = w ? 1 / B : B;\n        e[u] = k;\n        e[q] = a;\n        g[w ? c ? \"scaleY\" : \"scaleX\" : \"scale\" + n] = B;\n        g[\"translate\" + n] = f * b + (m - f * G);\n      };\n\n      g.prototype.reset = function (c, a) {\n        var g = this.chart,\n            p = g.hoverSeries,\n            e = g.hoverPoint,\n            f = g.hoverPoints,\n            l = g.tooltip,\n            r = l && l.shared ? f : e;\n        c && r && d(r).forEach(function (a) {\n          a.series.isCartesian && \"undefined\" === typeof a.plotX && (c = !1);\n        });\n        if (c) l && r && d(r).length && (l.refresh(r), l.shared && f ? f.forEach(function (a) {\n          a.setState(a.state, !0);\n          a.series.isCartesian && (a.series.xAxis.crosshair && a.series.xAxis.drawCrosshair(null, a), a.series.yAxis.crosshair && a.series.yAxis.drawCrosshair(null, a));\n        }) : e && (e.setState(e.state, !0), g.axes.forEach(function (a) {\n          a.crosshair && e.series[a.coll] === a && a.drawCrosshair(null, e);\n        })));else {\n          if (e) e.onMouseOut();\n          f && f.forEach(function (a) {\n            a.setState();\n          });\n          if (p) p.onMouseOut();\n          l && l.hide(a);\n          this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());\n          g.axes.forEach(function (a) {\n            a.hideCrosshair();\n          });\n          this.hoverX = g.hoverPoints = g.hoverPoint = null;\n        }\n      };\n\n      g.prototype.runPointActions = function (c, a) {\n        var d = this.chart,\n            g = d.tooltip && d.tooltip.options.enabled ? d.tooltip : void 0,\n            e = g ? g.shared : !1,\n            f = a || d.hoverPoint,\n            l = f && f.series || d.hoverSeries;\n        l = this.getHoverData(f, l, d.series, (!c || \"touchmove\" !== c.type) && (!!a || l && l.directTouch && this.isDirectTouch), e, c);\n        f = l.hoverPoint;\n        var n = l.hoverPoints;\n        a = (l = l.hoverSeries) && l.tooltipOptions.followPointer;\n        e = e && l && !l.noSharedTooltip;\n\n        if (f && (f !== d.hoverPoint || g && g.isHidden)) {\n          (d.hoverPoints || []).forEach(function (a) {\n            -1 === n.indexOf(a) && a.setState();\n          });\n          if (d.hoverSeries !== l) l.onMouseOver();\n          this.applyInactiveState(n);\n          (n || []).forEach(function (a) {\n            a.setState(\"hover\");\n          });\n          d.hoverPoint && d.hoverPoint.firePointEvent(\"mouseOut\");\n          if (!f.series) return;\n          d.hoverPoints = n;\n          d.hoverPoint = f;\n          f.firePointEvent(\"mouseOver\");\n          g && g.refresh(e ? n : f, c);\n        } else a && g && !g.isHidden && (f = g.getAnchor([{}], c), g.updatePosition({\n          plotX: f[0],\n          plotY: f[1]\n        }));\n\n        this.unDocMouseMove || (this.unDocMouseMove = C(d.container.ownerDocument, \"mousemove\", function (a) {\n          var c = P[h.hoverChartIndex];\n          if (c) c.pointer.onDocumentMouseMove(a);\n        }));\n        d.axes.forEach(function (a) {\n          var g = r((a.crosshair || {}).snap, !0),\n              p;\n          g && ((p = d.hoverPoint) && p.series[a.coll] === a || (p = x(n, function (c) {\n            return c.series[a.coll] === a;\n          })));\n          p || !g ? a.drawCrosshair(c, p) : a.hideCrosshair();\n        });\n      };\n\n      g.prototype.scaleGroups = function (c, a) {\n        var d = this.chart,\n            g;\n        d.series.forEach(function (p) {\n          g = c || p.getPlotBox();\n          p.xAxis && p.xAxis.zoomEnabled && p.group && (p.group.attr(g), p.markerGroup && (p.markerGroup.attr(g), p.markerGroup.clip(a ? d.clipRect : null)), p.dataLabelsGroup && p.dataLabelsGroup.attr(g));\n        });\n        d.clipRect.attr(a || d.clipBox);\n      };\n\n      g.prototype.setDOMEvents = function () {\n        var c = this.chart.container,\n            a = c.ownerDocument;\n        c.onmousedown = this.onContainerMouseDown.bind(this);\n        c.onmousemove = this.onContainerMouseMove.bind(this);\n        c.onclick = this.onContainerClick.bind(this);\n        this.unbindContainerMouseEnter = C(c, \"mouseenter\", this.onContainerMouseEnter.bind(this));\n        this.unbindContainerMouseLeave = C(c, \"mouseleave\", this.onContainerMouseLeave.bind(this));\n        h.unbindDocumentMouseUp || (h.unbindDocumentMouseUp = C(a, \"mouseup\", this.onDocumentMouseUp.bind(this)));\n        h.hasTouch && (C(c, \"touchstart\", this.onContainerTouchStart.bind(this)), C(c, \"touchmove\", this.onContainerTouchMove.bind(this)), h.unbindDocumentTouchEnd || (h.unbindDocumentTouchEnd = C(a, \"touchend\", this.onDocumentTouchEnd.bind(this))));\n      };\n\n      g.prototype.setHoverChartIndex = function () {\n        var c = this.chart,\n            a = h.charts[r(h.hoverChartIndex, -1)];\n        if (a && a !== c) a.pointer.onContainerMouseLeave({\n          relatedTarget: !0\n        });\n        a && a.mouseIsDown || (h.hoverChartIndex = c.index);\n      };\n\n      g.prototype.touch = function (c, a) {\n        var d = this.chart,\n            g;\n        this.setHoverChartIndex();\n        if (1 === c.touches.length) {\n          if (c = this.normalize(c), (g = d.isInsidePlot(c.chartX - d.plotLeft, c.chartY - d.plotTop)) && !d.openMenu) {\n            a && this.runPointActions(c);\n\n            if (\"touchmove\" === c.type) {\n              a = this.pinchDown;\n              var e = a[0] ? 4 <= Math.sqrt(Math.pow(a[0].chartX - c.chartX, 2) + Math.pow(a[0].chartY - c.chartY, 2)) : !1;\n            }\n\n            r(e, !0) && this.pinch(c);\n          } else a && this.reset();\n        } else 2 === c.touches.length && this.pinch(c);\n      };\n\n      g.prototype.zoomOption = function (c) {\n        var a = this.chart,\n            d = a.options.chart,\n            g = d.zoomType || \"\";\n        a = a.inverted;\n        /touch/.test(c.type) && (g = r(d.pinchType, g));\n        this.zoomX = c = /x/.test(g);\n        this.zoomY = g = /y/.test(g);\n        this.zoomHor = c && !a || g && a;\n        this.zoomVert = g && !a || c && a;\n        this.hasZoom = c || g;\n      };\n\n      return g;\n    }();\n\n    return h.Pointer = f;\n  });\n  N(m, \"Core/MSPointer.js\", [m[\"Core/Globals.js\"], m[\"Core/Pointer.js\"], m[\"Core/Utilities.js\"]], function (f, h, m) {\n    function z() {\n      var e = [];\n\n      e.item = function (e) {\n        return this[e];\n      };\n\n      v(D, function (f) {\n        e.push({\n          pageX: f.pageX,\n          pageY: f.pageY,\n          target: f.target\n        });\n      });\n      return e;\n    }\n\n    function F(e, n, h, r) {\n      \"touch\" !== e.pointerType && e.pointerType !== e.MSPOINTER_TYPE_TOUCH || !K[f.hoverChartIndex] || (r(e), r = K[f.hoverChartIndex].pointer, r[n]({\n        type: h,\n        target: e.currentTarget,\n        preventDefault: y,\n        touches: z()\n      }));\n    }\n\n    var P = this && this.__extends || function () {\n      var e = function (f, l) {\n        e = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (e, d) {\n          e.__proto__ = d;\n        } || function (e, d) {\n          for (var g in d) d.hasOwnProperty(g) && (e[g] = d[g]);\n        };\n\n        return e(f, l);\n      };\n\n      return function (f, l) {\n        function r() {\n          this.constructor = f;\n        }\n\n        e(f, l);\n        f.prototype = null === l ? Object.create(l) : (r.prototype = l.prototype, new r());\n      };\n    }(),\n        K = f.charts,\n        C = f.doc,\n        y = f.noop,\n        e = m.addEvent,\n        I = m.css,\n        v = m.objectEach,\n        x = m.removeEvent,\n        D = {},\n        n = !!f.win.PointerEvent;\n\n    return function (f) {\n      function l() {\n        return null !== f && f.apply(this, arguments) || this;\n      }\n\n      P(l, f);\n\n      l.prototype.batchMSEvents = function (e) {\n        e(this.chart.container, n ? \"pointerdown\" : \"MSPointerDown\", this.onContainerPointerDown);\n        e(this.chart.container, n ? \"pointermove\" : \"MSPointerMove\", this.onContainerPointerMove);\n        e(C, n ? \"pointerup\" : \"MSPointerUp\", this.onDocumentPointerUp);\n      };\n\n      l.prototype.destroy = function () {\n        this.batchMSEvents(x);\n        f.prototype.destroy.call(this);\n      };\n\n      l.prototype.init = function (e, l) {\n        f.prototype.init.call(this, e, l);\n        this.hasZoom && I(e.container, {\n          \"-ms-touch-action\": \"none\",\n          \"touch-action\": \"none\"\n        });\n      };\n\n      l.prototype.onContainerPointerDown = function (e) {\n        F(e, \"onContainerTouchStart\", \"touchstart\", function (e) {\n          D[e.pointerId] = {\n            pageX: e.pageX,\n            pageY: e.pageY,\n            target: e.currentTarget\n          };\n        });\n      };\n\n      l.prototype.onContainerPointerMove = function (e) {\n        F(e, \"onContainerTouchMove\", \"touchmove\", function (e) {\n          D[e.pointerId] = {\n            pageX: e.pageX,\n            pageY: e.pageY\n          };\n          D[e.pointerId].target || (D[e.pointerId].target = e.currentTarget);\n        });\n      };\n\n      l.prototype.onDocumentPointerUp = function (e) {\n        F(e, \"onDocumentTouchEnd\", \"touchend\", function (e) {\n          delete D[e.pointerId];\n        });\n      };\n\n      l.prototype.setDOMEvents = function () {\n        f.prototype.setDOMEvents.call(this);\n        (this.hasZoom || this.followTouchMove) && this.batchMSEvents(e);\n      };\n\n      return l;\n    }(h);\n  });\n  N(m, \"Core/Legend.js\", [m[\"Core/Animation/AnimationUtilities.js\"], m[\"Core/Globals.js\"], m[\"Core/Utilities.js\"]], function (f, h, m) {\n    var z = f.animObject,\n        F = f.setAnimation,\n        L = m.addEvent,\n        K = m.css,\n        C = m.defined,\n        y = m.discardElement,\n        e = m.find,\n        I = m.fireEvent,\n        v = m.format,\n        x = m.isNumber,\n        D = m.merge,\n        n = m.pick,\n        l = m.relativeLength,\n        J = m.stableSort,\n        w = m.syncTimeout;\n    f = m.wrap;\n    m = h.isFirefox;\n\n    var r = h.marginNames,\n        d = h.win,\n        g = function () {\n      function c(a, c) {\n        this.allItems = [];\n        this.contentGroup = this.box = void 0;\n        this.display = !1;\n        this.group = void 0;\n        this.offsetWidth = this.maxLegendWidth = this.maxItemWidth = this.legendWidth = this.legendHeight = this.lastLineHeight = this.lastItemY = this.itemY = this.itemX = this.itemMarginTop = this.itemMarginBottom = this.itemHeight = this.initialItemY = 0;\n        this.options = {};\n        this.padding = 0;\n        this.pages = [];\n        this.proximate = !1;\n        this.scrollGroup = void 0;\n        this.widthOption = this.totalItemWidth = this.titleHeight = this.symbolWidth = this.symbolHeight = 0;\n        this.chart = a;\n        this.init(a, c);\n      }\n\n      c.prototype.init = function (a, c) {\n        this.chart = a;\n        this.setOptions(c);\n        c.enabled && (this.render(), L(this.chart, \"endResize\", function () {\n          this.legend.positionCheckboxes();\n        }), this.proximate ? this.unchartrender = L(this.chart, \"render\", function () {\n          this.legend.proximatePositions();\n          this.legend.positionItems();\n        }) : this.unchartrender && this.unchartrender());\n      };\n\n      c.prototype.setOptions = function (a) {\n        var c = n(a.padding, 8);\n        this.options = a;\n        this.chart.styledMode || (this.itemStyle = a.itemStyle, this.itemHiddenStyle = D(this.itemStyle, a.itemHiddenStyle));\n        this.itemMarginTop = a.itemMarginTop || 0;\n        this.itemMarginBottom = a.itemMarginBottom || 0;\n        this.padding = c;\n        this.initialItemY = c - 5;\n        this.symbolWidth = n(a.symbolWidth, 16);\n        this.pages = [];\n        this.proximate = \"proximate\" === a.layout && !this.chart.inverted;\n        this.baseline = void 0;\n      };\n\n      c.prototype.update = function (a, c) {\n        var d = this.chart;\n        this.setOptions(D(!0, this.options, a));\n        this.destroy();\n        d.isDirtyLegend = d.isDirtyBox = !0;\n        n(c, !0) && d.redraw();\n        I(this, \"afterUpdate\");\n      };\n\n      c.prototype.colorizeItem = function (a, c) {\n        a.legendGroup[c ? \"removeClass\" : \"addClass\"](\"highcharts-legend-item-hidden\");\n\n        if (!this.chart.styledMode) {\n          var d = this.options,\n              g = a.legendItem,\n              e = a.legendLine,\n              f = a.legendSymbol,\n              q = this.itemHiddenStyle.color;\n          d = c ? d.itemStyle.color : q;\n          var l = c ? a.color || q : q,\n              r = a.options && a.options.marker,\n              n = {\n            fill: l\n          };\n          g && g.css({\n            fill: d,\n            color: d\n          });\n          e && e.attr({\n            stroke: l\n          });\n          f && (r && f.isMarker && (n = a.pointAttribs(), c || (n.stroke = n.fill = q)), f.attr(n));\n        }\n\n        I(this, \"afterColorizeItem\", {\n          item: a,\n          visible: c\n        });\n      };\n\n      c.prototype.positionItems = function () {\n        this.allItems.forEach(this.positionItem, this);\n        this.chart.isResizing || this.positionCheckboxes();\n      };\n\n      c.prototype.positionItem = function (a) {\n        var c = this,\n            d = this.options,\n            g = d.symbolPadding,\n            e = !d.rtl,\n            f = a._legendItemPos;\n        d = f[0];\n        f = f[1];\n        var l = a.checkbox,\n            n = a.legendGroup;\n        n && n.element && (g = {\n          translateX: e ? d : this.legendWidth - d - 2 * g - 4,\n          translateY: f\n        }, e = function () {\n          I(c, \"afterPositionItem\", {\n            item: a\n          });\n        }, C(n.translateY) ? n.animate(g, void 0, e) : (n.attr(g), e()));\n        l && (l.x = d, l.y = f);\n      };\n\n      c.prototype.destroyItem = function (a) {\n        var c = a.checkbox;\n        [\"legendItem\", \"legendLine\", \"legendSymbol\", \"legendGroup\"].forEach(function (c) {\n          a[c] && (a[c] = a[c].destroy());\n        });\n        c && y(a.checkbox);\n      };\n\n      c.prototype.destroy = function () {\n        function a(a) {\n          this[a] && (this[a] = this[a].destroy());\n        }\n\n        this.getAllItems().forEach(function (c) {\n          [\"legendItem\", \"legendGroup\"].forEach(a, c);\n        });\n        \"clipRect up down pager nav box title group\".split(\" \").forEach(a, this);\n        this.display = null;\n      };\n\n      c.prototype.positionCheckboxes = function () {\n        var a = this.group && this.group.alignAttr,\n            c = this.clipHeight || this.legendHeight,\n            d = this.titleHeight;\n\n        if (a) {\n          var g = a.translateY;\n          this.allItems.forEach(function (e) {\n            var p = e.checkbox;\n\n            if (p) {\n              var f = g + d + p.y + (this.scrollOffset || 0) + 3;\n              K(p, {\n                left: a.translateX + e.checkboxOffset + p.x - 20 + \"px\",\n                top: f + \"px\",\n                display: this.proximate || f > g - 6 && f < g + c - 6 ? \"\" : \"none\"\n              });\n            }\n          }, this);\n        }\n      };\n\n      c.prototype.renderTitle = function () {\n        var a = this.options,\n            c = this.padding,\n            d = a.title,\n            g = 0;\n        d.text && (this.title || (this.title = this.chart.renderer.label(d.text, c - 3, c - 4, null, null, null, a.useHTML, null, \"legend-title\").attr({\n          zIndex: 1\n        }), this.chart.styledMode || this.title.css(d.style), this.title.add(this.group)), d.width || this.title.css({\n          width: this.maxLegendWidth + \"px\"\n        }), a = this.title.getBBox(), g = a.height, this.offsetWidth = a.width, this.contentGroup.attr({\n          translateY: g\n        }));\n        this.titleHeight = g;\n      };\n\n      c.prototype.setText = function (a) {\n        var c = this.options;\n        a.legendItem.attr({\n          text: c.labelFormat ? v(c.labelFormat, a, this.chart) : c.labelFormatter.call(a)\n        });\n      };\n\n      c.prototype.renderItem = function (a) {\n        var c = this.chart,\n            d = c.renderer,\n            g = this.options,\n            e = this.symbolWidth,\n            f = g.symbolPadding,\n            l = this.itemStyle,\n            r = this.itemHiddenStyle,\n            h = \"horizontal\" === g.layout ? n(g.itemDistance, 20) : 0,\n            w = !g.rtl,\n            v = a.legendItem,\n            u = !a.series,\n            b = !u && a.series.drawLegendSymbol ? a.series : a,\n            k = b.options;\n        k = this.createCheckboxForItem && k && k.showCheckbox;\n        h = e + f + h + (k ? 20 : 0);\n        var t = g.useHTML,\n            H = a.options.className;\n        v || (a.legendGroup = d.g(\"legend-item\").addClass(\"highcharts-\" + b.type + \"-series highcharts-color-\" + a.colorIndex + (H ? \" \" + H : \"\") + (u ? \" highcharts-series-\" + a.index : \"\")).attr({\n          zIndex: 1\n        }).add(this.scrollGroup), a.legendItem = v = d.text(\"\", w ? e + f : -f, this.baseline || 0, t), c.styledMode || v.css(D(a.visible ? l : r)), v.attr({\n          align: w ? \"left\" : \"right\",\n          zIndex: 2\n        }).add(a.legendGroup), this.baseline || (this.fontMetrics = d.fontMetrics(c.styledMode ? 12 : l.fontSize, v), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, v.attr(\"y\", this.baseline)), this.symbolHeight = g.symbolHeight || this.fontMetrics.f, b.drawLegendSymbol(this, a), this.setItemEvents && this.setItemEvents(a, v, t));\n        k && !a.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(a);\n        this.colorizeItem(a, a.visible);\n        !c.styledMode && l.width || v.css({\n          width: (g.itemWidth || this.widthOption || c.spacingBox.width) - h + \"px\"\n        });\n        this.setText(a);\n        c = v.getBBox();\n        a.itemWidth = a.checkboxOffset = g.itemWidth || a.legendItemWidth || c.width + h;\n        this.maxItemWidth = Math.max(this.maxItemWidth, a.itemWidth);\n        this.totalItemWidth += a.itemWidth;\n        this.itemHeight = a.itemHeight = Math.round(a.legendItemHeight || c.height || this.symbolHeight);\n      };\n\n      c.prototype.layoutItem = function (a) {\n        var c = this.options,\n            d = this.padding,\n            g = \"horizontal\" === c.layout,\n            e = a.itemHeight,\n            f = this.itemMarginBottom,\n            l = this.itemMarginTop,\n            r = g ? n(c.itemDistance, 20) : 0,\n            h = this.maxLegendWidth;\n        c = c.alignColumns && this.totalItemWidth > h ? this.maxItemWidth : a.itemWidth;\n        g && this.itemX - d + c > h && (this.itemX = d, this.lastLineHeight && (this.itemY += l + this.lastLineHeight + f), this.lastLineHeight = 0);\n        this.lastItemY = l + this.itemY + f;\n        this.lastLineHeight = Math.max(e, this.lastLineHeight);\n        a._legendItemPos = [this.itemX, this.itemY];\n        g ? this.itemX += c : (this.itemY += l + e + f, this.lastLineHeight = e);\n        this.offsetWidth = this.widthOption || Math.max((g ? this.itemX - d - (a.checkbox ? 0 : r) : c) + d, this.offsetWidth);\n      };\n\n      c.prototype.getAllItems = function () {\n        var a = [];\n        this.chart.series.forEach(function (c) {\n          var d = c && c.options;\n          c && n(d.showInLegend, C(d.linkedTo) ? !1 : void 0, !0) && (a = a.concat(c.legendItems || (\"point\" === d.legendType ? c.data : c)));\n        });\n        I(this, \"afterGetAllItems\", {\n          allItems: a\n        });\n        return a;\n      };\n\n      c.prototype.getAlignment = function () {\n        var a = this.options;\n        return this.proximate ? a.align.charAt(0) + \"tv\" : a.floating ? \"\" : a.align.charAt(0) + a.verticalAlign.charAt(0) + a.layout.charAt(0);\n      };\n\n      c.prototype.adjustMargins = function (a, c) {\n        var d = this.chart,\n            g = this.options,\n            e = this.getAlignment();\n        e && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (f, p) {\n          f.test(e) && !C(a[p]) && (d[r[p]] = Math.max(d[r[p]], d.legend[(p + 1) % 2 ? \"legendHeight\" : \"legendWidth\"] + [1, -1, -1, 1][p] * g[p % 2 ? \"x\" : \"y\"] + n(g.margin, 12) + c[p] + (d.titleOffset[p] || 0)));\n        });\n      };\n\n      c.prototype.proximatePositions = function () {\n        var a = this.chart,\n            c = [],\n            d = \"left\" === this.options.align;\n        this.allItems.forEach(function (g) {\n          var f;\n          var p = d;\n\n          if (g.yAxis) {\n            g.xAxis.options.reversed && (p = !p);\n            g.points && (f = e(p ? g.points : g.points.slice(0).reverse(), function (a) {\n              return x(a.plotY);\n            }));\n            p = this.itemMarginTop + g.legendItem.getBBox().height + this.itemMarginBottom;\n            var q = g.yAxis.top - a.plotTop;\n            g.visible ? (f = f ? f.plotY : g.yAxis.height, f += q - .3 * p) : f = q + g.yAxis.height;\n            c.push({\n              target: f,\n              size: p,\n              item: g\n            });\n          }\n        }, this);\n        h.distribute(c, a.plotHeight);\n        c.forEach(function (c) {\n          c.item._legendItemPos[1] = a.plotTop - a.spacing[0] + c.pos;\n        });\n      };\n\n      c.prototype.render = function () {\n        var a = this.chart,\n            c = a.renderer,\n            d = this.group,\n            g = this.box,\n            e = this.options,\n            f = this.padding;\n        this.itemX = f;\n        this.itemY = this.initialItemY;\n        this.lastItemY = this.offsetWidth = 0;\n        this.widthOption = l(e.width, a.spacingBox.width - f);\n        var n = a.spacingBox.width - 2 * f - e.x;\n        -1 < [\"rm\", \"lm\"].indexOf(this.getAlignment().substring(0, 2)) && (n /= 2);\n        this.maxLegendWidth = this.widthOption || n;\n        d || (this.group = d = c.g(\"legend\").attr({\n          zIndex: 7\n        }).add(), this.contentGroup = c.g().attr({\n          zIndex: 1\n        }).add(d), this.scrollGroup = c.g().add(this.contentGroup));\n        this.renderTitle();\n        var r = this.getAllItems();\n        J(r, function (a, c) {\n          return (a.options && a.options.legendIndex || 0) - (c.options && c.options.legendIndex || 0);\n        });\n        e.reversed && r.reverse();\n        this.allItems = r;\n        this.display = n = !!r.length;\n        this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;\n        r.forEach(this.renderItem, this);\n        r.forEach(this.layoutItem, this);\n        r = (this.widthOption || this.offsetWidth) + f;\n        var h = this.lastItemY + this.lastLineHeight + this.titleHeight;\n        h = this.handleOverflow(h);\n        h += f;\n        g || (this.box = g = c.rect().addClass(\"highcharts-legend-box\").attr({\n          r: e.borderRadius\n        }).add(d), g.isNew = !0);\n        a.styledMode || g.attr({\n          stroke: e.borderColor,\n          \"stroke-width\": e.borderWidth || 0,\n          fill: e.backgroundColor || \"none\"\n        }).shadow(e.shadow);\n        0 < r && 0 < h && (g[g.isNew ? \"attr\" : \"animate\"](g.crisp.call({}, {\n          x: 0,\n          y: 0,\n          width: r,\n          height: h\n        }, g.strokeWidth())), g.isNew = !1);\n        g[n ? \"show\" : \"hide\"]();\n        a.styledMode && \"none\" === d.getStyle(\"display\") && (r = h = 0);\n        this.legendWidth = r;\n        this.legendHeight = h;\n        n && this.align();\n        this.proximate || this.positionItems();\n        I(this, \"afterRender\");\n      };\n\n      c.prototype.align = function (a) {\n        void 0 === a && (a = this.chart.spacingBox);\n        var c = this.chart,\n            d = this.options,\n            g = a.y;\n        /(lth|ct|rth)/.test(this.getAlignment()) && 0 < c.titleOffset[0] ? g += c.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && 0 < c.titleOffset[2] && (g -= c.titleOffset[2]);\n        g !== a.y && (a = D(a, {\n          y: g\n        }));\n        this.group.align(D(d, {\n          width: this.legendWidth,\n          height: this.legendHeight,\n          verticalAlign: this.proximate ? \"top\" : d.verticalAlign\n        }), !0, a);\n      };\n\n      c.prototype.handleOverflow = function (a) {\n        var c = this,\n            d = this.chart,\n            g = d.renderer,\n            e = this.options,\n            f = e.y,\n            l = this.padding;\n        f = d.spacingBox.height + (\"top\" === e.verticalAlign ? -f : f) - l;\n\n        var r = e.maxHeight,\n            h,\n            w = this.clipRect,\n            v = e.navigation,\n            u = n(v.animation, !0),\n            b = v.arrowSize || 12,\n            k = this.nav,\n            t = this.pages,\n            H,\n            m = this.allItems,\n            D = function (a) {\n          \"number\" === typeof a ? w.attr({\n            height: a\n          }) : w && (c.clipRect = w.destroy(), c.contentGroup.clip());\n          c.contentGroup.div && (c.contentGroup.div.style.clip = a ? \"rect(\" + l + \"px,9999px,\" + (l + a) + \"px,0)\" : \"auto\");\n        },\n            x = function (a) {\n          c[a] = g.circle(0, 0, 1.3 * b).translate(b / 2, b / 2).add(k);\n          d.styledMode || c[a].attr(\"fill\", \"rgba(0,0,0,0.0001)\");\n          return c[a];\n        };\n\n        \"horizontal\" !== e.layout || \"middle\" === e.verticalAlign || e.floating || (f /= 2);\n        r && (f = Math.min(f, r));\n        t.length = 0;\n        a > f && !1 !== v.enabled ? (this.clipHeight = h = Math.max(f - 20 - this.titleHeight - l, 0), this.currentPage = n(this.currentPage, 1), this.fullHeight = a, m.forEach(function (a, b) {\n          var c = a._legendItemPos[1],\n              d = Math.round(a.legendItem.getBBox().height),\n              g = t.length;\n          if (!g || c - t[g - 1] > h && (H || c) !== t[g - 1]) t.push(H || c), g++;\n          a.pageIx = g - 1;\n          H && (m[b - 1].pageIx = g - 1);\n          b === m.length - 1 && c + d - t[g - 1] > h && c !== H && (t.push(c), a.pageIx = g);\n          c !== H && (H = c);\n        }), w || (w = c.clipRect = g.clipRect(0, l, 9999, 0), c.contentGroup.clip(w)), D(h), k || (this.nav = k = g.g().attr({\n          zIndex: 1\n        }).add(this.group), this.up = g.symbol(\"triangle\", 0, 0, b, b).add(k), x(\"upTracker\").on(\"click\", function () {\n          c.scroll(-1, u);\n        }), this.pager = g.text(\"\", 15, 10).addClass(\"highcharts-legend-navigation\"), d.styledMode || this.pager.css(v.style), this.pager.add(k), this.down = g.symbol(\"triangle-down\", 0, 0, b, b).add(k), x(\"downTracker\").on(\"click\", function () {\n          c.scroll(1, u);\n        })), c.scroll(0), a = f) : k && (D(), this.nav = k.destroy(), this.scrollGroup.attr({\n          translateY: 1\n        }), this.clipHeight = 0);\n        return a;\n      };\n\n      c.prototype.scroll = function (a, c) {\n        var d = this,\n            g = this.chart,\n            e = this.pages,\n            f = e.length,\n            l = this.currentPage + a;\n        a = this.clipHeight;\n        var q = this.options.navigation,\n            r = this.pager,\n            h = this.padding;\n        l > f && (l = f);\n        0 < l && (\"undefined\" !== typeof c && F(c, g), this.nav.attr({\n          translateX: h,\n          translateY: a + this.padding + 7 + this.titleHeight,\n          visibility: \"visible\"\n        }), [this.up, this.upTracker].forEach(function (a) {\n          a.attr({\n            \"class\": 1 === l ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n          });\n        }), r.attr({\n          text: l + \"/\" + f\n        }), [this.down, this.downTracker].forEach(function (a) {\n          a.attr({\n            x: 18 + this.pager.getBBox().width,\n            \"class\": l === f ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n          });\n        }, this), g.styledMode || (this.up.attr({\n          fill: 1 === l ? q.inactiveColor : q.activeColor\n        }), this.upTracker.css({\n          cursor: 1 === l ? \"default\" : \"pointer\"\n        }), this.down.attr({\n          fill: l === f ? q.inactiveColor : q.activeColor\n        }), this.downTracker.css({\n          cursor: l === f ? \"default\" : \"pointer\"\n        })), this.scrollOffset = -e[l - 1] + this.initialItemY, this.scrollGroup.animate({\n          translateY: this.scrollOffset\n        }), this.currentPage = l, this.positionCheckboxes(), c = z(n(c, g.renderer.globalAnimation, !0)), w(function () {\n          I(d, \"afterScroll\", {\n            currentPage: l\n          });\n        }, c.duration));\n      };\n\n      return c;\n    }();\n\n    (/Trident\\/7\\.0/.test(d.navigator && d.navigator.userAgent) || m) && f(g.prototype, \"positionItem\", function (c, a) {\n      var d = this,\n          g = function () {\n        a._legendItemPos && c.call(d, a);\n      };\n\n      g();\n      d.bubbleLegend || setTimeout(g);\n    });\n    h.Legend = g;\n    return h.Legend;\n  });\n  N(m, \"Core/Series/Point.js\", [m[\"Core/Animation/AnimationUtilities.js\"], m[\"Core/Globals.js\"], m[\"Core/Utilities.js\"]], function (f, h, m) {\n    var z = f.animObject,\n        F = m.defined,\n        L = m.erase,\n        K = m.extend,\n        C = m.fireEvent,\n        y = m.format,\n        e = m.getNestedProperty,\n        I = m.isArray,\n        v = m.isNumber,\n        x = m.isObject,\n        D = m.syncTimeout,\n        n = m.pick,\n        l = m.removeEvent,\n        J = m.uniqueKey;\n    \"\";\n\n    f = function () {\n      function f() {\n        this.colorIndex = this.category = void 0;\n        this.formatPrefix = \"point\";\n        this.id = void 0;\n        this.isNull = !1;\n        this.percentage = this.options = this.name = void 0;\n        this.selected = !1;\n        this.total = this.series = void 0;\n        this.visible = !0;\n        this.x = void 0;\n      }\n\n      f.prototype.animateBeforeDestroy = function () {\n        var e = this,\n            d = {\n          x: e.startXPos,\n          opacity: 0\n        },\n            g,\n            c = e.getGraphicalProps();\n        c.singular.forEach(function (a) {\n          g = \"dataLabel\" === a;\n          e[a] = e[a].animate(g ? {\n            x: e[a].startXPos,\n            y: e[a].startYPos,\n            opacity: 0\n          } : d);\n        });\n        c.plural.forEach(function (a) {\n          e[a].forEach(function (a) {\n            a.element && a.animate(K({\n              x: e.startXPos\n            }, a.startYPos ? {\n              x: a.startXPos,\n              y: a.startYPos\n            } : {}));\n          });\n        });\n      };\n\n      f.prototype.applyOptions = function (e, d) {\n        var g = this.series,\n            c = g.options.pointValKey || g.pointValKey;\n        e = f.prototype.optionsToObject.call(this, e);\n        K(this, e);\n        this.options = this.options ? K(this.options, e) : e;\n        e.group && delete this.group;\n        e.dataLabels && delete this.dataLabels;\n        c && (this.y = f.prototype.getNestedProperty.call(this, c));\n        this.formatPrefix = (this.isNull = n(this.isValid && !this.isValid(), null === this.x || !v(this.y))) ? \"null\" : \"point\";\n        this.selected && (this.state = \"select\");\n        \"name\" in this && \"undefined\" === typeof d && g.xAxis && g.xAxis.hasNames && (this.x = g.xAxis.nameToX(this));\n        \"undefined\" === typeof this.x && g && (this.x = \"undefined\" === typeof d ? g.autoIncrement(this) : d);\n        return this;\n      };\n\n      f.prototype.destroy = function () {\n        function e() {\n          if (d.graphic || d.dataLabel || d.dataLabels) l(d), d.destroyElements();\n\n          for (p in d) d[p] = null;\n        }\n\n        var d = this,\n            g = d.series,\n            c = g.chart;\n        g = g.options.dataSorting;\n        var a = c.hoverPoints,\n            f = z(d.series.chart.renderer.globalAnimation),\n            p;\n        d.legendItem && c.legend.destroyItem(d);\n        a && (d.setState(), L(a, d), a.length || (c.hoverPoints = null));\n        if (d === c.hoverPoint) d.onMouseOut();\n        g && g.enabled ? (this.animateBeforeDestroy(), D(e, f.duration)) : e();\n        c.pointCount--;\n      };\n\n      f.prototype.destroyElements = function (e) {\n        var d = this;\n        e = d.getGraphicalProps(e);\n        e.singular.forEach(function (g) {\n          d[g] = d[g].destroy();\n        });\n        e.plural.forEach(function (g) {\n          d[g].forEach(function (c) {\n            c.element && c.destroy();\n          });\n          delete d[g];\n        });\n      };\n\n      f.prototype.firePointEvent = function (e, d, g) {\n        var c = this,\n            a = this.series.options;\n        (a.point.events[e] || c.options && c.options.events && c.options.events[e]) && c.importEvents();\n        \"click\" === e && a.allowPointSelect && (g = function (a) {\n          c.select && c.select(null, a.ctrlKey || a.metaKey || a.shiftKey);\n        });\n        C(c, e, d, g);\n      };\n\n      f.prototype.getClassName = function () {\n        return \"highcharts-point\" + (this.selected ? \" highcharts-point-select\" : \"\") + (this.negative ? \" highcharts-negative\" : \"\") + (this.isNull ? \" highcharts-null-point\" : \"\") + (\"undefined\" !== typeof this.colorIndex ? \" highcharts-color-\" + this.colorIndex : \"\") + (this.options.className ? \" \" + this.options.className : \"\") + (this.zone && this.zone.className ? \" \" + this.zone.className.replace(\"highcharts-negative\", \"\") : \"\");\n      };\n\n      f.prototype.getGraphicalProps = function (e) {\n        var d = this,\n            g = [],\n            c,\n            a = {\n          singular: [],\n          plural: []\n        };\n        e = e || {\n          graphic: 1,\n          dataLabel: 1\n        };\n        e.graphic && g.push(\"graphic\", \"shadowGroup\");\n        e.dataLabel && g.push(\"dataLabel\", \"dataLabelUpper\", \"connector\");\n\n        for (c = g.length; c--;) {\n          var f = g[c];\n          d[f] && a.singular.push(f);\n        }\n\n        [\"dataLabel\", \"connector\"].forEach(function (c) {\n          var g = c + \"s\";\n          e[c] && d[g] && a.plural.push(g);\n        });\n        return a;\n      };\n\n      f.prototype.getLabelConfig = function () {\n        return {\n          x: this.category,\n          y: this.y,\n          color: this.color,\n          colorIndex: this.colorIndex,\n          key: this.name || this.category,\n          series: this.series,\n          point: this,\n          percentage: this.percentage,\n          total: this.total || this.stackTotal\n        };\n      };\n\n      f.prototype.getNestedProperty = function (f) {\n        if (f) return 0 === f.indexOf(\"custom.\") ? e(f, this.options) : this[f];\n      };\n\n      f.prototype.getZone = function () {\n        var e = this.series,\n            d = e.zones;\n        e = e.zoneAxis || \"y\";\n        var g = 0,\n            c;\n\n        for (c = d[g]; this[e] >= c.value;) c = d[++g];\n\n        this.nonZonedColor || (this.nonZonedColor = this.color);\n        this.color = c && c.color && !this.options.color ? c.color : this.nonZonedColor;\n        return c;\n      };\n\n      f.prototype.hasNewShapeType = function () {\n        return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;\n      };\n\n      f.prototype.init = function (e, d, g) {\n        this.series = e;\n        this.applyOptions(d, g);\n        this.id = F(this.id) ? this.id : J();\n        this.resolveColor();\n        e.chart.pointCount++;\n        C(this, \"afterInit\");\n        return this;\n      };\n\n      f.prototype.optionsToObject = function (e) {\n        var d = {},\n            g = this.series,\n            c = g.options.keys,\n            a = c || g.pointArrayMap || [\"y\"],\n            l = a.length,\n            p = 0,\n            n = 0;\n        if (v(e) || null === e) d[a[0]] = e;else if (I(e)) for (!c && e.length > l && (g = typeof e[0], \"string\" === g ? d.name = e[0] : \"number\" === g && (d.x = e[0]), p++); n < l;) c && \"undefined\" === typeof e[p] || (0 < a[n].indexOf(\".\") ? f.prototype.setNestedProperty(d, e[p], a[n]) : d[a[n]] = e[p]), p++, n++;else \"object\" === typeof e && (d = e, e.dataLabels && (g._hasPointLabels = !0), e.marker && (g._hasPointMarkers = !0));\n        return d;\n      };\n\n      f.prototype.resolveColor = function () {\n        var e = this.series;\n        var d = e.chart.options.chart.colorCount;\n        var g = e.chart.styledMode;\n        delete this.nonZonedColor;\n        g || this.options.color || (this.color = e.color);\n        e.options.colorByPoint ? (g || (d = e.options.colors || e.chart.options.colors, this.color = this.color || d[e.colorCounter], d = d.length), g = e.colorCounter, e.colorCounter++, e.colorCounter === d && (e.colorCounter = 0)) : g = e.colorIndex;\n        this.colorIndex = n(this.colorIndex, g);\n      };\n\n      f.prototype.setNestedProperty = function (e, d, g) {\n        g.split(\".\").reduce(function (c, a, g, e) {\n          c[a] = e.length - 1 === g ? d : x(c[a], !0) ? c[a] : {};\n          return c[a];\n        }, e);\n        return e;\n      };\n\n      f.prototype.tooltipFormatter = function (e) {\n        var d = this.series,\n            g = d.tooltipOptions,\n            c = n(g.valueDecimals, \"\"),\n            a = g.valuePrefix || \"\",\n            f = g.valueSuffix || \"\";\n        d.chart.styledMode && (e = d.chart.tooltip.styledModeFormat(e));\n        (d.pointArrayMap || [\"y\"]).forEach(function (d) {\n          d = \"{point.\" + d;\n          if (a || f) e = e.replace(RegExp(d + \"}\", \"g\"), a + d + \"}\" + f);\n          e = e.replace(RegExp(d + \"}\", \"g\"), d + \":,.\" + c + \"f}\");\n        });\n        return y(e, {\n          point: this,\n          series: this.series\n        }, d.chart);\n      };\n\n      return f;\n    }();\n\n    return h.Point = f;\n  });\n  N(m, \"Core/Series/Series.js\", [m[\"Core/Globals.js\"], m[\"Core/Series/Point.js\"], m[\"Core/Utilities.js\"]], function (f, h, m) {\n    var z = m.error,\n        F = m.extendClass,\n        L = m.fireEvent,\n        K = m.getOptions,\n        C = m.isObject,\n        y = m.merge,\n        e = m.objectEach;\n\n    m = function () {\n      function f(e, h) {\n        var v = y(f.defaultOptions, h);\n        this.chart = e;\n        this._i = e.series.length;\n        e.series.push(this);\n        this.options = v;\n        this.userOptions = y(h);\n      }\n\n      f.addSeries = function (e, h) {\n        f.seriesTypes[e] = h;\n      };\n\n      f.cleanRecursively = function (h, m) {\n        var v = {};\n        e(h, function (e, l) {\n          if (C(h[l], !0) && !h.nodeType && m[l]) e = f.cleanRecursively(h[l], m[l]), Object.keys(e).length && (v[l] = e);else if (C(h[l]) || h[l] !== m[l]) v[l] = h[l];\n        });\n        return v;\n      };\n\n      f.getSeries = function (e, h) {\n        void 0 === h && (h = {});\n        var v = e.options.chart;\n        v = h.type || v.type || v.defaultSeriesType || \"\";\n        var n = f.seriesTypes[v];\n        n || z(17, !0, e, {\n          missingModuleFor: v\n        });\n        return new n(e, h);\n      };\n\n      f.seriesType = function (e, m, D, n, l) {\n        var v = K().plotOptions || {},\n            w = f.seriesTypes;\n        m = m || \"\";\n        v[e] = y(v[m], D);\n        f.addSeries(e, F(w[m] || function () {}, n));\n        w[e].prototype.type = e;\n        l && (w[e].prototype.pointClass = F(h, l));\n        return w[e];\n      };\n\n      f.prototype.update = function (e, h) {\n        void 0 === h && (h = !0);\n        var m = this;\n        e = f.cleanRecursively(e, this.userOptions);\n        var n = e.type;\n        \"undefined\" !== typeof n && n !== m.type && (m = f.getSeries(m.chart, e));\n        L(m, \"update\", {\n          newOptions: e\n        });\n        m.userOptions = y(e);\n        L(m, \"afterUpdate\", {\n          newOptions: e\n        });\n        h && m.chart.redraw();\n        return m;\n      };\n\n      f.defaultOptions = {\n        type: \"base\"\n      };\n      f.seriesTypes = {};\n      return f;\n    }();\n\n    m.prototype.pointClass = h;\n    f.seriesType = m.seriesType;\n    f.seriesTypes = m.seriesTypes;\n    return m;\n  });\n  N(m, \"Core/Chart/Chart.js\", [m[\"Core/Animation/AnimationUtilities.js\"], m[\"Core/Axis/Axis.js\"], m[\"Core/Series/Series.js\"], m[\"Core/Globals.js\"], m[\"Core/Legend.js\"], m[\"Core/MSPointer.js\"], m[\"Core/Options.js\"], m[\"Core/Pointer.js\"], m[\"Core/Time.js\"], m[\"Core/Utilities.js\"]], function (f, h, m, z, F, L, K, C, y, e) {\n    var I = f.animate,\n        v = f.animObject,\n        x = f.setAnimation,\n        D = z.charts,\n        n = z.doc,\n        l = z.win,\n        J = K.defaultOptions,\n        w = e.addEvent,\n        r = e.attr,\n        d = e.createElement,\n        g = e.css,\n        c = e.defined,\n        a = e.discardElement,\n        q = e.erase,\n        p = e.error,\n        B = e.extend,\n        A = e.find,\n        G = e.fireEvent,\n        M = e.getStyle,\n        T = e.isArray,\n        Q = e.isFunction,\n        O = e.isNumber,\n        E = e.isObject,\n        u = e.isString,\n        b = e.merge,\n        k = e.numberFormat,\n        t = e.objectEach,\n        H = e.pick,\n        R = e.pInt,\n        U = e.relativeLength,\n        Z = e.removeEvent,\n        aa = e.splat,\n        ba = e.syncTimeout,\n        S = e.uniqueKey,\n        Y = z.marginNames,\n        W = function () {\n      function f(a, b, c) {\n        this.yAxis = this.xAxis = this.userOptions = this.titleOffset = this.time = this.symbolCounter = this.spacingBox = this.spacing = this.series = this.renderTo = this.renderer = this.pointer = this.pointCount = this.plotWidth = this.plotTop = this.plotLeft = this.plotHeight = this.plotBox = this.options = this.numberFormatter = this.margin = this.legend = this.labelCollectors = this.isResizing = this.index = this.container = this.colorCounter = this.clipBox = this.chartWidth = this.chartHeight = this.bounds = this.axisOffset = this.axes = void 0;\n        this.getArgs(a, b, c);\n      }\n\n      f.prototype.getArgs = function (a, b, c) {\n        u(a) || a.nodeName ? (this.renderTo = a, this.init(b, c)) : this.init(a, b);\n      };\n\n      f.prototype.init = function (a, c) {\n        var d,\n            g = a.series,\n            e = a.plotOptions || {};\n        G(this, \"init\", {\n          args: arguments\n        }, function () {\n          a.series = null;\n          d = b(J, a);\n          var f = d.chart || {};\n          t(d.plotOptions, function (a, c) {\n            E(a) && (a.tooltip = e[c] && b(e[c].tooltip) || void 0);\n          });\n          d.tooltip.userOptions = a.chart && a.chart.forExport && a.tooltip.userOptions || a.tooltip;\n          d.series = a.series = g;\n          this.userOptions = a;\n          var p = f.events;\n          this.margin = [];\n          this.spacing = [];\n          this.bounds = {\n            h: {},\n            v: {}\n          };\n          this.labelCollectors = [];\n          this.callback = c;\n          this.isResizing = 0;\n          this.options = d;\n          this.axes = [];\n          this.series = [];\n          this.time = a.time && Object.keys(a.time).length ? new y(a.time) : z.time;\n          this.numberFormatter = f.numberFormatter || k;\n          this.styledMode = f.styledMode;\n          this.hasCartesianSeries = f.showAxes;\n          var l = this;\n          l.index = D.length;\n          D.push(l);\n          z.chartCount++;\n          p && t(p, function (a, b) {\n            Q(a) && w(l, b, a);\n          });\n          l.xAxis = [];\n          l.yAxis = [];\n          l.pointCount = l.colorCounter = l.symbolCounter = 0;\n          G(l, \"afterInit\");\n          l.firstRender();\n        });\n      };\n\n      f.prototype.initSeries = function (a) {\n        var b = this.options.chart;\n        b = a.type || b.type || b.defaultSeriesType;\n        var c = m.seriesTypes[b];\n        c || p(17, !0, this, {\n          missingModuleFor: b\n        });\n        b = new c(this, a);\n        \"function\" === typeof b.init && b.init(this, a);\n        return b;\n      };\n\n      f.prototype.setSeriesData = function () {\n        this.getSeriesOrderByLinks().forEach(function (a) {\n          a.points || a.data || !a.enabledDataSorting || a.setData(a.options.data, !1);\n        });\n      };\n\n      f.prototype.getSeriesOrderByLinks = function () {\n        return this.series.concat().sort(function (a, b) {\n          return a.linkedSeries.length || b.linkedSeries.length ? b.linkedSeries.length - a.linkedSeries.length : 0;\n        });\n      };\n\n      f.prototype.orderSeries = function (a) {\n        var b = this.series;\n\n        for (a = a || 0; a < b.length; a++) b[a] && (b[a].index = a, b[a].name = b[a].getName());\n      };\n\n      f.prototype.isInsidePlot = function (a, b, c) {\n        var d = c ? b : a;\n        a = c ? a : b;\n        d = {\n          x: d,\n          y: a,\n          isInsidePlot: 0 <= d && d <= this.plotWidth && 0 <= a && a <= this.plotHeight\n        };\n        G(this, \"afterIsInsidePlot\", d);\n        return d.isInsidePlot;\n      };\n\n      f.prototype.redraw = function (a) {\n        G(this, \"beforeRedraw\");\n        var b = this,\n            c = b.axes,\n            d = b.series,\n            g = b.pointer,\n            k = b.legend,\n            e = b.userOptions.legend,\n            f = b.isDirtyLegend,\n            t = b.hasCartesianSeries,\n            p = b.isDirtyBox,\n            l = b.renderer,\n            q = l.isHidden(),\n            h = [];\n        b.setResponsive && b.setResponsive(!1);\n        x(b.hasRendered ? a : !1, b);\n        q && b.temporaryDisplay();\n        b.layOutTitles();\n\n        for (a = d.length; a--;) {\n          var n = d[a];\n\n          if (n.options.stacking) {\n            var u = !0;\n\n            if (n.isDirty) {\n              var r = !0;\n              break;\n            }\n          }\n        }\n\n        if (r) for (a = d.length; a--;) n = d[a], n.options.stacking && (n.isDirty = !0);\n        d.forEach(function (a) {\n          a.isDirty && (\"point\" === a.options.legendType ? (\"function\" === typeof a.updateTotals && a.updateTotals(), f = !0) : e && (e.labelFormatter || e.labelFormat) && (f = !0));\n          a.isDirtyData && G(a, \"updatedData\");\n        });\n        f && k && k.options.enabled && (k.render(), b.isDirtyLegend = !1);\n        u && b.getStacks();\n        t && c.forEach(function (a) {\n          b.isResizing && O(a.min) || (a.updateNames(), a.setScale());\n        });\n        b.getMargins();\n        t && (c.forEach(function (a) {\n          a.isDirty && (p = !0);\n        }), c.forEach(function (a) {\n          var b = a.min + \",\" + a.max;\n          a.extKey !== b && (a.extKey = b, h.push(function () {\n            G(a, \"afterSetExtremes\", B(a.eventArgs, a.getExtremes()));\n            delete a.eventArgs;\n          }));\n          (p || u) && a.redraw();\n        }));\n        p && b.drawChartBox();\n        G(b, \"predraw\");\n        d.forEach(function (a) {\n          (p || a.isDirty) && a.visible && a.redraw();\n          a.isDirtyData = !1;\n        });\n        g && g.reset(!0);\n        l.draw();\n        G(b, \"redraw\");\n        G(b, \"render\");\n        q && b.temporaryDisplay(!0);\n        h.forEach(function (a) {\n          a.call();\n        });\n      };\n\n      f.prototype.get = function (a) {\n        function b(b) {\n          return b.id === a || b.options && b.options.id === a;\n        }\n\n        var c = this.series,\n            d;\n        var g = A(this.axes, b) || A(this.series, b);\n\n        for (d = 0; !g && d < c.length; d++) g = A(c[d].points || [], b);\n\n        return g;\n      };\n\n      f.prototype.getAxes = function () {\n        var a = this,\n            b = this.options,\n            c = b.xAxis = aa(b.xAxis || {});\n        b = b.yAxis = aa(b.yAxis || {});\n        G(this, \"getAxes\");\n        c.forEach(function (a, b) {\n          a.index = b;\n          a.isX = !0;\n        });\n        b.forEach(function (a, b) {\n          a.index = b;\n        });\n        c.concat(b).forEach(function (b) {\n          new h(a, b);\n        });\n        G(this, \"afterGetAxes\");\n      };\n\n      f.prototype.getSelectedPoints = function () {\n        var a = [];\n        this.series.forEach(function (b) {\n          a = a.concat(b.getPointsCollection().filter(function (a) {\n            return H(a.selectedStaging, a.selected);\n          }));\n        });\n        return a;\n      };\n\n      f.prototype.getSelectedSeries = function () {\n        return this.series.filter(function (a) {\n          return a.selected;\n        });\n      };\n\n      f.prototype.setTitle = function (a, b, c) {\n        this.applyDescription(\"title\", a);\n        this.applyDescription(\"subtitle\", b);\n        this.applyDescription(\"caption\", void 0);\n        this.layOutTitles(c);\n      };\n\n      f.prototype.applyDescription = function (a, c) {\n        var d = this,\n            g = \"title\" === a ? {\n          color: \"#333333\",\n          fontSize: this.options.isStock ? \"16px\" : \"18px\"\n        } : {\n          color: \"#666666\"\n        };\n        g = this.options[a] = b(!this.styledMode && {\n          style: g\n        }, this.options[a], c);\n        var k = this[a];\n        k && c && (this[a] = k = k.destroy());\n        g && !k && (k = this.renderer.text(g.text, 0, 0, g.useHTML).attr({\n          align: g.align,\n          \"class\": \"highcharts-\" + a,\n          zIndex: g.zIndex || 4\n        }).add(), k.update = function (b) {\n          d[{\n            title: \"setTitle\",\n            subtitle: \"setSubtitle\",\n            caption: \"setCaption\"\n          }[a]](b);\n        }, this.styledMode || k.css(g.style), this[a] = k);\n      };\n\n      f.prototype.layOutTitles = function (a) {\n        var b = [0, 0, 0],\n            c = this.renderer,\n            d = this.spacingBox;\n        [\"title\", \"subtitle\", \"caption\"].forEach(function (a) {\n          var g = this[a],\n              k = this.options[a],\n              e = k.verticalAlign || \"top\";\n          a = \"title\" === a ? -3 : \"top\" === e ? b[0] + 2 : 0;\n\n          if (g) {\n            if (!this.styledMode) var f = k.style.fontSize;\n            f = c.fontMetrics(f, g).b;\n            g.css({\n              width: (k.width || d.width + (k.widthAdjust || 0)) + \"px\"\n            });\n            var t = Math.round(g.getBBox(k.useHTML).height);\n            g.align(B({\n              y: \"bottom\" === e ? f : a + f,\n              height: t\n            }, k), !1, \"spacingBox\");\n            k.floating || (\"top\" === e ? b[0] = Math.ceil(b[0] + t) : \"bottom\" === e && (b[2] = Math.ceil(b[2] + t)));\n          }\n        }, this);\n        b[0] && \"top\" === (this.options.title.verticalAlign || \"top\") && (b[0] += this.options.title.margin);\n        b[2] && \"bottom\" === this.options.caption.verticalAlign && (b[2] += this.options.caption.margin);\n        var g = !this.titleOffset || this.titleOffset.join(\",\") !== b.join(\",\");\n        this.titleOffset = b;\n        G(this, \"afterLayOutTitles\");\n        !this.isDirtyBox && g && (this.isDirtyBox = this.isDirtyLegend = g, this.hasRendered && H(a, !0) && this.isDirtyBox && this.redraw());\n      };\n\n      f.prototype.getChartSize = function () {\n        var a = this.options.chart,\n            b = a.width;\n        a = a.height;\n        var d = this.renderTo;\n        c(b) || (this.containerWidth = M(d, \"width\"));\n        c(a) || (this.containerHeight = M(d, \"height\"));\n        this.chartWidth = Math.max(0, b || this.containerWidth || 600);\n        this.chartHeight = Math.max(0, U(a, this.chartWidth) || (1 < this.containerHeight ? this.containerHeight : 400));\n      };\n\n      f.prototype.temporaryDisplay = function (a) {\n        var b = this.renderTo;\n        if (a) for (; b && b.style;) b.hcOrigStyle && (g(b, b.hcOrigStyle), delete b.hcOrigStyle), b.hcOrigDetached && (n.body.removeChild(b), b.hcOrigDetached = !1), b = b.parentNode;else for (; b && b.style;) {\n          n.body.contains(b) || b.parentNode || (b.hcOrigDetached = !0, n.body.appendChild(b));\n          if (\"none\" === M(b, \"display\", !1) || b.hcOricDetached) b.hcOrigStyle = {\n            display: b.style.display,\n            height: b.style.height,\n            overflow: b.style.overflow\n          }, a = {\n            display: \"block\",\n            overflow: \"hidden\"\n          }, b !== this.renderTo && (a.height = 0), g(b, a), b.offsetWidth || b.style.setProperty(\"display\", \"block\", \"important\");\n          b = b.parentNode;\n          if (b === n.body) break;\n        }\n      };\n\n      f.prototype.setClassName = function (a) {\n        this.container.className = \"highcharts-container \" + (a || \"\");\n      };\n\n      f.prototype.getContainer = function () {\n        var a = this.options,\n            b = a.chart;\n        var c = this.renderTo;\n        var k = S(),\n            e,\n            f;\n        c || (this.renderTo = c = b.renderTo);\n        u(c) && (this.renderTo = c = n.getElementById(c));\n        c || p(13, !0, this);\n        var t = R(r(c, \"data-highcharts-chart\"));\n        O(t) && D[t] && D[t].hasRendered && D[t].destroy();\n        r(c, \"data-highcharts-chart\", this.index);\n        c.innerHTML = \"\";\n        b.skipClone || c.offsetWidth || this.temporaryDisplay();\n        this.getChartSize();\n        t = this.chartWidth;\n        var l = this.chartHeight;\n        g(c, {\n          overflow: \"hidden\"\n        });\n        this.styledMode || (e = B({\n          position: \"relative\",\n          overflow: \"hidden\",\n          width: t + \"px\",\n          height: l + \"px\",\n          textAlign: \"left\",\n          lineHeight: \"normal\",\n          zIndex: 0,\n          \"-webkit-tap-highlight-color\": \"rgba(0,0,0,0)\",\n          userSelect: \"none\"\n        }, b.style));\n        this.container = c = d(\"div\", {\n          id: k\n        }, e, c);\n        this._cursor = c.style.cursor;\n        this.renderer = new (z[b.renderer] || z.Renderer)(c, t, l, null, b.forExport, a.exporting && a.exporting.allowHTML, this.styledMode);\n        x(void 0, this);\n        this.setClassName(b.className);\n        if (this.styledMode) for (f in a.defs) this.renderer.definition(a.defs[f]);else this.renderer.setStyle(b.style);\n        this.renderer.chartIndex = this.index;\n        G(this, \"afterGetContainer\");\n      };\n\n      f.prototype.getMargins = function (a) {\n        var b = this.spacing,\n            d = this.margin,\n            g = this.titleOffset;\n        this.resetMargins();\n        g[0] && !c(d[0]) && (this.plotTop = Math.max(this.plotTop, g[0] + b[0]));\n        g[2] && !c(d[2]) && (this.marginBottom = Math.max(this.marginBottom, g[2] + b[2]));\n        this.legend && this.legend.display && this.legend.adjustMargins(d, b);\n        G(this, \"getMargins\");\n        a || this.getAxisMargins();\n      };\n\n      f.prototype.getAxisMargins = function () {\n        var a = this,\n            b = a.axisOffset = [0, 0, 0, 0],\n            d = a.colorAxis,\n            g = a.margin,\n            k = function (a) {\n          a.forEach(function (a) {\n            a.visible && a.getOffset();\n          });\n        };\n\n        a.hasCartesianSeries ? k(a.axes) : d && d.length && k(d);\n        Y.forEach(function (d, k) {\n          c(g[k]) || (a[d] += b[k]);\n        });\n        a.setChartSize();\n      };\n\n      f.prototype.reflow = function (a) {\n        var b = this,\n            d = b.options.chart,\n            g = b.renderTo,\n            k = c(d.width) && c(d.height),\n            f = d.width || M(g, \"width\");\n        d = d.height || M(g, \"height\");\n        g = a ? a.target : l;\n\n        if (!k && !b.isPrinting && f && d && (g === l || g === n)) {\n          if (f !== b.containerWidth || d !== b.containerHeight) e.clearTimeout(b.reflowTimeout), b.reflowTimeout = ba(function () {\n            b.container && b.setSize(void 0, void 0, !1);\n          }, a ? 100 : 0);\n          b.containerWidth = f;\n          b.containerHeight = d;\n        }\n      };\n\n      f.prototype.setReflow = function (a) {\n        var b = this;\n        !1 === a || this.unbindReflow ? !1 === a && this.unbindReflow && (this.unbindReflow = this.unbindReflow()) : (this.unbindReflow = w(l, \"resize\", function (a) {\n          b.options && b.reflow(a);\n        }), w(this, \"destroy\", this.unbindReflow));\n      };\n\n      f.prototype.setSize = function (a, b, c) {\n        var d = this,\n            k = d.renderer;\n        d.isResizing += 1;\n        x(c, d);\n        c = k.globalAnimation;\n        d.oldChartHeight = d.chartHeight;\n        d.oldChartWidth = d.chartWidth;\n        \"undefined\" !== typeof a && (d.options.chart.width = a);\n        \"undefined\" !== typeof b && (d.options.chart.height = b);\n        d.getChartSize();\n        d.styledMode || (c ? I : g)(d.container, {\n          width: d.chartWidth + \"px\",\n          height: d.chartHeight + \"px\"\n        }, c);\n        d.setChartSize(!0);\n        k.setSize(d.chartWidth, d.chartHeight, c);\n        d.axes.forEach(function (a) {\n          a.isDirty = !0;\n          a.setScale();\n        });\n        d.isDirtyLegend = !0;\n        d.isDirtyBox = !0;\n        d.layOutTitles();\n        d.getMargins();\n        d.redraw(c);\n        d.oldChartHeight = null;\n        G(d, \"resize\");\n        ba(function () {\n          d && G(d, \"endResize\", null, function () {\n            --d.isResizing;\n          });\n        }, v(c).duration);\n      };\n\n      f.prototype.setChartSize = function (a) {\n        var b = this.inverted,\n            c = this.renderer,\n            d = this.chartWidth,\n            g = this.chartHeight,\n            k = this.options.chart,\n            e = this.spacing,\n            f = this.clipOffset,\n            t,\n            p,\n            l,\n            q;\n        this.plotLeft = t = Math.round(this.plotLeft);\n        this.plotTop = p = Math.round(this.plotTop);\n        this.plotWidth = l = Math.max(0, Math.round(d - t - this.marginRight));\n        this.plotHeight = q = Math.max(0, Math.round(g - p - this.marginBottom));\n        this.plotSizeX = b ? q : l;\n        this.plotSizeY = b ? l : q;\n        this.plotBorderWidth = k.plotBorderWidth || 0;\n        this.spacingBox = c.spacingBox = {\n          x: e[3],\n          y: e[0],\n          width: d - e[3] - e[1],\n          height: g - e[0] - e[2]\n        };\n        this.plotBox = c.plotBox = {\n          x: t,\n          y: p,\n          width: l,\n          height: q\n        };\n        d = 2 * Math.floor(this.plotBorderWidth / 2);\n        b = Math.ceil(Math.max(d, f[3]) / 2);\n        c = Math.ceil(Math.max(d, f[0]) / 2);\n        this.clipBox = {\n          x: b,\n          y: c,\n          width: Math.floor(this.plotSizeX - Math.max(d, f[1]) / 2 - b),\n          height: Math.max(0, Math.floor(this.plotSizeY - Math.max(d, f[2]) / 2 - c))\n        };\n        a || this.axes.forEach(function (a) {\n          a.setAxisSize();\n          a.setAxisTranslation();\n        });\n        G(this, \"afterSetChartSize\", {\n          skipAxes: a\n        });\n      };\n\n      f.prototype.resetMargins = function () {\n        G(this, \"resetMargins\");\n        var a = this,\n            b = a.options.chart;\n        [\"margin\", \"spacing\"].forEach(function (c) {\n          var d = b[c],\n              g = E(d) ? d : [d, d, d, d];\n          [\"Top\", \"Right\", \"Bottom\", \"Left\"].forEach(function (d, k) {\n            a[c][k] = H(b[c + d], g[k]);\n          });\n        });\n        Y.forEach(function (b, c) {\n          a[b] = H(a.margin[c], a.spacing[c]);\n        });\n        a.axisOffset = [0, 0, 0, 0];\n        a.clipOffset = [0, 0, 0, 0];\n      };\n\n      f.prototype.drawChartBox = function () {\n        var a = this.options.chart,\n            b = this.renderer,\n            c = this.chartWidth,\n            d = this.chartHeight,\n            g = this.chartBackground,\n            k = this.plotBackground,\n            e = this.plotBorder,\n            f = this.styledMode,\n            t = this.plotBGImage,\n            p = a.backgroundColor,\n            l = a.plotBackgroundColor,\n            q = a.plotBackgroundImage,\n            h,\n            n = this.plotLeft,\n            u = this.plotTop,\n            r = this.plotWidth,\n            m = this.plotHeight,\n            w = this.plotBox,\n            v = this.clipRect,\n            H = this.clipBox,\n            B = \"animate\";\n        g || (this.chartBackground = g = b.rect().addClass(\"highcharts-background\").add(), B = \"attr\");\n        if (f) var A = h = g.strokeWidth();else {\n          A = a.borderWidth || 0;\n          h = A + (a.shadow ? 8 : 0);\n          p = {\n            fill: p || \"none\"\n          };\n          if (A || g[\"stroke-width\"]) p.stroke = a.borderColor, p[\"stroke-width\"] = A;\n          g.attr(p).shadow(a.shadow);\n        }\n        g[B]({\n          x: h / 2,\n          y: h / 2,\n          width: c - h - A % 2,\n          height: d - h - A % 2,\n          r: a.borderRadius\n        });\n        B = \"animate\";\n        k || (B = \"attr\", this.plotBackground = k = b.rect().addClass(\"highcharts-plot-background\").add());\n        k[B](w);\n        f || (k.attr({\n          fill: l || \"none\"\n        }).shadow(a.plotShadow), q && (t ? (q !== t.attr(\"href\") && t.attr(\"href\", q), t.animate(w)) : this.plotBGImage = b.image(q, n, u, r, m).add()));\n        v ? v.animate({\n          width: H.width,\n          height: H.height\n        }) : this.clipRect = b.clipRect(H);\n        B = \"animate\";\n        e || (B = \"attr\", this.plotBorder = e = b.rect().addClass(\"highcharts-plot-border\").attr({\n          zIndex: 1\n        }).add());\n        f || e.attr({\n          stroke: a.plotBorderColor,\n          \"stroke-width\": a.plotBorderWidth || 0,\n          fill: \"none\"\n        });\n        e[B](e.crisp({\n          x: n,\n          y: u,\n          width: r,\n          height: m\n        }, -e.strokeWidth()));\n        this.isDirtyBox = !1;\n        G(this, \"afterDrawChartBox\");\n      };\n\n      f.prototype.propFromSeries = function () {\n        var a = this,\n            b = a.options.chart,\n            c,\n            d = a.options.series,\n            g,\n            k;\n        [\"inverted\", \"angular\", \"polar\"].forEach(function (e) {\n          c = m.seriesTypes[b.type || b.defaultSeriesType];\n          k = b[e] || c && c.prototype[e];\n\n          for (g = d && d.length; !k && g--;) (c = m.seriesTypes[d[g].type]) && c.prototype[e] && (k = !0);\n\n          a[e] = k;\n        });\n      };\n\n      f.prototype.linkSeries = function () {\n        var a = this,\n            b = a.series;\n        b.forEach(function (a) {\n          a.linkedSeries.length = 0;\n        });\n        b.forEach(function (b) {\n          var c = b.options.linkedTo;\n          u(c) && (c = \":previous\" === c ? a.series[b.index - 1] : a.get(c)) && c.linkedParent !== b && (c.linkedSeries.push(b), b.linkedParent = c, c.enabledDataSorting && b.setDataSortingOptions(), b.visible = H(b.options.visible, c.options.visible, b.visible));\n        });\n        G(this, \"afterLinkSeries\");\n      };\n\n      f.prototype.renderSeries = function () {\n        this.series.forEach(function (a) {\n          a.translate();\n          a.render();\n        });\n      };\n\n      f.prototype.renderLabels = function () {\n        var a = this,\n            b = a.options.labels;\n        b.items && b.items.forEach(function (c) {\n          var d = B(b.style, c.style),\n              g = R(d.left) + a.plotLeft,\n              k = R(d.top) + a.plotTop + 12;\n          delete d.left;\n          delete d.top;\n          a.renderer.text(c.html, g, k).attr({\n            zIndex: 2\n          }).css(d).add();\n        });\n      };\n\n      f.prototype.render = function () {\n        var a = this.axes,\n            b = this.colorAxis,\n            c = this.renderer,\n            d = this.options,\n            g = 0,\n            k = function (a) {\n          a.forEach(function (a) {\n            a.visible && a.render();\n          });\n        };\n\n        this.setTitle();\n        this.legend = new F(this, d.legend);\n        this.getStacks && this.getStacks();\n        this.getMargins(!0);\n        this.setChartSize();\n        d = this.plotWidth;\n        a.some(function (a) {\n          if (a.horiz && a.visible && a.options.labels.enabled && a.series.length) return g = 21, !0;\n        });\n        var e = this.plotHeight = Math.max(this.plotHeight - g, 0);\n        a.forEach(function (a) {\n          a.setScale();\n        });\n        this.getAxisMargins();\n        var f = 1.1 < d / this.plotWidth;\n        var t = 1.05 < e / this.plotHeight;\n        if (f || t) a.forEach(function (a) {\n          (a.horiz && f || !a.horiz && t) && a.setTickInterval(!0);\n        }), this.getMargins();\n        this.drawChartBox();\n        this.hasCartesianSeries ? k(a) : b && b.length && k(b);\n        this.seriesGroup || (this.seriesGroup = c.g(\"series-group\").attr({\n          zIndex: 3\n        }).add());\n        this.renderSeries();\n        this.renderLabels();\n        this.addCredits();\n        this.setResponsive && this.setResponsive();\n        this.updateContainerScaling();\n        this.hasRendered = !0;\n      };\n\n      f.prototype.addCredits = function (a) {\n        var c = this,\n            d = b(!0, this.options.credits, a);\n        d.enabled && !this.credits && (this.credits = this.renderer.text(d.text + (this.mapCredits || \"\"), 0, 0).addClass(\"highcharts-credits\").on(\"click\", function () {\n          d.href && (l.location.href = d.href);\n        }).attr({\n          align: d.position.align,\n          zIndex: 8\n        }), c.styledMode || this.credits.css(d.style), this.credits.add().align(d.position), this.credits.update = function (a) {\n          c.credits = c.credits.destroy();\n          c.addCredits(a);\n        });\n      };\n\n      f.prototype.updateContainerScaling = function () {\n        var a = this.container;\n\n        if (2 < a.offsetWidth && 2 < a.offsetHeight && a.getBoundingClientRect) {\n          var b = a.getBoundingClientRect(),\n              c = b.width / a.offsetWidth;\n          a = b.height / a.offsetHeight;\n          1 !== c || 1 !== a ? this.containerScaling = {\n            scaleX: c,\n            scaleY: a\n          } : delete this.containerScaling;\n        }\n      };\n\n      f.prototype.destroy = function () {\n        var b = this,\n            c = b.axes,\n            d = b.series,\n            g = b.container,\n            k,\n            e = g && g.parentNode;\n        G(b, \"destroy\");\n        b.renderer.forExport ? q(D, b) : D[b.index] = void 0;\n        z.chartCount--;\n        b.renderTo.removeAttribute(\"data-highcharts-chart\");\n        Z(b);\n\n        for (k = c.length; k--;) c[k] = c[k].destroy();\n\n        this.scroller && this.scroller.destroy && this.scroller.destroy();\n\n        for (k = d.length; k--;) d[k] = d[k].destroy();\n\n        \"title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer\".split(\" \").forEach(function (a) {\n          var c = b[a];\n          c && c.destroy && (b[a] = c.destroy());\n        });\n        g && (g.innerHTML = \"\", Z(g), e && a(g));\n        t(b, function (a, c) {\n          delete b[c];\n        });\n      };\n\n      f.prototype.firstRender = function () {\n        var a = this,\n            b = a.options;\n\n        if (!a.isReadyToRender || a.isReadyToRender()) {\n          a.getContainer();\n          a.resetMargins();\n          a.setChartSize();\n          a.propFromSeries();\n          a.getAxes();\n          (T(b.series) ? b.series : []).forEach(function (b) {\n            a.initSeries(b);\n          });\n          a.linkSeries();\n          a.setSeriesData();\n          G(a, \"beforeRender\");\n          C && (a.pointer = z.hasTouch || !l.PointerEvent && !l.MSPointerEvent ? new C(a, b) : new L(a, b));\n          a.render();\n          if (!a.renderer.imgCount && !a.hasLoaded) a.onload();\n          a.temporaryDisplay(!0);\n        }\n      };\n\n      f.prototype.onload = function () {\n        this.callbacks.concat([this.callback]).forEach(function (a) {\n          a && \"undefined\" !== typeof this.index && a.apply(this, [this]);\n        }, this);\n        G(this, \"load\");\n        G(this, \"render\");\n        c(this.index) && this.setReflow(this.options.chart.reflow);\n        this.hasLoaded = !0;\n      };\n\n      return f;\n    }();\n\n    W.prototype.callbacks = [];\n\n    z.chart = function (a, b, c) {\n      return new W(a, b, c);\n    };\n\n    return z.Chart = W;\n  });\n  N(m, \"Extensions/ScrollablePlotArea.js\", [m[\"Core/Animation/AnimationUtilities.js\"], m[\"Core/Chart/Chart.js\"], m[\"Core/Globals.js\"], m[\"Core/Utilities.js\"]], function (f, h, m, z) {\n    var F = f.stop,\n        L = z.addEvent,\n        K = z.createElement,\n        C = z.pick;\n    \"\";\n    L(h, \"afterSetChartSize\", function (f) {\n      var e = this.options.chart.scrollablePlotArea,\n          h = e && e.minWidth;\n      e = e && e.minHeight;\n\n      if (!this.renderer.forExport) {\n        if (h) {\n          if (this.scrollablePixelsX = h = Math.max(0, h - this.chartWidth)) {\n            this.plotWidth += h;\n            this.inverted ? (this.clipBox.height += h, this.plotBox.height += h) : (this.clipBox.width += h, this.plotBox.width += h);\n            var v = {\n              1: {\n                name: \"right\",\n                value: h\n              }\n            };\n          }\n        } else e && (this.scrollablePixelsY = h = Math.max(0, e - this.chartHeight)) && (this.plotHeight += h, this.inverted ? (this.clipBox.width += h, this.plotBox.width += h) : (this.clipBox.height += h, this.plotBox.height += h), v = {\n          2: {\n            name: \"bottom\",\n            value: h\n          }\n        });\n\n        v && !f.skipAxes && this.axes.forEach(function (e) {\n          v[e.side] ? e.getPlotLinePath = function () {\n            var f = v[e.side].name,\n                h = this[f];\n            this[f] = h - v[e.side].value;\n            var l = m.Axis.prototype.getPlotLinePath.apply(this, arguments);\n            this[f] = h;\n            return l;\n          } : (e.setAxisSize(), e.setAxisTranslation());\n        });\n      }\n    });\n    L(h, \"render\", function () {\n      this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();\n    });\n\n    h.prototype.setUpScrolling = function () {\n      var f = this,\n          e = {\n        WebkitOverflowScrolling: \"touch\",\n        overflowX: \"hidden\",\n        overflowY: \"hidden\"\n      };\n      this.scrollablePixelsX && (e.overflowX = \"auto\");\n      this.scrollablePixelsY && (e.overflowY = \"auto\");\n      this.scrollingParent = K(\"div\", {\n        className: \"highcharts-scrolling-parent\"\n      }, {\n        position: \"relative\"\n      }, this.renderTo);\n      this.scrollingContainer = K(\"div\", {\n        className: \"highcharts-scrolling\"\n      }, e, this.scrollingParent);\n      L(this.scrollingContainer, \"scroll\", function () {\n        f.pointer && delete f.pointer.chartPosition;\n      });\n      this.innerContainer = K(\"div\", {\n        className: \"highcharts-inner-container\"\n      }, null, this.scrollingContainer);\n      this.innerContainer.appendChild(this.container);\n      this.setUpScrolling = null;\n    };\n\n    h.prototype.moveFixedElements = function () {\n      var f = this.container,\n          e = this.fixedRenderer,\n          h = \".highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-legend-checkbox .highcharts-navigator-series .highcharts-navigator-xaxis .highcharts-navigator-yaxis .highcharts-navigator .highcharts-reset-zoom .highcharts-scrollbar .highcharts-subtitle .highcharts-title\".split(\" \"),\n          m;\n      this.scrollablePixelsX && !this.inverted ? m = \".highcharts-yaxis\" : this.scrollablePixelsX && this.inverted ? m = \".highcharts-xaxis\" : this.scrollablePixelsY && !this.inverted ? m = \".highcharts-xaxis\" : this.scrollablePixelsY && this.inverted && (m = \".highcharts-yaxis\");\n      h.push(m, m + \"-labels\");\n      h.forEach(function (h) {\n        [].forEach.call(f.querySelectorAll(h), function (f) {\n          (f.namespaceURI === e.SVG_NS ? e.box : e.box.parentNode).appendChild(f);\n          f.style.pointerEvents = \"auto\";\n        });\n      });\n    };\n\n    h.prototype.applyFixed = function () {\n      var f,\n          e,\n          h = !this.fixedDiv,\n          v = this.options.chart.scrollablePlotArea;\n      h ? (this.fixedDiv = K(\"div\", {\n        className: \"highcharts-fixed\"\n      }, {\n        position: \"absolute\",\n        overflow: \"hidden\",\n        pointerEvents: \"none\",\n        zIndex: 2,\n        top: 0\n      }, null, !0), null === (f = this.scrollingContainer) || void 0 === f ? void 0 : f.parentNode.insertBefore(this.fixedDiv, this.scrollingContainer), this.renderTo.style.overflow = \"visible\", this.fixedRenderer = f = new m.Renderer(this.fixedDiv, this.chartWidth, this.chartHeight, null === (e = this.options.chart) || void 0 === e ? void 0 : e.style), this.scrollableMask = f.path().attr({\n        fill: this.options.chart.backgroundColor || \"#fff\",\n        \"fill-opacity\": C(v.opacity, .85),\n        zIndex: -1\n      }).addClass(\"highcharts-scrollable-mask\").add(), this.moveFixedElements(), L(this, \"afterShowResetZoom\", this.moveFixedElements), L(this, \"afterLayOutTitles\", this.moveFixedElements)) : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);\n      e = this.chartWidth + (this.scrollablePixelsX || 0);\n      f = this.chartHeight + (this.scrollablePixelsY || 0);\n      F(this.container);\n      this.container.style.width = e + \"px\";\n      this.container.style.height = f + \"px\";\n      this.renderer.boxWrapper.attr({\n        width: e,\n        height: f,\n        viewBox: [0, 0, e, f].join(\" \")\n      });\n      this.chartBackground.attr({\n        width: e,\n        height: f\n      });\n      this.scrollingContainer.style.height = this.chartHeight + \"px\";\n      h && (v.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixelsX * v.scrollPositionX), v.scrollPositionY && (this.scrollingContainer.scrollTop = this.scrollablePixelsY * v.scrollPositionY));\n      f = this.axisOffset;\n      h = this.plotTop - f[0] - 1;\n      v = this.plotLeft - f[3] - 1;\n      e = this.plotTop + this.plotHeight + f[2] + 1;\n      f = this.plotLeft + this.plotWidth + f[1] + 1;\n      var x = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0),\n          D = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0);\n      h = this.scrollablePixelsX ? [[\"M\", 0, h], [\"L\", this.plotLeft - 1, h], [\"L\", this.plotLeft - 1, e], [\"L\", 0, e], [\"Z\"], [\"M\", x, h], [\"L\", this.chartWidth, h], [\"L\", this.chartWidth, e], [\"L\", x, e], [\"Z\"]] : this.scrollablePixelsY ? [[\"M\", v, 0], [\"L\", v, this.plotTop - 1], [\"L\", f, this.plotTop - 1], [\"L\", f, 0], [\"Z\"], [\"M\", v, D], [\"L\", v, this.chartHeight], [\"L\", f, this.chartHeight], [\"L\", f, D], [\"Z\"]] : [[\"M\", 0, 0]];\n      \"adjustHeight\" !== this.redrawTrigger && this.scrollableMask.attr({\n        d: h\n      });\n    };\n  });\n  N(m, \"Core/Axis/StackingAxis.js\", [m[\"Core/Animation/AnimationUtilities.js\"], m[\"Core/Utilities.js\"]], function (f, h) {\n    var m = f.getDeferredAnimation,\n        z = h.addEvent,\n        F = h.destroyObjectProperties,\n        L = h.fireEvent,\n        K = h.objectEach,\n        C = h.pick,\n        y = function () {\n      function e(e) {\n        this.oldStacks = {};\n        this.stacks = {};\n        this.stacksTouched = 0;\n        this.axis = e;\n      }\n\n      e.prototype.buildStacks = function () {\n        var e = this.axis,\n            f = e.series,\n            h = C(e.options.reversedStacks, !0),\n            m = f.length,\n            n;\n\n        if (!e.isXAxis) {\n          this.usePercentage = !1;\n\n          for (n = m; n--;) {\n            var l = f[h ? n : m - n - 1];\n            l.setStackedPoints();\n            l.setGroupedPoints();\n          }\n\n          for (n = 0; n < m; n++) f[n].modifyStacks();\n\n          L(e, \"afterBuildStacks\");\n        }\n      };\n\n      e.prototype.cleanStacks = function () {\n        if (!this.axis.isXAxis) {\n          if (this.oldStacks) var e = this.stacks = this.oldStacks;\n          K(e, function (e) {\n            K(e, function (e) {\n              e.cumulative = e.total;\n            });\n          });\n        }\n      };\n\n      e.prototype.resetStacks = function () {\n        var e = this,\n            f = e.stacks;\n        e.axis.isXAxis || K(f, function (f) {\n          K(f, function (h, n) {\n            h.touched < e.stacksTouched ? (h.destroy(), delete f[n]) : (h.total = null, h.cumulative = null);\n          });\n        });\n      };\n\n      e.prototype.renderStackTotals = function () {\n        var e = this.axis,\n            f = e.chart,\n            h = f.renderer,\n            D = this.stacks;\n        e = m(f, e.options.stackLabels.animation);\n        var n = this.stackTotalGroup = this.stackTotalGroup || h.g(\"stack-labels\").attr({\n          visibility: \"visible\",\n          zIndex: 6,\n          opacity: 0\n        }).add();\n        n.translate(f.plotLeft, f.plotTop);\n        K(D, function (e) {\n          K(e, function (e) {\n            e.render(n);\n          });\n        });\n        n.animate({\n          opacity: 1\n        }, e);\n      };\n\n      return e;\n    }();\n\n    return function () {\n      function e() {}\n\n      e.compose = function (f) {\n        z(f, \"init\", e.onInit);\n        z(f, \"destroy\", e.onDestroy);\n      };\n\n      e.onDestroy = function () {\n        var e = this.stacking;\n\n        if (e) {\n          var f = e.stacks;\n          K(f, function (e, h) {\n            F(e);\n            f[h] = null;\n          });\n          e && e.stackTotalGroup && e.stackTotalGroup.destroy();\n        }\n      };\n\n      e.onInit = function () {\n        this.stacking || (this.stacking = new y(this));\n      };\n\n      return e;\n    }();\n  });\n  N(m, \"Mixins/LegendSymbol.js\", [m[\"Core/Globals.js\"], m[\"Core/Utilities.js\"]], function (f, h) {\n    var m = h.merge,\n        z = h.pick;\n    return f.LegendSymbolMixin = {\n      drawRectangle: function (f, h) {\n        var m = f.symbolHeight,\n            C = f.options.squareSymbol;\n        h.legendSymbol = this.chart.renderer.rect(C ? (f.symbolWidth - m) / 2 : 0, f.baseline - m + 1, C ? m : f.symbolWidth, m, z(f.options.symbolRadius, m / 2)).addClass(\"highcharts-point\").attr({\n          zIndex: 3\n        }).add(h.legendGroup);\n      },\n      drawLineMarker: function (f) {\n        var h = this.options,\n            F = h.marker,\n            C = f.symbolWidth,\n            y = f.symbolHeight,\n            e = y / 2,\n            I = this.chart.renderer,\n            v = this.legendGroup;\n        f = f.baseline - Math.round(.3 * f.fontMetrics.b);\n        var x = {};\n        this.chart.styledMode || (x = {\n          \"stroke-width\": h.lineWidth || 0\n        }, h.dashStyle && (x.dashstyle = h.dashStyle));\n        this.legendLine = I.path([[\"M\", 0, f], [\"L\", C, f]]).addClass(\"highcharts-graph\").attr(x).add(v);\n        F && !1 !== F.enabled && C && (h = Math.min(z(F.radius, e), e), 0 === this.symbol.indexOf(\"url\") && (F = m(F, {\n          width: y,\n          height: y\n        }), h = 0), this.legendSymbol = F = I.symbol(this.symbol, C / 2 - h, f - h, 2 * h, 2 * h, F).addClass(\"highcharts-point\").add(v), F.isMarker = !0);\n      }\n    };\n  });\n  N(m, \"Core/Series/CartesianSeries.js\", [m[\"Core/Animation/AnimationUtilities.js\"], m[\"Core/Series/Series.js\"], m[\"Core/Globals.js\"], m[\"Mixins/LegendSymbol.js\"], m[\"Core/Options.js\"], m[\"Core/Series/Point.js\"], m[\"Core/Renderer/SVG/SVGElement.js\"], m[\"Core/Utilities.js\"]], function (f, h, m, z, F, L, K, C) {\n    var y = f.animObject,\n        e = F.defaultOptions,\n        I = C.addEvent,\n        v = C.arrayMax,\n        x = C.arrayMin,\n        D = C.clamp,\n        n = C.correctFloat,\n        l = C.defined,\n        J = C.erase,\n        w = C.error,\n        r = C.extend,\n        d = C.find,\n        g = C.fireEvent,\n        c = C.getNestedProperty,\n        a = C.isArray,\n        q = C.isFunction,\n        p = C.isNumber,\n        B = C.isString,\n        A = C.merge,\n        G = C.objectEach,\n        M = C.pick,\n        T = C.removeEvent,\n        Q = C.splat,\n        O = C.syncTimeout;\n    \"\";\n    var E = h.seriesTypes,\n        u = m.win;\n    f = h.seriesType(\"line\", void 0, {\n      lineWidth: 2,\n      allowPointSelect: !1,\n      crisp: !0,\n      showCheckbox: !1,\n      animation: {\n        duration: 1E3\n      },\n      events: {},\n      marker: {\n        enabledThreshold: 2,\n        lineColor: \"#ffffff\",\n        lineWidth: 0,\n        radius: 4,\n        states: {\n          normal: {\n            animation: !0\n          },\n          hover: {\n            animation: {\n              duration: 50\n            },\n            enabled: !0,\n            radiusPlus: 2,\n            lineWidthPlus: 1\n          },\n          select: {\n            fillColor: \"#cccccc\",\n            lineColor: \"#000000\",\n            lineWidth: 2\n          }\n        }\n      },\n      point: {\n        events: {}\n      },\n      dataLabels: {\n        animation: {},\n        align: \"center\",\n        defer: !0,\n        formatter: function () {\n          var a = this.series.chart.numberFormatter;\n          return \"number\" !== typeof this.y ? \"\" : a(this.y, -1);\n        },\n        padding: 5,\n        style: {\n          fontSize: \"11px\",\n          fontWeight: \"bold\",\n          color: \"contrast\",\n          textOutline: \"1px contrast\"\n        },\n        verticalAlign: \"bottom\",\n        x: 0,\n        y: 0\n      },\n      cropThreshold: 300,\n      opacity: 1,\n      pointRange: 0,\n      softThreshold: !0,\n      states: {\n        normal: {\n          animation: !0\n        },\n        hover: {\n          animation: {\n            duration: 50\n          },\n          lineWidthPlus: 1,\n          marker: {},\n          halo: {\n            size: 10,\n            opacity: .25\n          }\n        },\n        select: {\n          animation: {\n            duration: 0\n          }\n        },\n        inactive: {\n          animation: {\n            duration: 50\n          },\n          opacity: .2\n        }\n      },\n      stickyTracking: !0,\n      turboThreshold: 1E3,\n      findNearestPointBy: \"x\"\n    }, {\n      axisTypes: [\"xAxis\", \"yAxis\"],\n      coll: \"series\",\n      colorCounter: 0,\n      cropShoulder: 1,\n      directTouch: !1,\n      isCartesian: !0,\n      parallelArrays: [\"x\", \"y\"],\n      pointClass: L,\n      requireSorting: !0,\n      sorted: !0,\n      init: function (a, c) {\n        g(this, \"init\", {\n          options: c\n        });\n        var b = this,\n            d = a.series,\n            k;\n        this.eventOptions = this.eventOptions || {};\n        this.eventsToUnbind = [];\n        b.chart = a;\n        b.options = c = b.setOptions(c);\n        b.linkedSeries = [];\n        b.bindAxes();\n        r(b, {\n          name: c.name,\n          state: \"\",\n          visible: !1 !== c.visible,\n          selected: !0 === c.selected\n        });\n        var e = c.events;\n        G(e, function (a, c) {\n          q(a) && b.eventOptions[c] !== a && (q(b.eventOptions[c]) && T(b, c, b.eventOptions[c]), b.eventOptions[c] = a, I(b, c, a));\n        });\n        if (e && e.click || c.point && c.point.events && c.point.events.click || c.allowPointSelect) a.runTrackerClick = !0;\n        b.getColor();\n        b.getSymbol();\n        b.parallelArrays.forEach(function (a) {\n          b[a + \"Data\"] || (b[a + \"Data\"] = []);\n        });\n        b.isCartesian && (a.hasCartesianSeries = !0);\n        d.length && (k = d[d.length - 1]);\n        b._i = M(k && k._i, -1) + 1;\n        b.opacity = b.options.opacity;\n        a.orderSeries(this.insert(d));\n        c.dataSorting && c.dataSorting.enabled ? b.setDataSortingOptions() : b.points || b.data || b.setData(c.data, !1);\n        g(this, \"afterInit\");\n      },\n      is: function (a) {\n        return E[a] && this instanceof E[a];\n      },\n      insert: function (a) {\n        var b = this.options.index,\n            c;\n\n        if (p(b)) {\n          for (c = a.length; c--;) if (b >= M(a[c].options.index, a[c]._i)) {\n            a.splice(c + 1, 0, this);\n            break;\n          }\n\n          -1 === c && a.unshift(this);\n          c += 1;\n        } else a.push(this);\n\n        return M(c, a.length - 1);\n      },\n      bindAxes: function () {\n        var a = this,\n            c = a.options,\n            d = a.chart,\n            e;\n        g(this, \"bindAxes\", null, function () {\n          (a.axisTypes || []).forEach(function (b) {\n            d[b].forEach(function (d) {\n              e = d.options;\n              if (c[b] === e.index || \"undefined\" !== typeof c[b] && c[b] === e.id || \"undefined\" === typeof c[b] && 0 === e.index) a.insert(d.series), a[b] = d, d.isDirty = !0;\n            });\n            a[b] || a.optionalAxis === b || w(18, !0, d);\n          });\n        });\n        g(this, \"afterBindAxes\");\n      },\n      updateParallelArrays: function (a, c) {\n        var b = a.series,\n            d = arguments,\n            g = p(c) ? function (d) {\n          var g = \"y\" === d && b.toYData ? b.toYData(a) : a[d];\n          b[d + \"Data\"][c] = g;\n        } : function (a) {\n          Array.prototype[c].apply(b[a + \"Data\"], Array.prototype.slice.call(d, 2));\n        };\n        b.parallelArrays.forEach(g);\n      },\n      hasData: function () {\n        return this.visible && \"undefined\" !== typeof this.dataMax && \"undefined\" !== typeof this.dataMin || this.visible && this.yData && 0 < this.yData.length;\n      },\n      autoIncrement: function () {\n        var a = this.options,\n            c = this.xIncrement,\n            d,\n            g = a.pointIntervalUnit,\n            e = this.chart.time;\n        c = M(c, a.pointStart, 0);\n        this.pointInterval = d = M(this.pointInterval, a.pointInterval, 1);\n        g && (a = new e.Date(c), \"day\" === g ? e.set(\"Date\", a, e.get(\"Date\", a) + d) : \"month\" === g ? e.set(\"Month\", a, e.get(\"Month\", a) + d) : \"year\" === g && e.set(\"FullYear\", a, e.get(\"FullYear\", a) + d), d = a.getTime() - c);\n        this.xIncrement = c + d;\n        return c;\n      },\n      setDataSortingOptions: function () {\n        var a = this.options;\n        r(this, {\n          requireSorting: !1,\n          sorted: !1,\n          enabledDataSorting: !0,\n          allowDG: !1\n        });\n        l(a.pointRange) || (a.pointRange = 1);\n      },\n      setOptions: function (a) {\n        var b = this.chart,\n            c = b.options,\n            d = c.plotOptions,\n            f = b.userOptions || {};\n        a = A(a);\n        b = b.styledMode;\n        var p = {\n          plotOptions: d,\n          userOptions: a\n        };\n        g(this, \"setOptions\", p);\n        var h = p.plotOptions[this.type],\n            q = f.plotOptions || {};\n        this.userOptions = p.userOptions;\n        f = A(h, d.series, f.plotOptions && f.plotOptions[this.type], a);\n        this.tooltipOptions = A(e.tooltip, e.plotOptions.series && e.plotOptions.series.tooltip, e.plotOptions[this.type].tooltip, c.tooltip.userOptions, d.series && d.series.tooltip, d[this.type].tooltip, a.tooltip);\n        this.stickyTracking = M(a.stickyTracking, q[this.type] && q[this.type].stickyTracking, q.series && q.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : f.stickyTracking);\n        null === h.marker && delete f.marker;\n        this.zoneAxis = f.zoneAxis;\n        c = this.zones = (f.zones || []).slice();\n        !f.negativeColor && !f.negativeFillColor || f.zones || (d = {\n          value: f[this.zoneAxis + \"Threshold\"] || f.threshold || 0,\n          className: \"highcharts-negative\"\n        }, b || (d.color = f.negativeColor, d.fillColor = f.negativeFillColor), c.push(d));\n        c.length && l(c[c.length - 1].value) && c.push(b ? {} : {\n          color: this.color,\n          fillColor: this.fillColor\n        });\n        g(this, \"afterSetOptions\", {\n          options: f\n        });\n        return f;\n      },\n      getName: function () {\n        return M(this.options.name, \"Series \" + (this.index + 1));\n      },\n      getCyclic: function (a, c, d) {\n        var b = this.chart,\n            g = this.userOptions,\n            k = a + \"Index\",\n            e = a + \"Counter\",\n            f = d ? d.length : M(b.options.chart[a + \"Count\"], b[a + \"Count\"]);\n\n        if (!c) {\n          var p = M(g[k], g[\"_\" + k]);\n          l(p) || (b.series.length || (b[e] = 0), g[\"_\" + k] = p = b[e] % f, b[e] += 1);\n          d && (c = d[p]);\n        }\n\n        \"undefined\" !== typeof p && (this[k] = p);\n        this[a] = c;\n      },\n      getColor: function () {\n        this.chart.styledMode ? this.getCyclic(\"color\") : this.options.colorByPoint ? this.options.color = null : this.getCyclic(\"color\", this.options.color || e.plotOptions[this.type].color, this.chart.options.colors);\n      },\n      getPointsCollection: function () {\n        return (this.hasGroupedData ? this.points : this.data) || [];\n      },\n      getSymbol: function () {\n        this.getCyclic(\"symbol\", this.options.marker.symbol, this.chart.options.symbols);\n      },\n      findPointIndex: function (a, c) {\n        var b = a.id,\n            g = a.x,\n            k = this.points,\n            e,\n            f = this.options.dataSorting;\n        if (b) var l = this.chart.get(b);else if (this.linkedParent || this.enabledDataSorting) {\n          var h = f && f.matchByName ? \"name\" : \"index\";\n          l = d(k, function (b) {\n            return !b.touched && b[h] === a[h];\n          });\n          if (!l) return;\n        }\n\n        if (l) {\n          var q = l && l.index;\n          \"undefined\" !== typeof q && (e = !0);\n        }\n\n        \"undefined\" === typeof q && p(g) && (q = this.xData.indexOf(g, c));\n        -1 !== q && \"undefined\" !== typeof q && this.cropped && (q = q >= this.cropStart ? q - this.cropStart : q);\n        !e && k[q] && k[q].touched && (q = void 0);\n        return q;\n      },\n      drawLegendSymbol: z.drawLineMarker,\n      updateData: function (a, c) {\n        var b = this.options,\n            d = b.dataSorting,\n            g = this.points,\n            k = [],\n            e,\n            f,\n            h,\n            q = this.requireSorting,\n            n = a.length === g.length,\n            u = !0;\n        this.xIncrement = null;\n        a.forEach(function (a, c) {\n          var f = l(a) && this.pointClass.prototype.optionsToObject.call({\n            series: this\n          }, a) || {};\n          var t = f.x;\n\n          if (f.id || p(t)) {\n            if (t = this.findPointIndex(f, h), -1 === t || \"undefined\" === typeof t ? k.push(a) : g[t] && a !== b.data[t] ? (g[t].update(a, !1, null, !1), g[t].touched = !0, q && (h = t + 1)) : g[t] && (g[t].touched = !0), !n || c !== t || d && d.enabled || this.hasDerivedData) e = !0;\n          } else k.push(a);\n        }, this);\n        if (e) for (a = g.length; a--;) (f = g[a]) && !f.touched && f.remove && f.remove(!1, c);else !n || d && d.enabled ? u = !1 : (a.forEach(function (a, b) {\n          g[b].update && a !== g[b].y && g[b].update(a, !1, null, !1);\n        }), k.length = 0);\n        g.forEach(function (a) {\n          a && (a.touched = !1);\n        });\n        if (!u) return !1;\n        k.forEach(function (a) {\n          this.addPoint(a, !1, null, null, !1);\n        }, this);\n        null === this.xIncrement && this.xData && this.xData.length && (this.xIncrement = v(this.xData), this.autoIncrement());\n        return !0;\n      },\n      setData: function (b, c, d, g) {\n        var k = this,\n            e = k.points,\n            f = e && e.length || 0,\n            t,\n            l = k.options,\n            h = k.chart,\n            q = l.dataSorting,\n            n = null,\n            u = k.xAxis;\n        n = l.turboThreshold;\n        var r = this.xData,\n            m = this.yData,\n            A = (t = k.pointArrayMap) && t.length,\n            v = l.keys,\n            E = 0,\n            H = 1,\n            O;\n        b = b || [];\n        t = b.length;\n        c = M(c, !0);\n        q && q.enabled && (b = this.sortData(b));\n        !1 !== g && t && f && !k.cropped && !k.hasGroupedData && k.visible && !k.isSeriesBoosting && (O = this.updateData(b, d));\n\n        if (!O) {\n          k.xIncrement = null;\n          k.colorCounter = 0;\n          this.parallelArrays.forEach(function (a) {\n            k[a + \"Data\"].length = 0;\n          });\n          if (n && t > n) {\n            if (n = k.getFirstValidPoint(b), p(n)) for (d = 0; d < t; d++) r[d] = this.autoIncrement(), m[d] = b[d];else if (a(n)) {\n              if (A) for (d = 0; d < t; d++) g = b[d], r[d] = g[0], m[d] = g.slice(1, A + 1);else for (v && (E = v.indexOf(\"x\"), H = v.indexOf(\"y\"), E = 0 <= E ? E : 0, H = 0 <= H ? H : 1), d = 0; d < t; d++) g = b[d], r[d] = g[E], m[d] = g[H];\n            } else w(12, !1, h);\n          } else for (d = 0; d < t; d++) \"undefined\" !== typeof b[d] && (g = {\n            series: k\n          }, k.pointClass.prototype.applyOptions.apply(g, [b[d]]), k.updateParallelArrays(g, d));\n          m && B(m[0]) && w(14, !0, h);\n          k.data = [];\n          k.options.data = k.userOptions.data = b;\n\n          for (d = f; d--;) e[d] && e[d].destroy && e[d].destroy();\n\n          u && (u.minRange = u.userMinRange);\n          k.isDirty = h.isDirtyBox = !0;\n          k.isDirtyData = !!e;\n          d = !1;\n        }\n\n        \"point\" === l.legendType && (this.processData(), this.generatePoints());\n        c && h.redraw(d);\n      },\n      sortData: function (a) {\n        var b = this,\n            d = b.options.dataSorting.sortKey || \"y\",\n            g = function (a, b) {\n          return l(b) && a.pointClass.prototype.optionsToObject.call({\n            series: a\n          }, b) || {};\n        };\n\n        a.forEach(function (c, d) {\n          a[d] = g(b, c);\n          a[d].index = d;\n        }, this);\n        a.concat().sort(function (a, b) {\n          a = c(d, a);\n          b = c(d, b);\n          return b < a ? -1 : b > a ? 1 : 0;\n        }).forEach(function (a, b) {\n          a.x = b;\n        }, this);\n        b.linkedSeries && b.linkedSeries.forEach(function (b) {\n          var c = b.options,\n              d = c.data;\n          c.dataSorting && c.dataSorting.enabled || !d || (d.forEach(function (c, k) {\n            d[k] = g(b, c);\n            a[k] && (d[k].x = a[k].x, d[k].index = k);\n          }), b.setData(d, !1));\n        });\n        return a;\n      },\n      getProcessedData: function (a) {\n        var b = this.xData,\n            c = this.yData,\n            d = b.length;\n        var g = 0;\n        var e = this.xAxis,\n            f = this.options;\n        var p = f.cropThreshold;\n        var l = a || this.getExtremesFromAll || f.getExtremesFromAll,\n            h = this.isCartesian;\n        a = e && e.val2lin;\n        f = !(!e || !e.logarithmic);\n        var q = this.requireSorting;\n\n        if (e) {\n          e = e.getExtremes();\n          var n = e.min;\n          var u = e.max;\n        }\n\n        if (h && this.sorted && !l && (!p || d > p || this.forceCrop)) if (b[d - 1] < n || b[0] > u) b = [], c = [];else if (this.yData && (b[0] < n || b[d - 1] > u)) {\n          g = this.cropData(this.xData, this.yData, n, u);\n          b = g.xData;\n          c = g.yData;\n          g = g.start;\n          var r = !0;\n        }\n\n        for (p = b.length || 1; --p;) if (d = f ? a(b[p]) - a(b[p - 1]) : b[p] - b[p - 1], 0 < d && (\"undefined\" === typeof m || d < m)) var m = d;else 0 > d && q && (w(15, !1, this.chart), q = !1);\n\n        return {\n          xData: b,\n          yData: c,\n          cropped: r,\n          cropStart: g,\n          closestPointRange: m\n        };\n      },\n      processData: function (a) {\n        var b = this.xAxis;\n        if (this.isCartesian && !this.isDirty && !b.isDirty && !this.yAxis.isDirty && !a) return !1;\n        a = this.getProcessedData();\n        this.cropped = a.cropped;\n        this.cropStart = a.cropStart;\n        this.processedXData = a.xData;\n        this.processedYData = a.yData;\n        this.closestPointRange = this.basePointRange = a.closestPointRange;\n      },\n      cropData: function (a, c, d, g, e) {\n        var b = a.length,\n            k = 0,\n            f = b,\n            p;\n        e = M(e, this.cropShoulder);\n\n        for (p = 0; p < b; p++) if (a[p] >= d) {\n          k = Math.max(0, p - e);\n          break;\n        }\n\n        for (d = p; d < b; d++) if (a[d] > g) {\n          f = d + e;\n          break;\n        }\n\n        return {\n          xData: a.slice(k, f),\n          yData: c.slice(k, f),\n          start: k,\n          end: f\n        };\n      },\n      generatePoints: function () {\n        var a = this.options,\n            c = a.data,\n            d = this.data,\n            e,\n            f = this.processedXData,\n            p = this.processedYData,\n            l = this.pointClass,\n            h = f.length,\n            q = this.cropStart || 0,\n            n = this.hasGroupedData;\n        a = a.keys;\n        var u = [],\n            m;\n        d || n || (d = [], d.length = c.length, d = this.data = d);\n        a && n && (this.options.keys = !1);\n\n        for (m = 0; m < h; m++) {\n          var w = q + m;\n\n          if (n) {\n            var v = new l().init(this, [f[m]].concat(Q(p[m])));\n            v.dataGroup = this.groupMap[m];\n            v.dataGroup.options && (v.options = v.dataGroup.options, r(v, v.dataGroup.options), delete v.dataLabels);\n          } else (v = d[w]) || \"undefined\" === typeof c[w] || (d[w] = v = new l().init(this, c[w], f[m]));\n\n          v && (v.index = w, u[m] = v);\n        }\n\n        this.options.keys = a;\n        if (d && (h !== (e = d.length) || n)) for (m = 0; m < e; m++) m !== q || n || (m += h), d[m] && (d[m].destroyElements(), d[m].plotX = void 0);\n        this.data = d;\n        this.points = u;\n        g(this, \"afterGeneratePoints\");\n      },\n      getXExtremes: function (a) {\n        return {\n          min: x(a),\n          max: v(a)\n        };\n      },\n      getExtremes: function (b, c) {\n        var d = this.xAxis,\n            k = this.yAxis,\n            e = this.processedXData || this.xData,\n            f = [],\n            l = 0,\n            h = 0;\n        var q = 0;\n        var n = this.requireSorting ? this.cropShoulder : 0,\n            u = k ? k.positiveValuesOnly : !1,\n            r;\n        b = b || this.stackedYData || this.processedYData || [];\n        k = b.length;\n        d && (q = d.getExtremes(), h = q.min, q = q.max);\n\n        for (r = 0; r < k; r++) {\n          var m = e[r];\n          var w = b[r];\n          var A = (p(w) || a(w)) && (w.length || 0 < w || !u);\n          m = c || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !d || (e[r + n] || m) >= h && (e[r - n] || m) <= q;\n          if (A && m) if (A = w.length) for (; A--;) p(w[A]) && (f[l++] = w[A]);else f[l++] = w;\n        }\n\n        b = {\n          dataMin: x(f),\n          dataMax: v(f)\n        };\n        g(this, \"afterGetExtremes\", {\n          dataExtremes: b\n        });\n        return b;\n      },\n      applyExtremes: function () {\n        var a = this.getExtremes();\n        this.dataMin = a.dataMin;\n        this.dataMax = a.dataMax;\n        return a;\n      },\n      getFirstValidPoint: function (a) {\n        for (var b = null, c = a.length, d = 0; null === b && d < c;) b = a[d], d++;\n\n        return b;\n      },\n      translate: function () {\n        this.processedXData || this.processData();\n        this.generatePoints();\n        var b = this.options,\n            c = b.stacking,\n            d = this.xAxis,\n            e = d.categories,\n            f = this.enabledDataSorting,\n            h = this.yAxis,\n            q = this.points,\n            u = q.length,\n            r = !!this.modifyValue,\n            m,\n            w = this.pointPlacementToXValue(),\n            v = !!w,\n            A = b.threshold,\n            B = b.startFromThreshold ? A : 0,\n            E,\n            O = this.zoneAxis || \"y\",\n            G = Number.MAX_VALUE;\n\n        for (m = 0; m < u; m++) {\n          var x = q[m],\n              y = x.x,\n              z = x.y,\n              C = x.low,\n              J = c && h.stacking && h.stacking.stacks[(this.negStacks && z < (B ? 0 : A) ? \"-\" : \"\") + this.stackKey];\n          if (h.positiveValuesOnly && !h.validatePositiveValue(z) || d.positiveValuesOnly && !d.validatePositiveValue(y)) x.isNull = !0;\n          x.plotX = E = n(D(d.translate(y, 0, 0, 0, 1, w, \"flags\" === this.type), -1E5, 1E5));\n\n          if (c && this.visible && J && J[y]) {\n            var F = this.getStackIndicator(F, y, this.index);\n\n            if (!x.isNull) {\n              var Q = J[y];\n              var I = Q.points[F.key];\n            }\n          }\n\n          a(I) && (C = I[0], z = I[1], C === B && F.key === J[y].base && (C = M(p(A) && A, h.min)), h.positiveValuesOnly && 0 >= C && (C = null), x.total = x.stackTotal = Q.total, x.percentage = Q.total && x.y / Q.total * 100, x.stackY = z, this.irregularWidths || Q.setOffset(this.pointXOffset || 0, this.barW || 0));\n          x.yBottom = l(C) ? D(h.translate(C, 0, 1, 0, 1), -1E5, 1E5) : null;\n          r && (z = this.modifyValue(z, x));\n          x.plotY = \"number\" === typeof z && Infinity !== z ? D(h.translate(z, 0, 1, 0, 1), -1E5, 1E5) : void 0;\n          x.isInside = this.isPointInside(x);\n          x.clientX = v ? n(d.translate(y, 0, 0, 0, 1, w)) : E;\n          x.negative = x[O] < (b[O + \"Threshold\"] || A || 0);\n          x.category = e && \"undefined\" !== typeof e[x.x] ? e[x.x] : x.x;\n\n          if (!x.isNull && !1 !== x.visible) {\n            \"undefined\" !== typeof K && (G = Math.min(G, Math.abs(E - K)));\n            var K = E;\n          }\n\n          x.zone = this.zones.length && x.getZone();\n          !x.graphic && this.group && f && (x.isNew = !0);\n        }\n\n        this.closestPointRangePx = G;\n        g(this, \"afterTranslate\");\n      },\n      getValidPoints: function (a, c, d) {\n        var b = this.chart;\n        return (a || this.points || []).filter(function (a) {\n          return c && !b.isInsidePlot(a.plotX, a.plotY, b.inverted) ? !1 : !1 !== a.visible && (d || !a.isNull);\n        });\n      },\n      getClipBox: function (a, c) {\n        var b = this.options,\n            d = this.chart,\n            g = d.inverted,\n            k = this.xAxis,\n            e = k && this.yAxis,\n            f = d.options.chart.scrollablePlotArea || {};\n        a && !1 === b.clip && e ? a = g ? {\n          y: -d.chartWidth + e.len + e.pos,\n          height: d.chartWidth,\n          width: d.chartHeight,\n          x: -d.chartHeight + k.len + k.pos\n        } : {\n          y: -e.pos,\n          height: d.chartHeight,\n          width: d.chartWidth,\n          x: -k.pos\n        } : (a = this.clipBox || d.clipBox, c && (a.width = d.plotSizeX, a.x = (d.scrollablePixelsX || 0) * (f.scrollPositionX || 0)));\n        return c ? {\n          width: a.width,\n          x: a.x\n        } : a;\n      },\n      setClip: function (a) {\n        var b = this.chart,\n            c = this.options,\n            d = b.renderer,\n            g = b.inverted,\n            e = this.clipBox,\n            f = this.getClipBox(a),\n            p = this.sharedClipKey || [\"_sharedClip\", a && a.duration, a && a.easing, f.height, c.xAxis, c.yAxis].join(),\n            l = b[p],\n            h = b[p + \"m\"];\n        a && (f.width = 0, g && (f.x = b.plotHeight + (!1 !== c.clip ? 0 : b.plotTop)));\n        l ? b.hasLoaded || l.attr(f) : (a && (b[p + \"m\"] = h = d.clipRect(g ? b.plotSizeX + 99 : -99, g ? -b.plotLeft : -b.plotTop, 99, g ? b.chartWidth : b.chartHeight)), b[p] = l = d.clipRect(f), l.count = {\n          length: 0\n        });\n        a && !l.count[this.index] && (l.count[this.index] = !0, l.count.length += 1);\n        if (!1 !== c.clip || a) this.group.clip(a || e ? l : b.clipRect), this.markerGroup.clip(h), this.sharedClipKey = p;\n        a || (l.count[this.index] && (delete l.count[this.index], --l.count.length), 0 === l.count.length && p && b[p] && (e || (b[p] = b[p].destroy()), b[p + \"m\"] && (b[p + \"m\"] = b[p + \"m\"].destroy())));\n      },\n      animate: function (a) {\n        var b = this.chart,\n            c = y(this.options.animation);\n        if (!b.hasRendered) if (a) this.setClip(c);else {\n          var d = this.sharedClipKey;\n          a = b[d];\n          var g = this.getClipBox(c, !0);\n          a && a.animate(g, c);\n          b[d + \"m\"] && b[d + \"m\"].animate({\n            width: g.width + 99,\n            x: g.x - (b.inverted ? 0 : 99)\n          }, c);\n        }\n      },\n      afterAnimate: function () {\n        this.setClip();\n        g(this, \"afterAnimate\");\n        this.finishedAnimating = !0;\n      },\n      drawPoints: function () {\n        var a = this.points,\n            c = this.chart,\n            d,\n            g,\n            e = this.options.marker,\n            f = this[this.specialGroup] || this.markerGroup,\n            p = this.xAxis,\n            l = M(e.enabled, !p || p.isRadial ? !0 : null, this.closestPointRangePx >= e.enabledThreshold * e.radius);\n        if (!1 !== e.enabled || this._hasPointMarkers) for (d = 0; d < a.length; d++) {\n          var h = a[d];\n          var q = (g = h.graphic) ? \"animate\" : \"attr\";\n          var n = h.marker || {};\n          var u = !!h.marker;\n\n          if ((l && \"undefined\" === typeof n.enabled || n.enabled) && !h.isNull && !1 !== h.visible) {\n            var r = M(n.symbol, this.symbol);\n            var m = this.markerAttribs(h, h.selected && \"select\");\n            this.enabledDataSorting && (h.startXPos = p.reversed ? -m.width : p.width);\n            var w = !1 !== h.isInside;\n            g ? g[w ? \"show\" : \"hide\"](w).animate(m) : w && (0 < m.width || h.hasImage) && (h.graphic = g = c.renderer.symbol(r, m.x, m.y, m.width, m.height, u ? n : e).add(f), this.enabledDataSorting && c.hasRendered && (g.attr({\n              x: h.startXPos\n            }), q = \"animate\"));\n            g && \"animate\" === q && g[w ? \"show\" : \"hide\"](w).animate(m);\n            if (g && !c.styledMode) g[q](this.pointAttribs(h, h.selected && \"select\"));\n            g && g.addClass(h.getClassName(), !0);\n          } else g && (h.graphic = g.destroy());\n        }\n      },\n      markerAttribs: function (a, c) {\n        var b = this.options,\n            d = b.marker,\n            g = a.marker || {},\n            e = g.symbol || d.symbol,\n            k = M(g.radius, d.radius);\n        c && (d = d.states[c], c = g.states && g.states[c], k = M(c && c.radius, d && d.radius, k + (d && d.radiusPlus || 0)));\n        a.hasImage = e && 0 === e.indexOf(\"url\");\n        a.hasImage && (k = 0);\n        a = {\n          x: b.crisp ? Math.floor(a.plotX) - k : a.plotX - k,\n          y: a.plotY - k\n        };\n        k && (a.width = a.height = 2 * k);\n        return a;\n      },\n      pointAttribs: function (a, c) {\n        var b = this.options.marker,\n            d = a && a.options,\n            g = d && d.marker || {},\n            e = this.color,\n            k = d && d.color,\n            f = a && a.color;\n        d = M(g.lineWidth, b.lineWidth);\n        var p = a && a.zone && a.zone.color;\n        a = 1;\n        e = k || p || f || e;\n        k = g.fillColor || b.fillColor || e;\n        e = g.lineColor || b.lineColor || e;\n        c = c || \"normal\";\n        b = b.states[c];\n        c = g.states && g.states[c] || {};\n        d = M(c.lineWidth, b.lineWidth, d + M(c.lineWidthPlus, b.lineWidthPlus, 0));\n        k = c.fillColor || b.fillColor || k;\n        e = c.lineColor || b.lineColor || e;\n        a = M(c.opacity, b.opacity, a);\n        return {\n          stroke: e,\n          \"stroke-width\": d,\n          fill: k,\n          opacity: a\n        };\n      },\n      destroy: function (a) {\n        var b = this,\n            c = b.chart,\n            d = /AppleWebKit\\/533/.test(u.navigator.userAgent),\n            e,\n            f,\n            p = b.data || [],\n            h,\n            l;\n        g(b, \"destroy\");\n        this.removeEvents(a);\n        (b.axisTypes || []).forEach(function (a) {\n          (l = b[a]) && l.series && (J(l.series, b), l.isDirty = l.forceRedraw = !0);\n        });\n        b.legendItem && b.chart.legend.destroyItem(b);\n\n        for (f = p.length; f--;) (h = p[f]) && h.destroy && h.destroy();\n\n        b.points = null;\n        C.clearTimeout(b.animationTimeout);\n        G(b, function (a, b) {\n          a instanceof K && !a.survive && (e = d && \"group\" === b ? \"hide\" : \"destroy\", a[e]());\n        });\n        c.hoverSeries === b && (c.hoverSeries = null);\n        J(c.series, b);\n        c.orderSeries();\n        G(b, function (c, d) {\n          a && \"hcEvents\" === d || delete b[d];\n        });\n      },\n      getGraphPath: function (a, c, d) {\n        var b = this,\n            g = b.options,\n            e = g.step,\n            k,\n            f = [],\n            p = [],\n            h;\n        a = a || b.points;\n        (k = a.reversed) && a.reverse();\n        (e = {\n          right: 1,\n          center: 2\n        }[e] || e && 3) && k && (e = 4 - e);\n        a = this.getValidPoints(a, !1, !(g.connectNulls && !c && !d));\n        a.forEach(function (k, q) {\n          var t = k.plotX,\n              n = k.plotY,\n              u = a[q - 1];\n          (k.leftCliff || u && u.rightCliff) && !d && (h = !0);\n          k.isNull && !l(c) && 0 < q ? h = !g.connectNulls : k.isNull && !c ? h = !0 : (0 === q || h ? q = [[\"M\", k.plotX, k.plotY]] : b.getPointSpline ? q = [b.getPointSpline(a, k, q)] : e ? (q = 1 === e ? [[\"L\", u.plotX, n]] : 2 === e ? [[\"L\", (u.plotX + t) / 2, u.plotY], [\"L\", (u.plotX + t) / 2, n]] : [[\"L\", t, u.plotY]], q.push([\"L\", t, n])) : q = [[\"L\", t, n]], p.push(k.x), e && (p.push(k.x), 2 === e && p.push(k.x)), f.push.apply(f, q), h = !1);\n        });\n        f.xMap = p;\n        return b.graphPath = f;\n      },\n      drawGraph: function () {\n        var a = this,\n            c = this.options,\n            d = (this.gappedPath || this.getGraphPath).call(this),\n            g = this.chart.styledMode,\n            e = [[\"graph\", \"highcharts-graph\"]];\n        g || e[0].push(c.lineColor || this.color || \"#cccccc\", c.dashStyle);\n        e = a.getZonesGraphs(e);\n        e.forEach(function (b, e) {\n          var k = b[0],\n              f = a[k],\n              p = f ? \"animate\" : \"attr\";\n          f ? (f.endX = a.preventGraphAnimation ? null : d.xMap, f.animate({\n            d: d\n          })) : d.length && (a[k] = f = a.chart.renderer.path(d).addClass(b[1]).attr({\n            zIndex: 1\n          }).add(a.group));\n          f && !g && (k = {\n            stroke: b[2],\n            \"stroke-width\": c.lineWidth,\n            fill: a.fillGraph && a.color || \"none\"\n          }, b[3] ? k.dashstyle = b[3] : \"square\" !== c.linecap && (k[\"stroke-linecap\"] = k[\"stroke-linejoin\"] = \"round\"), f[p](k).shadow(2 > e && c.shadow));\n          f && (f.startX = d.xMap, f.isArea = d.isArea);\n        });\n      },\n      getZonesGraphs: function (a) {\n        this.zones.forEach(function (b, c) {\n          c = [\"zone-graph-\" + c, \"highcharts-graph highcharts-zone-graph-\" + c + \" \" + (b.className || \"\")];\n          this.chart.styledMode || c.push(b.color || this.color, b.dashStyle || this.options.dashStyle);\n          a.push(c);\n        }, this);\n        return a;\n      },\n      applyZones: function () {\n        var a = this,\n            c = this.chart,\n            d = c.renderer,\n            g = this.zones,\n            e,\n            f,\n            p = this.clips || [],\n            h,\n            l = this.graph,\n            q = this.area,\n            n = Math.max(c.chartWidth, c.chartHeight),\n            u = this[(this.zoneAxis || \"y\") + \"Axis\"],\n            r = c.inverted,\n            m,\n            w,\n            v,\n            A = !1,\n            B,\n            E;\n\n        if (g.length && (l || q) && u && \"undefined\" !== typeof u.min) {\n          var O = u.reversed;\n          var G = u.horiz;\n          l && !this.showLine && l.hide();\n          q && q.hide();\n          var x = u.getExtremes();\n          g.forEach(function (b, g) {\n            e = O ? G ? c.plotWidth : 0 : G ? 0 : u.toPixels(x.min) || 0;\n            e = D(M(f, e), 0, n);\n            f = D(Math.round(u.toPixels(M(b.value, x.max), !0) || 0), 0, n);\n            A && (e = f = u.toPixels(x.max));\n            m = Math.abs(e - f);\n            w = Math.min(e, f);\n            v = Math.max(e, f);\n            u.isXAxis ? (h = {\n              x: r ? v : w,\n              y: 0,\n              width: m,\n              height: n\n            }, G || (h.x = c.plotHeight - h.x)) : (h = {\n              x: 0,\n              y: r ? v : w,\n              width: n,\n              height: m\n            }, G && (h.y = c.plotWidth - h.y));\n            r && d.isVML && (h = u.isXAxis ? {\n              x: 0,\n              y: O ? w : v,\n              height: h.width,\n              width: c.chartWidth\n            } : {\n              x: h.y - c.plotLeft - c.spacingBox.x,\n              y: 0,\n              width: h.height,\n              height: c.chartHeight\n            });\n            p[g] ? p[g].animate(h) : p[g] = d.clipRect(h);\n            B = a[\"zone-area-\" + g];\n            E = a[\"zone-graph-\" + g];\n            l && E && E.clip(p[g]);\n            q && B && B.clip(p[g]);\n            A = b.value > x.max;\n            a.resetZones && 0 === f && (f = void 0);\n          });\n          this.clips = p;\n        } else a.visible && (l && l.show(!0), q && q.show(!0));\n      },\n      invertGroups: function (a) {\n        function b() {\n          [\"group\", \"markerGroup\"].forEach(function (b) {\n            c[b] && (d.renderer.isVML && c[b].attr({\n              width: c.yAxis.len,\n              height: c.xAxis.len\n            }), c[b].width = c.yAxis.len, c[b].height = c.xAxis.len, c[b].invert(c.isRadialSeries ? !1 : a));\n          });\n        }\n\n        var c = this,\n            d = c.chart;\n        c.xAxis && (c.eventsToUnbind.push(I(d, \"resize\", b)), b(), c.invertGroups = b);\n      },\n      plotGroup: function (a, c, d, g, e) {\n        var b = this[a],\n            k = !b;\n        d = {\n          visibility: d,\n          zIndex: g || .1\n        };\n        \"undefined\" === typeof this.opacity || this.chart.styledMode || \"inactive\" === this.state || (d.opacity = this.opacity);\n        k && (this[a] = b = this.chart.renderer.g().add(e));\n        b.addClass(\"highcharts-\" + c + \" highcharts-series-\" + this.index + \" highcharts-\" + this.type + \"-series \" + (l(this.colorIndex) ? \"highcharts-color-\" + this.colorIndex + \" \" : \"\") + (this.options.className || \"\") + (b.hasClass(\"highcharts-tracker\") ? \" highcharts-tracker\" : \"\"), !0);\n        b.attr(d)[k ? \"attr\" : \"animate\"](this.getPlotBox());\n        return b;\n      },\n      getPlotBox: function () {\n        var a = this.chart,\n            c = this.xAxis,\n            d = this.yAxis;\n        a.inverted && (c = d, d = this.xAxis);\n        return {\n          translateX: c ? c.left : a.plotLeft,\n          translateY: d ? d.top : a.plotTop,\n          scaleX: 1,\n          scaleY: 1\n        };\n      },\n      removeEvents: function (a) {\n        a ? this.eventsToUnbind.length && (this.eventsToUnbind.forEach(function (a) {\n          a();\n        }), this.eventsToUnbind.length = 0) : T(this);\n      },\n      render: function () {\n        var a = this,\n            c = a.chart,\n            d = a.options,\n            e = y(d.animation),\n            f = !a.finishedAnimating && c.renderer.isSVG && e.duration,\n            p = a.visible ? \"inherit\" : \"hidden\",\n            h = d.zIndex,\n            l = a.hasRendered,\n            q = c.seriesGroup,\n            n = c.inverted;\n        g(this, \"render\");\n        var u = a.plotGroup(\"group\", \"series\", p, h, q);\n        a.markerGroup = a.plotGroup(\"markerGroup\", \"markers\", p, h, q);\n        f && a.animate && a.animate(!0);\n        u.inverted = a.isCartesian || a.invertable ? n : !1;\n        a.drawGraph && (a.drawGraph(), a.applyZones());\n        a.visible && a.drawPoints();\n        a.drawDataLabels && a.drawDataLabels();\n        a.redrawPoints && a.redrawPoints();\n        a.drawTracker && !1 !== a.options.enableMouseTracking && a.drawTracker();\n        a.invertGroups(n);\n        !1 === d.clip || a.sharedClipKey || l || u.clip(c.clipRect);\n        f && a.animate && a.animate();\n        l || (f && e.defer && (f += e.defer), a.animationTimeout = O(function () {\n          a.afterAnimate();\n        }, f || 0));\n        a.isDirty = !1;\n        a.hasRendered = !0;\n        g(a, \"afterRender\");\n      },\n      redraw: function () {\n        var a = this.chart,\n            c = this.isDirty || this.isDirtyData,\n            d = this.group,\n            g = this.xAxis,\n            e = this.yAxis;\n        d && (a.inverted && d.attr({\n          width: a.plotWidth,\n          height: a.plotHeight\n        }), d.animate({\n          translateX: M(g && g.left, a.plotLeft),\n          translateY: M(e && e.top, a.plotTop)\n        }));\n        this.translate();\n        this.render();\n        c && delete this.kdTree;\n      },\n      kdAxisArray: [\"clientX\", \"plotY\"],\n      searchPoint: function (a, c) {\n        var b = this.xAxis,\n            d = this.yAxis,\n            g = this.chart.inverted;\n        return this.searchKDTree({\n          clientX: g ? b.len - a.chartY + b.pos : a.chartX - b.pos,\n          plotY: g ? d.len - a.chartX + d.pos : a.chartY - d.pos\n        }, c, a);\n      },\n      buildKDTree: function (a) {\n        function b(a, d, g) {\n          var e;\n\n          if (e = a && a.length) {\n            var f = c.kdAxisArray[d % g];\n            a.sort(function (a, b) {\n              return a[f] - b[f];\n            });\n            e = Math.floor(e / 2);\n            return {\n              point: a[e],\n              left: b(a.slice(0, e), d + 1, g),\n              right: b(a.slice(e + 1), d + 1, g)\n            };\n          }\n        }\n\n        this.buildingKdTree = !0;\n        var c = this,\n            d = -1 < c.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n        delete c.kdTree;\n        O(function () {\n          c.kdTree = b(c.getValidPoints(null, !c.directTouch), d, d);\n          c.buildingKdTree = !1;\n        }, c.options.kdNow || a && \"touchstart\" === a.type ? 0 : 1);\n      },\n      searchKDTree: function (a, c, d) {\n        function b(a, c, d, p) {\n          var h = c.point,\n              q = g.kdAxisArray[d % p],\n              n = h;\n          var u = l(a[e]) && l(h[e]) ? Math.pow(a[e] - h[e], 2) : null;\n          var t = l(a[f]) && l(h[f]) ? Math.pow(a[f] - h[f], 2) : null;\n          t = (u || 0) + (t || 0);\n          h.dist = l(t) ? Math.sqrt(t) : Number.MAX_VALUE;\n          h.distX = l(u) ? Math.sqrt(u) : Number.MAX_VALUE;\n          q = a[q] - h[q];\n          t = 0 > q ? \"left\" : \"right\";\n          u = 0 > q ? \"right\" : \"left\";\n          c[t] && (t = b(a, c[t], d + 1, p), n = t[k] < n[k] ? t : h);\n          c[u] && Math.sqrt(q * q) < n[k] && (a = b(a, c[u], d + 1, p), n = a[k] < n[k] ? a : n);\n          return n;\n        }\n\n        var g = this,\n            e = this.kdAxisArray[0],\n            f = this.kdAxisArray[1],\n            k = c ? \"distX\" : \"dist\";\n        c = -1 < g.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n        this.kdTree || this.buildingKdTree || this.buildKDTree(d);\n        if (this.kdTree) return b(a, this.kdTree, c, c);\n      },\n      pointPlacementToXValue: function () {\n        var a = this.options,\n            c = a.pointRange,\n            d = this.xAxis;\n        a = a.pointPlacement;\n        \"between\" === a && (a = d.reversed ? -.5 : .5);\n        return p(a) ? a * M(c, d.pointRange) : 0;\n      },\n      isPointInside: function (a) {\n        return \"undefined\" !== typeof a.plotY && \"undefined\" !== typeof a.plotX && 0 <= a.plotY && a.plotY <= this.yAxis.len && 0 <= a.plotX && a.plotX <= this.xAxis.len;\n      }\n    });\n    \"\";\n    return f;\n  });\n  N(m, \"Series/LineSeries.js\", [m[\"Core/Series/CartesianSeries.js\"], m[\"Core/Globals.js\"]], function (f, h) {\n    h.Series = f;\n    return h.Series;\n  });\n  N(m, \"Extensions/Stacking.js\", [m[\"Core/Axis/Axis.js\"], m[\"Core/Chart/Chart.js\"], m[\"Core/Globals.js\"], m[\"Core/Axis/StackingAxis.js\"], m[\"Core/Utilities.js\"]], function (f, h, m, z, F) {\n    var L = F.correctFloat,\n        K = F.defined,\n        C = F.destroyObjectProperties,\n        y = F.format,\n        e = F.isNumber,\n        I = F.pick;\n    \"\";\n\n    var v = m.Series,\n        x = function () {\n      function f(e, f, h, m, r) {\n        var d = e.chart.inverted;\n        this.axis = e;\n        this.isNegative = h;\n        this.options = f = f || {};\n        this.x = m;\n        this.total = null;\n        this.points = {};\n        this.hasValidPoints = !1;\n        this.stack = r;\n        this.rightCliff = this.leftCliff = 0;\n        this.alignOptions = {\n          align: f.align || (d ? h ? \"left\" : \"right\" : \"center\"),\n          verticalAlign: f.verticalAlign || (d ? \"middle\" : h ? \"bottom\" : \"top\"),\n          y: f.y,\n          x: f.x\n        };\n        this.textAlign = f.textAlign || (d ? h ? \"right\" : \"left\" : \"center\");\n      }\n\n      f.prototype.destroy = function () {\n        C(this, this.axis);\n      };\n\n      f.prototype.render = function (e) {\n        var f = this.axis.chart,\n            h = this.options,\n            n = h.format;\n        n = n ? y(n, this, f) : h.formatter.call(this);\n        this.label ? this.label.attr({\n          text: n,\n          visibility: \"hidden\"\n        }) : (this.label = f.renderer.label(n, null, null, h.shape, null, null, h.useHTML, !1, \"stack-labels\"), n = {\n          r: h.borderRadius || 0,\n          text: n,\n          rotation: h.rotation,\n          padding: I(h.padding, 5),\n          visibility: \"hidden\"\n        }, f.styledMode || (n.fill = h.backgroundColor, n.stroke = h.borderColor, n[\"stroke-width\"] = h.borderWidth, this.label.css(h.style)), this.label.attr(n), this.label.added || this.label.add(e));\n        this.label.labelrank = f.plotHeight;\n      };\n\n      f.prototype.setOffset = function (f, h, m, w, r) {\n        var d = this.axis,\n            g = d.chart;\n        w = d.translate(d.stacking.usePercentage ? 100 : w ? w : this.total, 0, 0, 0, 1);\n        m = d.translate(m ? m : 0);\n        m = K(w) && Math.abs(w - m);\n        f = I(r, g.xAxis[0].translate(this.x)) + f;\n        d = K(w) && this.getStackBox(g, this, f, w, h, m, d);\n        h = this.label;\n        m = this.isNegative;\n        f = \"justify\" === I(this.options.overflow, \"justify\");\n        var c = this.textAlign;\n        h && d && (r = h.getBBox(), w = h.padding, c = \"left\" === c ? g.inverted ? -w : w : \"right\" === c ? r.width : g.inverted && \"center\" === c ? r.width / 2 : g.inverted ? m ? r.width + w : -w : r.width / 2, m = g.inverted ? r.height / 2 : m ? -w : r.height, this.alignOptions.x = I(this.options.x, 0), this.alignOptions.y = I(this.options.y, 0), d.x -= c, d.y -= m, h.align(this.alignOptions, null, d), g.isInsidePlot(h.alignAttr.x + c - this.alignOptions.x, h.alignAttr.y + m - this.alignOptions.y) ? h.show() : (h.alignAttr.y = -9999, f = !1), f && v.prototype.justifyDataLabel.call(this.axis, h, this.alignOptions, h.alignAttr, r, d), h.attr({\n          x: h.alignAttr.x,\n          y: h.alignAttr.y\n        }), I(!f && this.options.crop, !0) && ((g = e(h.x) && e(h.y) && g.isInsidePlot(h.x - w + h.width, h.y) && g.isInsidePlot(h.x + w, h.y)) || h.hide()));\n      };\n\n      f.prototype.getStackBox = function (e, f, h, m, r, d, g) {\n        var c = f.axis.reversed,\n            a = e.inverted,\n            q = g.height + g.pos - (a ? e.plotLeft : e.plotTop);\n        f = f.isNegative && !c || !f.isNegative && c;\n        return {\n          x: a ? f ? m - g.right : m - d + g.pos - e.plotLeft : h + e.xAxis[0].transB - e.plotLeft,\n          y: a ? g.height - h - r : f ? q - m - d : q - m,\n          width: a ? d : r,\n          height: a ? r : d\n        };\n      };\n\n      return f;\n    }();\n\n    h.prototype.getStacks = function () {\n      var e = this,\n          f = e.inverted;\n      e.yAxis.forEach(function (e) {\n        e.stacking && e.stacking.stacks && e.hasVisibleSeries && (e.stacking.oldStacks = e.stacking.stacks);\n      });\n      e.series.forEach(function (h) {\n        var l = h.xAxis && h.xAxis.options || {};\n        !h.options.stacking || !0 !== h.visible && !1 !== e.options.chart.ignoreHiddenSeries || (h.stackKey = [h.type, I(h.options.stack, \"\"), f ? l.top : l.left, f ? l.height : l.width].join());\n      });\n    };\n\n    z.compose(f);\n\n    v.prototype.setGroupedPoints = function () {\n      this.options.centerInCategory && (this.is(\"column\") || this.is(\"columnrange\")) && !this.options.stacking && 1 < this.chart.series.length && v.prototype.setStackedPoints.call(this, \"group\");\n    };\n\n    v.prototype.setStackedPoints = function (e) {\n      var f = e || this.options.stacking;\n\n      if (f && (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) {\n        var h = this.processedXData,\n            m = this.processedYData,\n            w = [],\n            r = m.length,\n            d = this.options,\n            g = d.threshold,\n            c = I(d.startFromThreshold && g, 0);\n        d = d.stack;\n        e = e ? this.type + \",\" + f : this.stackKey;\n        var a = \"-\" + e,\n            q = this.negStacks,\n            p = this.yAxis,\n            v = p.stacking.stacks,\n            A = p.stacking.oldStacks,\n            G,\n            D;\n        p.stacking.stacksTouched += 1;\n\n        for (D = 0; D < r; D++) {\n          var y = h[D];\n          var z = m[D];\n          var O = this.getStackIndicator(O, y, this.index);\n          var E = O.key;\n          var u = (G = q && z < (c ? 0 : g)) ? a : e;\n          v[u] || (v[u] = {});\n          v[u][y] || (A[u] && A[u][y] ? (v[u][y] = A[u][y], v[u][y].total = null) : v[u][y] = new x(p, p.options.stackLabels, G, y, d));\n          u = v[u][y];\n          null !== z ? (u.points[E] = u.points[this.index] = [I(u.cumulative, c)], K(u.cumulative) || (u.base = E), u.touched = p.stacking.stacksTouched, 0 < O.index && !1 === this.singleStacks && (u.points[E][0] = u.points[this.index + \",\" + y + \",0\"][0])) : u.points[E] = u.points[this.index] = null;\n          \"percent\" === f ? (G = G ? e : a, q && v[G] && v[G][y] ? (G = v[G][y], u.total = G.total = Math.max(G.total, u.total) + Math.abs(z) || 0) : u.total = L(u.total + (Math.abs(z) || 0))) : \"group\" === f ? null !== z && (u.total = (u.total || 0) + 1) : u.total = L(u.total + (z || 0));\n          u.cumulative = \"group\" === f ? (u.total || 1) - 1 : I(u.cumulative, c) + (z || 0);\n          null !== z && (u.points[E].push(u.cumulative), w[D] = u.cumulative, u.hasValidPoints = !0);\n        }\n\n        \"percent\" === f && (p.stacking.usePercentage = !0);\n        \"group\" !== f && (this.stackedYData = w);\n        p.stacking.oldStacks = {};\n      }\n    };\n\n    v.prototype.modifyStacks = function () {\n      var e = this,\n          f = e.stackKey,\n          h = e.yAxis.stacking.stacks,\n          m = e.processedXData,\n          w,\n          r = e.options.stacking;\n      e[r + \"Stacker\"] && [f, \"-\" + f].forEach(function (d) {\n        for (var g = m.length, c, a; g--;) if (c = m[g], w = e.getStackIndicator(w, c, e.index, d), a = (c = h[d] && h[d][c]) && c.points[w.key]) e[r + \"Stacker\"](a, c, g);\n      });\n    };\n\n    v.prototype.percentStacker = function (e, f, h) {\n      f = f.total ? 100 / f.total : 0;\n      e[0] = L(e[0] * f);\n      e[1] = L(e[1] * f);\n      this.stackedYData[h] = e[1];\n    };\n\n    v.prototype.getStackIndicator = function (e, f, h, m) {\n      !K(e) || e.x !== f || m && e.key !== m ? e = {\n        x: f,\n        index: 0,\n        key: m\n      } : e.index++;\n      e.key = [h, f, e.index].join();\n      return e;\n    };\n\n    m.StackItem = x;\n    return m.StackItem;\n  });\n  N(m, \"Core/Dynamics.js\", [m[\"Core/Animation/AnimationUtilities.js\"], m[\"Core/Axis/Axis.js\"], m[\"Core/Series/Series.js\"], m[\"Core/Chart/Chart.js\"], m[\"Core/Globals.js\"], m[\"Series/LineSeries.js\"], m[\"Core/Options.js\"], m[\"Core/Series/Point.js\"], m[\"Core/Time.js\"], m[\"Core/Utilities.js\"]], function (f, h, m, z, F, L, K, C, y, e) {\n    var I = f.animate,\n        v = f.setAnimation,\n        x = m.seriesTypes,\n        D = K.time,\n        n = e.addEvent,\n        l = e.createElement,\n        J = e.css,\n        w = e.defined,\n        r = e.erase,\n        d = e.error,\n        g = e.extend,\n        c = e.fireEvent,\n        a = e.isArray,\n        q = e.isNumber,\n        p = e.isObject,\n        B = e.isString,\n        A = e.merge,\n        G = e.objectEach,\n        M = e.pick,\n        T = e.relativeLength,\n        Q = e.splat;\n\n    F.cleanRecursively = function (a, c) {\n      var d = {};\n      G(a, function (b, g) {\n        if (p(a[g], !0) && !a.nodeType && c[g]) b = F.cleanRecursively(a[g], c[g]), Object.keys(b).length && (d[g] = b);else if (p(a[g]) || a[g] !== c[g]) d[g] = a[g];\n      });\n      return d;\n    };\n\n    g(z.prototype, {\n      addSeries: function (a, d, g) {\n        var b,\n            e = this;\n        a && (d = M(d, !0), c(e, \"addSeries\", {\n          options: a\n        }, function () {\n          b = e.initSeries(a);\n          e.isDirtyLegend = !0;\n          e.linkSeries();\n          b.enabledDataSorting && b.setData(a.data, !1);\n          c(e, \"afterAddSeries\", {\n            series: b\n          });\n          d && e.redraw(g);\n        }));\n        return b;\n      },\n      addAxis: function (a, c, d, b) {\n        return this.createAxis(c ? \"xAxis\" : \"yAxis\", {\n          axis: a,\n          redraw: d,\n          animation: b\n        });\n      },\n      addColorAxis: function (a, c, d) {\n        return this.createAxis(\"colorAxis\", {\n          axis: a,\n          redraw: c,\n          animation: d\n        });\n      },\n      createAxis: function (a, c) {\n        var d = this.options,\n            b = \"colorAxis\" === a,\n            g = c.redraw,\n            e = c.animation;\n        c = A(c.axis, {\n          index: this[a].length,\n          isX: \"xAxis\" === a\n        });\n        var f = b ? new F.ColorAxis(this, c) : new h(this, c);\n        d[a] = Q(d[a] || {});\n        d[a].push(c);\n        b && (this.isDirtyLegend = !0, this.axes.forEach(function (a) {\n          a.series = [];\n        }), this.series.forEach(function (a) {\n          a.bindAxes();\n          a.isDirtyData = !0;\n        }));\n        M(g, !0) && this.redraw(e);\n        return f;\n      },\n      showLoading: function (a) {\n        var c = this,\n            d = c.options,\n            b = c.loadingDiv,\n            e = d.loading,\n            f = function () {\n          b && J(b, {\n            left: c.plotLeft + \"px\",\n            top: c.plotTop + \"px\",\n            width: c.plotWidth + \"px\",\n            height: c.plotHeight + \"px\"\n          });\n        };\n\n        b || (c.loadingDiv = b = l(\"div\", {\n          className: \"highcharts-loading highcharts-loading-hidden\"\n        }, null, c.container), c.loadingSpan = l(\"span\", {\n          className: \"highcharts-loading-inner\"\n        }, null, b), n(c, \"redraw\", f));\n        b.className = \"highcharts-loading\";\n        c.loadingSpan.innerHTML = M(a, d.lang.loading, \"\");\n        c.styledMode || (J(b, g(e.style, {\n          zIndex: 10\n        })), J(c.loadingSpan, e.labelStyle), c.loadingShown || (J(b, {\n          opacity: 0,\n          display: \"\"\n        }), I(b, {\n          opacity: e.style.opacity || .5\n        }, {\n          duration: e.showDuration || 0\n        })));\n        c.loadingShown = !0;\n        f();\n      },\n      hideLoading: function () {\n        var a = this.options,\n            c = this.loadingDiv;\n        c && (c.className = \"highcharts-loading highcharts-loading-hidden\", this.styledMode || I(c, {\n          opacity: 0\n        }, {\n          duration: a.loading.hideDuration || 100,\n          complete: function () {\n            J(c, {\n              display: \"none\"\n            });\n          }\n        }));\n        this.loadingShown = !1;\n      },\n      propsRequireDirtyBox: \"backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow\".split(\" \"),\n      propsRequireReflow: \"margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft\".split(\" \"),\n      propsRequireUpdateSeries: \"chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip\".split(\" \"),\n      collectionsWithUpdate: [\"xAxis\", \"yAxis\", \"zAxis\", \"series\"],\n      update: function (a, d, g, b) {\n        var e = this,\n            f = {\n          credits: \"addCredits\",\n          title: \"setTitle\",\n          subtitle: \"setSubtitle\",\n          caption: \"setCaption\"\n        },\n            p,\n            h,\n            l,\n            n = a.isResponsiveOptions,\n            u = [];\n        c(e, \"update\", {\n          options: a\n        });\n        n || e.setResponsive(!1, !0);\n        a = F.cleanRecursively(a, e.options);\n        A(!0, e.userOptions, a);\n\n        if (p = a.chart) {\n          A(!0, e.options.chart, p);\n          \"className\" in p && e.setClassName(p.className);\n          \"reflow\" in p && e.setReflow(p.reflow);\n\n          if (\"inverted\" in p || \"polar\" in p || \"type\" in p) {\n            e.propFromSeries();\n            var m = !0;\n          }\n\n          \"alignTicks\" in p && (m = !0);\n          G(p, function (a, b) {\n            -1 !== e.propsRequireUpdateSeries.indexOf(\"chart.\" + b) && (h = !0);\n            -1 !== e.propsRequireDirtyBox.indexOf(b) && (e.isDirtyBox = !0);\n            -1 !== e.propsRequireReflow.indexOf(b) && (n ? e.isDirtyBox = !0 : l = !0);\n          });\n          !e.styledMode && \"style\" in p && e.renderer.setStyle(p.style);\n        }\n\n        !e.styledMode && a.colors && (this.options.colors = a.colors);\n        a.time && (this.time === D && (this.time = new y(a.time)), A(!0, e.options.time, a.time));\n        G(a, function (b, c) {\n          if (e[c] && \"function\" === typeof e[c].update) e[c].update(b, !1);else if (\"function\" === typeof e[f[c]]) e[f[c]](b);else \"color\" !== c && -1 === e.collectionsWithUpdate.indexOf(c) && A(!0, e.options[c], a[c]);\n          \"chart\" !== c && -1 !== e.propsRequireUpdateSeries.indexOf(c) && (h = !0);\n        });\n        this.collectionsWithUpdate.forEach(function (b) {\n          if (a[b]) {\n            if (\"series\" === b) {\n              var c = [];\n              e[b].forEach(function (a, b) {\n                a.options.isInternal || c.push(M(a.options.index, b));\n              });\n            }\n\n            Q(a[b]).forEach(function (a, d) {\n              var f = w(a.id),\n                  k;\n              f && (k = e.get(a.id));\n              k || (k = e[b][c ? c[d] : d]) && f && w(k.options.id) && (k = void 0);\n              k && k.coll === b && (k.update(a, !1), g && (k.touched = !0));\n              !k && g && e.collectionsWithInit[b] && (e.collectionsWithInit[b][0].apply(e, [a].concat(e.collectionsWithInit[b][1] || []).concat([!1])).touched = !0);\n            });\n            g && e[b].forEach(function (a) {\n              a.touched || a.options.isInternal ? delete a.touched : u.push(a);\n            });\n          }\n        });\n        u.forEach(function (a) {\n          a.remove && a.remove(!1);\n        });\n        m && e.axes.forEach(function (a) {\n          a.update({}, !1);\n        });\n        h && e.getSeriesOrderByLinks().forEach(function (a) {\n          a.chart && a.update({}, !1);\n        }, this);\n        m = p && p.width;\n        p = p && p.height;\n        B(p) && (p = T(p, m || e.chartWidth));\n        l || q(m) && m !== e.chartWidth || q(p) && p !== e.chartHeight ? e.setSize(m, p, b) : M(d, !0) && e.redraw(b);\n        c(e, \"afterUpdate\", {\n          options: a,\n          redraw: d,\n          animation: b\n        });\n      },\n      setSubtitle: function (a, c) {\n        this.applyDescription(\"subtitle\", a);\n        this.layOutTitles(c);\n      },\n      setCaption: function (a, c) {\n        this.applyDescription(\"caption\", a);\n        this.layOutTitles(c);\n      }\n    });\n    z.prototype.collectionsWithInit = {\n      xAxis: [z.prototype.addAxis, [!0]],\n      yAxis: [z.prototype.addAxis, [!1]],\n      series: [z.prototype.addSeries]\n    };\n    g(C.prototype, {\n      update: function (a, c, d, b) {\n        function g() {\n          e.applyOptions(a);\n          var b = h && e.hasDummyGraphic;\n          b = null === e.y ? !b : b;\n          h && b && (e.graphic = h.destroy(), delete e.hasDummyGraphic);\n          p(a, !0) && (h && h.element && a && a.marker && \"undefined\" !== typeof a.marker.symbol && (e.graphic = h.destroy()), a && a.dataLabels && e.dataLabel && (e.dataLabel = e.dataLabel.destroy()), e.connector && (e.connector = e.connector.destroy()));\n          q = e.index;\n          f.updateParallelArrays(e, q);\n          n.data[q] = p(n.data[q], !0) || p(a, !0) ? e.options : M(a, n.data[q]);\n          f.isDirty = f.isDirtyData = !0;\n          !f.fixedBox && f.hasCartesianSeries && (l.isDirtyBox = !0);\n          \"point\" === n.legendType && (l.isDirtyLegend = !0);\n          c && l.redraw(d);\n        }\n\n        var e = this,\n            f = e.series,\n            h = e.graphic,\n            q,\n            l = f.chart,\n            n = f.options;\n        c = M(c, !0);\n        !1 === b ? g() : e.firePointEvent(\"update\", {\n          options: a\n        }, g);\n      },\n      remove: function (a, c) {\n        this.series.removePoint(this.series.data.indexOf(this), a, c);\n      }\n    });\n    g(L.prototype, {\n      addPoint: function (a, d, g, b, e) {\n        var f = this.options,\n            k = this.data,\n            p = this.chart,\n            h = this.xAxis;\n        h = h && h.hasNames && h.names;\n        var q = f.data,\n            l = this.xData,\n            n;\n        d = M(d, !0);\n        var u = {\n          series: this\n        };\n        this.pointClass.prototype.applyOptions.apply(u, [a]);\n        var m = u.x;\n        var r = l.length;\n        if (this.requireSorting && m < l[r - 1]) for (n = !0; r && l[r - 1] > m;) r--;\n        this.updateParallelArrays(u, \"splice\", r, 0, 0);\n        this.updateParallelArrays(u, r);\n        h && u.name && (h[m] = u.name);\n        q.splice(r, 0, a);\n        n && (this.data.splice(r, 0, null), this.processData());\n        \"point\" === f.legendType && this.generatePoints();\n        g && (k[0] && k[0].remove ? k[0].remove(!1) : (k.shift(), this.updateParallelArrays(u, \"shift\"), q.shift()));\n        !1 !== e && c(this, \"addPoint\", {\n          point: u\n        });\n        this.isDirtyData = this.isDirty = !0;\n        d && p.redraw(b);\n      },\n      removePoint: function (a, c, d) {\n        var b = this,\n            g = b.data,\n            e = g[a],\n            f = b.points,\n            p = b.chart,\n            h = function () {\n          f && f.length === g.length && f.splice(a, 1);\n          g.splice(a, 1);\n          b.options.data.splice(a, 1);\n          b.updateParallelArrays(e || {\n            series: b\n          }, \"splice\", a, 1);\n          e && e.destroy();\n          b.isDirty = !0;\n          b.isDirtyData = !0;\n          c && p.redraw();\n        };\n\n        v(d, p);\n        c = M(c, !0);\n        e ? e.firePointEvent(\"remove\", null, h) : h();\n      },\n      remove: function (a, d, g, b) {\n        function e() {\n          f.destroy(b);\n          f.remove = null;\n          p.isDirtyLegend = p.isDirtyBox = !0;\n          p.linkSeries();\n          M(a, !0) && p.redraw(d);\n        }\n\n        var f = this,\n            p = f.chart;\n        !1 !== g ? c(f, \"remove\", null, e) : e();\n      },\n      update: function (a, e) {\n        a = F.cleanRecursively(a, this.userOptions);\n        c(this, \"update\", {\n          options: a\n        });\n        var f = this,\n            b = f.chart,\n            k = f.userOptions,\n            p = f.initialType || f.type,\n            h = b.options.plotOptions,\n            q = a.type || k.type || b.options.chart.type,\n            l = !(this.hasDerivedData || q && q !== this.type || \"undefined\" !== typeof a.pointStart || \"undefined\" !== typeof a.pointInterval || f.hasOptionChanged(\"dataGrouping\") || f.hasOptionChanged(\"pointStart\") || f.hasOptionChanged(\"pointInterval\") || f.hasOptionChanged(\"pointIntervalUnit\") || f.hasOptionChanged(\"keys\")),\n            n = x[p].prototype,\n            m,\n            r = [\"eventOptions\", \"navigatorSeries\", \"baseSeries\"],\n            w = f.finishedAnimating && {\n          animation: !1\n        },\n            v = {};\n        l && (r.push(\"data\", \"isDirtyData\", \"points\", \"processedXData\", \"processedYData\", \"xIncrement\", \"cropped\", \"_hasPointMarkers\", \"_hasPointLabels\", \"mapMap\", \"mapData\", \"minY\", \"maxY\", \"minX\", \"maxX\"), !1 !== a.visible && r.push(\"area\", \"graph\"), f.parallelArrays.forEach(function (a) {\n          r.push(a + \"Data\");\n        }), a.data && (a.dataSorting && g(f.options.dataSorting, a.dataSorting), this.setData(a.data, !1)));\n        a = A(k, w, {\n          index: \"undefined\" === typeof k.index ? f.index : k.index,\n          pointStart: M(h && h.series && h.series.pointStart, k.pointStart, f.xData[0])\n        }, !l && {\n          data: f.options.data\n        }, a);\n        l && a.data && (a.data = f.options.data);\n        r = [\"group\", \"markerGroup\", \"dataLabelsGroup\", \"transformGroup\"].concat(r);\n        r.forEach(function (a) {\n          r[a] = f[a];\n          delete f[a];\n        });\n        f.remove(!1, null, !1, !0);\n\n        for (m in n) f[m] = void 0;\n\n        x[q || p] ? g(f, x[q || p].prototype) : d(17, !0, b, {\n          missingModuleFor: q || p\n        });\n        r.forEach(function (a) {\n          f[a] = r[a];\n        });\n        f.init(b, a);\n\n        if (l && this.points) {\n          var B = f.options;\n          !1 === B.visible ? (v.graphic = 1, v.dataLabel = 1) : f._hasPointLabels || (a = B.marker, k = B.dataLabels, a && (!1 === a.enabled || \"symbol\" in a) && (v.graphic = 1), k && !1 === k.enabled && (v.dataLabel = 1));\n          this.points.forEach(function (a) {\n            a && a.series && (a.resolveColor(), Object.keys(v).length && a.destroyElements(v), !1 === B.showInLegend && a.legendItem && b.legend.destroyItem(a));\n          }, this);\n        }\n\n        f.initialType = p;\n        b.linkSeries();\n        c(this, \"afterUpdate\");\n        M(e, !0) && b.redraw(l ? void 0 : !1);\n      },\n      setName: function (a) {\n        this.name = this.options.name = this.userOptions.name = a;\n        this.chart.isDirtyLegend = !0;\n      },\n      hasOptionChanged: function (a) {\n        var c = this.options[a],\n            d = this.chart.options.plotOptions,\n            b = this.userOptions[a];\n        return b ? c !== b : c !== M(d && d[this.type] && d[this.type][a], d && d.series && d.series[a], c);\n      }\n    });\n    g(h.prototype, {\n      update: function (a, c) {\n        var d = this.chart,\n            b = a && a.events || {};\n        a = A(this.userOptions, a);\n        d.options[this.coll].indexOf && (d.options[this.coll][d.options[this.coll].indexOf(this.userOptions)] = a);\n        G(d.options[this.coll].events, function (a, c) {\n          \"undefined\" === typeof b[c] && (b[c] = void 0);\n        });\n        this.destroy(!0);\n        this.init(d, g(a, {\n          events: b\n        }));\n        d.isDirtyBox = !0;\n        M(c, !0) && d.redraw();\n      },\n      remove: function (c) {\n        for (var d = this.chart, g = this.coll, b = this.series, e = b.length; e--;) b[e] && b[e].remove(!1);\n\n        r(d.axes, this);\n        r(d[g], this);\n        a(d.options[g]) ? d.options[g].splice(this.options.index, 1) : delete d.options[g];\n        d[g].forEach(function (a, b) {\n          a.options.index = a.userOptions.index = b;\n        });\n        this.destroy();\n        d.isDirtyBox = !0;\n        M(c, !0) && d.redraw();\n      },\n      setTitle: function (a, c) {\n        this.update({\n          title: a\n        }, c);\n      },\n      setCategories: function (a, c) {\n        this.update({\n          categories: a\n        }, c);\n      }\n    });\n  });\n  N(m, \"Series/AreaSeries.js\", [m[\"Core/Series/Series.js\"], m[\"Core/Color/Color.js\"], m[\"Core/Globals.js\"], m[\"Mixins/LegendSymbol.js\"], m[\"Core/Utilities.js\"]], function (f, h, m, z, F) {\n    var L = h.parse,\n        K = F.objectEach,\n        C = F.pick,\n        y = m.Series;\n    f.seriesType(\"area\", \"line\", {\n      threshold: 0\n    }, {\n      singleStacks: !1,\n      getStackPoints: function (e) {\n        var f = [],\n            h = [],\n            m = this.xAxis,\n            D = this.yAxis,\n            n = D.stacking.stacks[this.stackKey],\n            l = {},\n            y = this.index,\n            w = D.series,\n            r = w.length,\n            d = C(D.options.reversedStacks, !0) ? 1 : -1,\n            g;\n        e = e || this.points;\n\n        if (this.options.stacking) {\n          for (g = 0; g < e.length; g++) e[g].leftNull = e[g].rightNull = void 0, l[e[g].x] = e[g];\n\n          K(n, function (a, c) {\n            null !== a.total && h.push(c);\n          });\n          h.sort(function (a, c) {\n            return a - c;\n          });\n          var c = w.map(function (a) {\n            return a.visible;\n          });\n          h.forEach(function (a, e) {\n            var p = 0,\n                q,\n                w;\n            if (l[a] && !l[a].isNull) f.push(l[a]), [-1, 1].forEach(function (f) {\n              var p = 1 === f ? \"rightNull\" : \"leftNull\",\n                  m = 0,\n                  v = n[h[e + f]];\n              if (v) for (g = y; 0 <= g && g < r;) q = v.points[g], q || (g === y ? l[a][p] = !0 : c[g] && (w = n[a].points[g]) && (m -= w[1] - w[0])), g += d;\n              l[a][1 === f ? \"rightCliff\" : \"leftCliff\"] = m;\n            });else {\n              for (g = y; 0 <= g && g < r;) {\n                if (q = n[a].points[g]) {\n                  p = q[1];\n                  break;\n                }\n\n                g += d;\n              }\n\n              p = D.translate(p, 0, 1, 0, 1);\n              f.push({\n                isNull: !0,\n                plotX: m.translate(a, 0, 0, 0, 1),\n                x: a,\n                plotY: p,\n                yBottom: p\n              });\n            }\n          });\n        }\n\n        return f;\n      },\n      getGraphPath: function (e) {\n        var f = y.prototype.getGraphPath,\n            h = this.options,\n            m = h.stacking,\n            D = this.yAxis,\n            n,\n            l = [],\n            z = [],\n            w = this.index,\n            r = D.stacking.stacks[this.stackKey],\n            d = h.threshold,\n            g = Math.round(D.getThreshold(h.threshold));\n        h = C(h.connectNulls, \"percent\" === m);\n\n        var c = function (a, c, f) {\n          var p = e[a];\n          a = m && r[p.x].points[w];\n          var h = p[f + \"Null\"] || 0;\n          f = p[f + \"Cliff\"] || 0;\n          p = !0;\n\n          if (f || h) {\n            var n = (h ? a[0] : a[1]) + f;\n            var v = a[0] + f;\n            p = !!h;\n          } else !m && e[c] && e[c].isNull && (n = v = d);\n\n          \"undefined\" !== typeof n && (z.push({\n            plotX: q,\n            plotY: null === n ? g : D.getThreshold(n),\n            isNull: p,\n            isCliff: !0\n          }), l.push({\n            plotX: q,\n            plotY: null === v ? g : D.getThreshold(v),\n            doCurve: !1\n          }));\n        };\n\n        e = e || this.points;\n        m && (e = this.getStackPoints(e));\n\n        for (n = 0; n < e.length; n++) {\n          m || (e[n].leftCliff = e[n].rightCliff = e[n].leftNull = e[n].rightNull = void 0);\n          var a = e[n].isNull;\n          var q = C(e[n].rectPlotX, e[n].plotX);\n          var p = m ? e[n].yBottom : g;\n          if (!a || h) h || c(n, n - 1, \"left\"), a && !m && h || (z.push(e[n]), l.push({\n            x: n,\n            plotX: q,\n            plotY: p\n          })), h || c(n, n + 1, \"right\");\n        }\n\n        n = f.call(this, z, !0, !0);\n        l.reversed = !0;\n        a = f.call(this, l, !0, !0);\n        (p = a[0]) && \"M\" === p[0] && (a[0] = [\"L\", p[1], p[2]]);\n        a = n.concat(a);\n        f = f.call(this, z, !1, h);\n        a.xMap = n.xMap;\n        this.areaPath = a;\n        return f;\n      },\n      drawGraph: function () {\n        this.areaPath = [];\n        y.prototype.drawGraph.apply(this);\n        var e = this,\n            f = this.areaPath,\n            h = this.options,\n            m = [[\"area\", \"highcharts-area\", this.color, h.fillColor]];\n        this.zones.forEach(function (f, n) {\n          m.push([\"zone-area-\" + n, \"highcharts-area highcharts-zone-area-\" + n + \" \" + f.className, f.color || e.color, f.fillColor || h.fillColor]);\n        });\n        m.forEach(function (m) {\n          var n = m[0],\n              l = e[n],\n              v = l ? \"animate\" : \"attr\",\n              w = {};\n          l ? (l.endX = e.preventGraphAnimation ? null : f.xMap, l.animate({\n            d: f\n          })) : (w.zIndex = 0, l = e[n] = e.chart.renderer.path(f).addClass(m[1]).add(e.group), l.isArea = !0);\n          e.chart.styledMode || (w.fill = C(m[3], L(m[2]).setOpacity(C(h.fillOpacity, .75)).get()));\n          l[v](w);\n          l.startX = f.xMap;\n          l.shiftUnit = h.step ? 2 : 1;\n        });\n      },\n      drawLegendSymbol: z.drawRectangle\n    });\n    \"\";\n  });\n  N(m, \"Series/SplineSeries.js\", [m[\"Core/Series/Series.js\"], m[\"Core/Utilities.js\"]], function (f, h) {\n    var m = h.pick;\n    f.seriesType(\"spline\", \"line\", {}, {\n      getPointSpline: function (f, h, L) {\n        var z = h.plotX || 0,\n            C = h.plotY || 0,\n            y = f[L - 1];\n        L = f[L + 1];\n\n        if (y && !y.isNull && !1 !== y.doCurve && !h.isCliff && L && !L.isNull && !1 !== L.doCurve && !h.isCliff) {\n          f = y.plotY || 0;\n          var e = L.plotX || 0;\n          L = L.plotY || 0;\n          var F = 0;\n          var v = (1.5 * z + (y.plotX || 0)) / 2.5;\n          var x = (1.5 * C + f) / 2.5;\n          e = (1.5 * z + e) / 2.5;\n          var D = (1.5 * C + L) / 2.5;\n          e !== v && (F = (D - x) * (e - z) / (e - v) + C - D);\n          x += F;\n          D += F;\n          x > f && x > C ? (x = Math.max(f, C), D = 2 * C - x) : x < f && x < C && (x = Math.min(f, C), D = 2 * C - x);\n          D > L && D > C ? (D = Math.max(L, C), x = 2 * C - D) : D < L && D < C && (D = Math.min(L, C), x = 2 * C - D);\n          h.rightContX = e;\n          h.rightContY = D;\n        }\n\n        h = [\"C\", m(y.rightContX, y.plotX, 0), m(y.rightContY, y.plotY, 0), m(v, z, 0), m(x, C, 0), z, C];\n        y.rightContX = y.rightContY = void 0;\n        return h;\n      }\n    });\n    \"\";\n  });\n  N(m, \"Series/AreaSplineSeries.js\", [m[\"Core/Series/Series.js\"], m[\"Mixins/LegendSymbol.js\"], m[\"Core/Options.js\"]], function (f, h, m) {\n    var z = f.seriesTypes.area.prototype;\n    f.seriesType(\"areaspline\", \"spline\", m.defaultOptions.plotOptions.area, {\n      getStackPoints: z.getStackPoints,\n      getGraphPath: z.getGraphPath,\n      drawGraph: z.drawGraph,\n      drawLegendSymbol: h.drawRectangle\n    });\n    \"\";\n  });\n  N(m, \"Series/ColumnSeries.js\", [m[\"Core/Animation/AnimationUtilities.js\"], m[\"Core/Series/Series.js\"], m[\"Core/Color/Color.js\"], m[\"Core/Globals.js\"], m[\"Mixins/LegendSymbol.js\"], m[\"Series/LineSeries.js\"], m[\"Core/Utilities.js\"]], function (f, h, m, z, F, L, K) {\n    var C = f.animObject,\n        y = m.parse;\n    f = z.noop;\n    var e = K.clamp,\n        I = K.defined,\n        v = K.extend,\n        x = K.isArray,\n        D = K.isNumber,\n        n = K.merge,\n        l = K.pick,\n        J = K.objectEach;\n    \"\";\n    h = h.seriesType(\"column\", \"line\", {\n      borderRadius: 0,\n      centerInCategory: !1,\n      groupPadding: .2,\n      marker: null,\n      pointPadding: .1,\n      minPointLength: 0,\n      cropThreshold: 50,\n      pointRange: null,\n      states: {\n        hover: {\n          halo: !1,\n          brightness: .1\n        },\n        select: {\n          color: \"#cccccc\",\n          borderColor: \"#000000\"\n        }\n      },\n      dataLabels: {\n        align: void 0,\n        verticalAlign: void 0,\n        y: void 0\n      },\n      startFromThreshold: !0,\n      stickyTracking: !1,\n      tooltip: {\n        distance: 6\n      },\n      threshold: 0,\n      borderColor: \"#ffffff\"\n    }, {\n      cropShoulder: 0,\n      directTouch: !0,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      negStacks: !0,\n      init: function () {\n        L.prototype.init.apply(this, arguments);\n        var e = this,\n            f = e.chart;\n        f.hasRendered && f.series.forEach(function (d) {\n          d.type === e.type && (d.isDirty = !0);\n        });\n      },\n      getColumnMetrics: function () {\n        var e = this,\n            f = e.options,\n            d = e.xAxis,\n            g = e.yAxis,\n            c = d.options.reversedStacks;\n        c = d.reversed && !c || !d.reversed && c;\n        var a,\n            h = {},\n            p = 0;\n        !1 === f.grouping ? p = 1 : e.chart.series.forEach(function (c) {\n          var d = c.yAxis,\n              f = c.options;\n\n          if (c.type === e.type && (c.visible || !e.chart.options.chart.ignoreHiddenSeries) && g.len === d.len && g.pos === d.pos) {\n            if (f.stacking && \"group\" !== f.stacking) {\n              a = c.stackKey;\n              \"undefined\" === typeof h[a] && (h[a] = p++);\n              var q = h[a];\n            } else !1 !== f.grouping && (q = p++);\n\n            c.columnIndex = q;\n          }\n        });\n        var n = Math.min(Math.abs(d.transA) * (d.ordinal && d.ordinal.slope || f.pointRange || d.closestPointRange || d.tickInterval || 1), d.len),\n            m = n * f.groupPadding,\n            v = (n - 2 * m) / (p || 1);\n        f = Math.min(f.maxPointWidth || d.len, l(f.pointWidth, v * (1 - 2 * f.pointPadding)));\n        e.columnMetrics = {\n          width: f,\n          offset: (v - f) / 2 + (m + ((e.columnIndex || 0) + (c ? 1 : 0)) * v - n / 2) * (c ? -1 : 1),\n          paddedWidth: v,\n          columnCount: p\n        };\n        return e.columnMetrics;\n      },\n      crispCol: function (e, f, d, g) {\n        var c = this.chart,\n            a = this.borderWidth,\n            h = -(a % 2 ? .5 : 0);\n        a = a % 2 ? .5 : 1;\n        c.inverted && c.renderer.isVML && (a += 1);\n        this.options.crisp && (d = Math.round(e + d) + h, e = Math.round(e) + h, d -= e);\n        g = Math.round(f + g) + a;\n        h = .5 >= Math.abs(f) && .5 < g;\n        f = Math.round(f) + a;\n        g -= f;\n        h && g && (--f, g += 1);\n        return {\n          x: e,\n          y: f,\n          width: d,\n          height: g\n        };\n      },\n      adjustForMissingColumns: function (e, f, d, g) {\n        var c = this,\n            a = this.options.stacking;\n\n        if (!d.isNull && 1 < g.columnCount) {\n          var h = 0,\n              p = 0;\n          J(this.yAxis.stacking && this.yAxis.stacking.stacks, function (g) {\n            if (\"number\" === typeof d.x && (g = g[d.x.toString()])) {\n              var e = g.points[c.index],\n                  f = g.total;\n              a ? (e && (h = p), g.hasValidPoints && p++) : x(e) && (h = e[1], p = f || 0);\n            }\n          });\n          e = (d.plotX || 0) + ((p - 1) * g.paddedWidth + f) / 2 - f - h * g.paddedWidth;\n        }\n\n        return e;\n      },\n      translate: function () {\n        var f = this,\n            h = f.chart,\n            d = f.options,\n            g = f.dense = 2 > f.closestPointRange * f.xAxis.transA;\n        g = f.borderWidth = l(d.borderWidth, g ? 0 : 1);\n        var c = f.xAxis,\n            a = f.yAxis,\n            q = d.threshold,\n            p = f.translatedThreshold = a.getThreshold(q),\n            n = l(d.minPointLength, 5),\n            m = f.getColumnMetrics(),\n            v = m.width,\n            x = f.barW = Math.max(v, 1 + 2 * g),\n            y = f.pointXOffset = m.offset,\n            z = f.dataMin,\n            C = f.dataMax;\n        h.inverted && (p -= .5);\n        d.pointPadding && (x = Math.ceil(x));\n        L.prototype.translate.apply(f);\n        f.points.forEach(function (g) {\n          var u = l(g.yBottom, p),\n              b = 999 + Math.abs(u),\n              k = v,\n              t = g.plotX || 0;\n          b = e(g.plotY, -b, a.len + b);\n          var r = t + y,\n              w = x,\n              A = Math.min(b, u),\n              B = Math.max(b, u) - A;\n\n          if (n && Math.abs(B) < n) {\n            B = n;\n            var E = !a.reversed && !g.negative || a.reversed && g.negative;\n            D(q) && D(C) && g.y === q && C <= q && (a.min || 0) < q && z !== C && (E = !E);\n            A = Math.abs(A - p) > n ? u - n : p - (E ? n : 0);\n          }\n\n          I(g.options.pointWidth) && (k = w = Math.ceil(g.options.pointWidth), r -= Math.round((k - v) / 2));\n          d.centerInCategory && (r = f.adjustForMissingColumns(r, k, g, m));\n          g.barX = r;\n          g.pointWidth = k;\n          g.tooltipPos = h.inverted ? [a.len + a.pos - h.plotLeft - b, c.len + c.pos - h.plotTop - (t || 0) - y - w / 2, B] : [r + w / 2, b + a.pos - h.plotTop, B];\n          g.shapeType = f.pointClass.prototype.shapeType || \"rect\";\n          g.shapeArgs = f.crispCol.apply(f, g.isNull ? [r, p, w, 0] : [r, A, w, B]);\n        });\n      },\n      getSymbol: f,\n      drawLegendSymbol: F.drawRectangle,\n      drawGraph: function () {\n        this.group[this.dense ? \"addClass\" : \"removeClass\"](\"highcharts-dense-data\");\n      },\n      pointAttribs: function (e, f) {\n        var d = this.options,\n            g = this.pointAttrToOptions || {};\n        var c = g.stroke || \"borderColor\";\n        var a = g[\"stroke-width\"] || \"borderWidth\",\n            h = e && e.color || this.color,\n            p = e && e[c] || d[c] || this.color || h,\n            m = e && e[a] || d[a] || this[a] || 0;\n        g = e && e.options.dashStyle || d.dashStyle;\n        var r = l(e && e.opacity, d.opacity, 1);\n\n        if (e && this.zones.length) {\n          var v = e.getZone();\n          h = e.options.color || v && (v.color || e.nonZonedColor) || this.color;\n          v && (p = v.borderColor || p, g = v.dashStyle || g, m = v.borderWidth || m);\n        }\n\n        f && e && (e = n(d.states[f], e.options.states && e.options.states[f] || {}), f = e.brightness, h = e.color || \"undefined\" !== typeof f && y(h).brighten(e.brightness).get() || h, p = e[c] || p, m = e[a] || m, g = e.dashStyle || g, r = l(e.opacity, r));\n        c = {\n          fill: h,\n          stroke: p,\n          \"stroke-width\": m,\n          opacity: r\n        };\n        g && (c.dashstyle = g);\n        return c;\n      },\n      drawPoints: function () {\n        var e = this,\n            f = this.chart,\n            d = e.options,\n            g = f.renderer,\n            c = d.animationLimit || 250,\n            a;\n        e.points.forEach(function (h) {\n          var p = h.graphic,\n              l = !!p,\n              q = p && f.pointCount < c ? \"animate\" : \"attr\";\n\n          if (D(h.plotY) && null !== h.y) {\n            a = h.shapeArgs;\n            p && h.hasNewShapeType() && (p = p.destroy());\n            e.enabledDataSorting && (h.startXPos = e.xAxis.reversed ? -(a ? a.width : 0) : e.xAxis.width);\n            p || (h.graphic = p = g[h.shapeType](a).add(h.group || e.group)) && e.enabledDataSorting && f.hasRendered && f.pointCount < c && (p.attr({\n              x: h.startXPos\n            }), l = !0, q = \"animate\");\n            if (p && l) p[q](n(a));\n            if (d.borderRadius) p[q]({\n              r: d.borderRadius\n            });\n            f.styledMode || p[q](e.pointAttribs(h, h.selected && \"select\")).shadow(!1 !== h.allowShadow && d.shadow, null, d.stacking && !d.borderRadius);\n            p.addClass(h.getClassName(), !0);\n          } else p && (h.graphic = p.destroy());\n        });\n      },\n      animate: function (f) {\n        var h = this,\n            d = this.yAxis,\n            g = h.options,\n            c = this.chart.inverted,\n            a = {},\n            l = c ? \"translateX\" : \"translateY\";\n        if (f) a.scaleY = .001, f = e(d.toPixels(g.threshold), d.pos, d.pos + d.len), c ? a.translateX = f - d.len : a.translateY = f, h.clipBox && h.setClip(), h.group.attr(a);else {\n          var p = h.group.attr(l);\n          h.group.animate({\n            scaleY: 1\n          }, v(C(h.options.animation), {\n            step: function (c, g) {\n              h.group && (a[l] = p + g.pos * (d.pos - p), h.group.attr(a));\n            }\n          }));\n        }\n      },\n      remove: function () {\n        var e = this,\n            f = e.chart;\n        f.hasRendered && f.series.forEach(function (d) {\n          d.type === e.type && (d.isDirty = !0);\n        });\n        L.prototype.remove.apply(e, arguments);\n      }\n    });\n    \"\";\n    return h;\n  });\n  N(m, \"Series/BarSeries.js\", [m[\"Core/Series/Series.js\"]], function (f) {\n    f.seriesType(\"bar\", \"column\", null, {\n      inverted: !0\n    });\n    \"\";\n  });\n  N(m, \"Series/ScatterSeries.js\", [m[\"Core/Series/Series.js\"], m[\"Core/Globals.js\"], m[\"Core/Utilities.js\"]], function (f, h, m) {\n    m = m.addEvent;\n    var z = h.Series;\n    f.seriesType(\"scatter\", \"line\", {\n      lineWidth: 0,\n      findNearestPointBy: \"xy\",\n      jitter: {\n        x: 0,\n        y: 0\n      },\n      marker: {\n        enabled: !0\n      },\n      tooltip: {\n        headerFormat: '<span style=\"color:{point.color}\">\\u25cf</span> <span style=\"font-size: 10px\"> {series.name}</span><br/>',\n        pointFormat: \"x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>\"\n      }\n    }, {\n      sorted: !1,\n      requireSorting: !1,\n      noSharedTooltip: !0,\n      trackerGroups: [\"group\", \"markerGroup\", \"dataLabelsGroup\"],\n      takeOrdinalPosition: !1,\n      drawGraph: function () {\n        (this.options.lineWidth || 0 === this.options.lineWidth && this.graph && this.graph.strokeWidth()) && z.prototype.drawGraph.call(this);\n      },\n      applyJitter: function () {\n        var f = this,\n            h = this.options.jitter,\n            m = this.points.length;\n        h && this.points.forEach(function (z, y) {\n          [\"x\", \"y\"].forEach(function (e, C) {\n            var v = \"plot\" + e.toUpperCase();\n\n            if (h[e] && !z.isNull) {\n              var x = f[e + \"Axis\"];\n              var D = h[e] * x.transA;\n\n              if (x && !x.isLog) {\n                var n = Math.max(0, z[v] - D);\n                x = Math.min(x.len, z[v] + D);\n                C = 1E4 * Math.sin(y + C * m);\n                z[v] = n + (x - n) * (C - Math.floor(C));\n                \"x\" === e && (z.clientX = z.plotX);\n              }\n            }\n          });\n        });\n      }\n    });\n    m(z, \"afterTranslate\", function () {\n      this.applyJitter && this.applyJitter();\n    });\n    \"\";\n  });\n  N(m, \"Mixins/CenteredSeries.js\", [m[\"Core/Globals.js\"], m[\"Core/Utilities.js\"]], function (f, h) {\n    var m = h.isNumber,\n        z = h.pick,\n        F = h.relativeLength,\n        L = f.deg2rad;\n    return f.CenteredSeriesMixin = {\n      getCenter: function () {\n        var h = this.options,\n            m = this.chart,\n            y = 2 * (h.slicedOffset || 0),\n            e = m.plotWidth - 2 * y,\n            I = m.plotHeight - 2 * y,\n            v = h.center,\n            x = Math.min(e, I),\n            D = h.size,\n            n = h.innerSize || 0;\n        \"string\" === typeof D && (D = parseFloat(D));\n        \"string\" === typeof n && (n = parseFloat(n));\n        h = [z(v[0], \"50%\"), z(v[1], \"50%\"), z(D && 0 > D ? void 0 : h.size, \"100%\"), z(n && 0 > n ? void 0 : h.innerSize || 0, \"0%\")];\n        !m.angular || this instanceof f.Series || (h[3] = 0);\n\n        for (v = 0; 4 > v; ++v) D = h[v], m = 2 > v || 2 === v && /%$/.test(D), h[v] = F(D, [e, I, x, h[2]][v]) + (m ? y : 0);\n\n        h[3] > h[2] && (h[3] = h[2]);\n        return h;\n      },\n      getStartAndEndRadians: function (f, h) {\n        f = m(f) ? f : 0;\n        h = m(h) && h > f && 360 > h - f ? h : f + 360;\n        return {\n          start: L * (f + -90),\n          end: L * (h + -90)\n        };\n      }\n    };\n  });\n  N(m, \"Series/PieSeries.js\", [m[\"Core/Animation/AnimationUtilities.js\"], m[\"Core/Series/Series.js\"], m[\"Mixins/CenteredSeries.js\"], m[\"Core/Globals.js\"], m[\"Mixins/LegendSymbol.js\"], m[\"Series/LineSeries.js\"], m[\"Core/Series/Point.js\"], m[\"Core/Renderer/SVG/SVGRenderer.js\"], m[\"Core/Utilities.js\"]], function (f, h, m, z, F, L, K, C, y) {\n    var e = f.setAnimation,\n        I = m.getStartAndEndRadians;\n    f = z.noop;\n    var v = y.addEvent,\n        x = y.clamp,\n        D = y.defined,\n        n = y.fireEvent,\n        l = y.isNumber,\n        J = y.merge,\n        w = y.pick,\n        r = y.relativeLength;\n    h.seriesType(\"pie\", \"line\", {\n      center: [null, null],\n      clip: !1,\n      colorByPoint: !0,\n      dataLabels: {\n        allowOverlap: !0,\n        connectorPadding: 5,\n        connectorShape: \"fixedOffset\",\n        crookDistance: \"70%\",\n        distance: 30,\n        enabled: !0,\n        formatter: function () {\n          return this.point.isNull ? void 0 : this.point.name;\n        },\n        softConnector: !0,\n        x: 0\n      },\n      fillColor: void 0,\n      ignoreHiddenPoint: !0,\n      inactiveOtherPoints: !0,\n      legendType: \"point\",\n      marker: null,\n      size: null,\n      showInLegend: !1,\n      slicedOffset: 10,\n      stickyTracking: !1,\n      tooltip: {\n        followPointer: !0\n      },\n      borderColor: \"#ffffff\",\n      borderWidth: 1,\n      lineWidth: void 0,\n      states: {\n        hover: {\n          brightness: .1\n        }\n      }\n    }, {\n      isCartesian: !1,\n      requireSorting: !1,\n      directTouch: !0,\n      noSharedTooltip: !0,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      axisTypes: [],\n      pointAttribs: h.seriesTypes.column.prototype.pointAttribs,\n      animate: function (d) {\n        var g = this,\n            c = g.points,\n            a = g.startAngleRad;\n        d || c.forEach(function (c) {\n          var d = c.graphic,\n              e = c.shapeArgs;\n          d && e && (d.attr({\n            r: w(c.startR, g.center && g.center[3] / 2),\n            start: a,\n            end: a\n          }), d.animate({\n            r: e.r,\n            start: e.start,\n            end: e.end\n          }, g.options.animation));\n        });\n      },\n      hasData: function () {\n        return !!this.processedXData.length;\n      },\n      updateTotals: function () {\n        var d,\n            g = 0,\n            c = this.points,\n            a = c.length,\n            e = this.options.ignoreHiddenPoint;\n\n        for (d = 0; d < a; d++) {\n          var f = c[d];\n          g += e && !f.visible ? 0 : f.isNull ? 0 : f.y;\n        }\n\n        this.total = g;\n\n        for (d = 0; d < a; d++) f = c[d], f.percentage = 0 < g && (f.visible || !e) ? f.y / g * 100 : 0, f.total = g;\n      },\n      generatePoints: function () {\n        L.prototype.generatePoints.call(this);\n        this.updateTotals();\n      },\n      getX: function (d, g, c) {\n        var a = this.center,\n            e = this.radii ? this.radii[c.index] : a[2] / 2;\n        d = Math.asin(x((d - a[1]) / (e + c.labelDistance), -1, 1));\n        return a[0] + (g ? -1 : 1) * Math.cos(d) * (e + c.labelDistance) + (0 < c.labelDistance ? (g ? -1 : 1) * this.options.dataLabels.padding : 0);\n      },\n      translate: function (d) {\n        this.generatePoints();\n        var g = 0,\n            c = this.options,\n            a = c.slicedOffset,\n            e = a + (c.borderWidth || 0),\n            f = I(c.startAngle, c.endAngle),\n            h = this.startAngleRad = f.start;\n        f = (this.endAngleRad = f.end) - h;\n        var l = this.points,\n            m = c.dataLabels.distance;\n        c = c.ignoreHiddenPoint;\n        var v,\n            x = l.length;\n        d || (this.center = d = this.getCenter());\n\n        for (v = 0; v < x; v++) {\n          var y = l[v];\n          var z = h + g * f;\n          if (!c || y.visible) g += y.percentage / 100;\n          var E = h + g * f;\n          y.shapeType = \"arc\";\n          y.shapeArgs = {\n            x: d[0],\n            y: d[1],\n            r: d[2] / 2,\n            innerR: d[3] / 2,\n            start: Math.round(1E3 * z) / 1E3,\n            end: Math.round(1E3 * E) / 1E3\n          };\n          y.labelDistance = w(y.options.dataLabels && y.options.dataLabels.distance, m);\n          y.labelDistance = r(y.labelDistance, y.shapeArgs.r);\n          this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, y.labelDistance);\n          E = (E + z) / 2;\n          E > 1.5 * Math.PI ? E -= 2 * Math.PI : E < -Math.PI / 2 && (E += 2 * Math.PI);\n          y.slicedTranslation = {\n            translateX: Math.round(Math.cos(E) * a),\n            translateY: Math.round(Math.sin(E) * a)\n          };\n          var u = Math.cos(E) * d[2] / 2;\n          var b = Math.sin(E) * d[2] / 2;\n          y.tooltipPos = [d[0] + .7 * u, d[1] + .7 * b];\n          y.half = E < -Math.PI / 2 || E > Math.PI / 2 ? 1 : 0;\n          y.angle = E;\n          z = Math.min(e, y.labelDistance / 5);\n          y.labelPosition = {\n            natural: {\n              x: d[0] + u + Math.cos(E) * y.labelDistance,\n              y: d[1] + b + Math.sin(E) * y.labelDistance\n            },\n            \"final\": {},\n            alignment: 0 > y.labelDistance ? \"center\" : y.half ? \"right\" : \"left\",\n            connectorPosition: {\n              breakAt: {\n                x: d[0] + u + Math.cos(E) * z,\n                y: d[1] + b + Math.sin(E) * z\n              },\n              touchingSliceAt: {\n                x: d[0] + u,\n                y: d[1] + b\n              }\n            }\n          };\n        }\n\n        n(this, \"afterTranslate\");\n      },\n      drawEmpty: function () {\n        var d = this.startAngleRad,\n            g = this.endAngleRad,\n            c = this.options;\n\n        if (0 === this.total && this.center) {\n          var a = this.center[0];\n          var e = this.center[1];\n          this.graph || (this.graph = this.chart.renderer.arc(a, e, this.center[1] / 2, 0, d, g).addClass(\"highcharts-empty-series\").add(this.group));\n          this.graph.attr({\n            d: C.prototype.symbols.arc(a, e, this.center[2] / 2, 0, {\n              start: d,\n              end: g,\n              innerR: this.center[3] / 2\n            })\n          });\n          this.chart.styledMode || this.graph.attr({\n            \"stroke-width\": c.borderWidth,\n            fill: c.fillColor || \"none\",\n            stroke: c.color || \"#cccccc\"\n          });\n        } else this.graph && (this.graph = this.graph.destroy());\n      },\n      redrawPoints: function () {\n        var d = this,\n            e = d.chart,\n            c = e.renderer,\n            a,\n            f,\n            h,\n            l,\n            n = d.options.shadow;\n        this.drawEmpty();\n        !n || d.shadowGroup || e.styledMode || (d.shadowGroup = c.g(\"shadow\").attr({\n          zIndex: -1\n        }).add(d.group));\n        d.points.forEach(function (g) {\n          var p = {};\n          f = g.graphic;\n\n          if (!g.isNull && f) {\n            l = g.shapeArgs;\n            a = g.getTranslate();\n\n            if (!e.styledMode) {\n              var q = g.shadowGroup;\n              n && !q && (q = g.shadowGroup = c.g(\"shadow\").add(d.shadowGroup));\n              q && q.attr(a);\n              h = d.pointAttribs(g, g.selected && \"select\");\n            }\n\n            g.delayedRendering ? (f.setRadialReference(d.center).attr(l).attr(a), e.styledMode || f.attr(h).attr({\n              \"stroke-linejoin\": \"round\"\n            }).shadow(n, q), g.delayedRendering = !1) : (f.setRadialReference(d.center), e.styledMode || J(!0, p, h), J(!0, p, l, a), f.animate(p));\n            f.attr({\n              visibility: g.visible ? \"inherit\" : \"hidden\"\n            });\n            f.addClass(g.getClassName());\n          } else f && (g.graphic = f.destroy());\n        });\n      },\n      drawPoints: function () {\n        var d = this.chart.renderer;\n        this.points.forEach(function (e) {\n          e.graphic && e.hasNewShapeType() && (e.graphic = e.graphic.destroy());\n          e.graphic || (e.graphic = d[e.shapeType](e.shapeArgs).add(e.series.group), e.delayedRendering = !0);\n        });\n      },\n      searchPoint: f,\n      sortByAngle: function (d, e) {\n        d.sort(function (c, a) {\n          return \"undefined\" !== typeof c.angle && (a.angle - c.angle) * e;\n        });\n      },\n      drawLegendSymbol: F.drawRectangle,\n      getCenter: m.getCenter,\n      getSymbol: f,\n      drawGraph: null\n    }, {\n      init: function () {\n        K.prototype.init.apply(this, arguments);\n        var d = this;\n        d.name = w(d.name, \"Slice\");\n\n        var e = function (c) {\n          d.slice(\"select\" === c.type);\n        };\n\n        v(d, \"select\", e);\n        v(d, \"unselect\", e);\n        return d;\n      },\n      isValid: function () {\n        return l(this.y) && 0 <= this.y;\n      },\n      setVisible: function (d, e) {\n        var c = this,\n            a = c.series,\n            g = a.chart,\n            f = a.options.ignoreHiddenPoint;\n        e = w(e, f);\n        d !== c.visible && (c.visible = c.options.visible = d = \"undefined\" === typeof d ? !c.visible : d, a.options.data[a.data.indexOf(c)] = c.options, [\"graphic\", \"dataLabel\", \"connector\", \"shadowGroup\"].forEach(function (a) {\n          if (c[a]) c[a][d ? \"show\" : \"hide\"](!0);\n        }), c.legendItem && g.legend.colorizeItem(c, d), d || \"hover\" !== c.state || c.setState(\"\"), f && (a.isDirty = !0), e && g.redraw());\n      },\n      slice: function (d, g, c) {\n        var a = this.series;\n        e(c, a.chart);\n        w(g, !0);\n        this.sliced = this.options.sliced = D(d) ? d : !this.sliced;\n        a.options.data[a.data.indexOf(this)] = this.options;\n        this.graphic && this.graphic.animate(this.getTranslate());\n        this.shadowGroup && this.shadowGroup.animate(this.getTranslate());\n      },\n      getTranslate: function () {\n        return this.sliced ? this.slicedTranslation : {\n          translateX: 0,\n          translateY: 0\n        };\n      },\n      haloPath: function (d) {\n        var e = this.shapeArgs;\n        return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(e.x, e.y, e.r + d, e.r + d, {\n          innerR: e.r - 1,\n          start: e.start,\n          end: e.end\n        });\n      },\n      connectorShapes: {\n        fixedOffset: function (d, e, c) {\n          var a = e.breakAt;\n          e = e.touchingSliceAt;\n          return [[\"M\", d.x, d.y], c.softConnector ? [\"C\", d.x + (\"left\" === d.alignment ? -5 : 5), d.y, 2 * a.x - e.x, 2 * a.y - e.y, a.x, a.y] : [\"L\", a.x, a.y], [\"L\", e.x, e.y]];\n        },\n        straight: function (d, e) {\n          e = e.touchingSliceAt;\n          return [[\"M\", d.x, d.y], [\"L\", e.x, e.y]];\n        },\n        crookedLine: function (d, e, c) {\n          e = e.touchingSliceAt;\n          var a = this.series,\n              g = a.center[0],\n              f = a.chart.plotWidth,\n              h = a.chart.plotLeft;\n          a = d.alignment;\n          var l = this.shapeArgs.r;\n          c = r(c.crookDistance, 1);\n          f = \"left\" === a ? g + l + (f + h - g - l) * (1 - c) : h + (g - l) * c;\n          c = [\"L\", f, d.y];\n          g = !0;\n          if (\"left\" === a ? f > d.x || f < e.x : f < d.x || f > e.x) g = !1;\n          d = [[\"M\", d.x, d.y]];\n          g && d.push(c);\n          d.push([\"L\", e.x, e.y]);\n          return d;\n        }\n      },\n      getConnectorPath: function () {\n        var d = this.labelPosition,\n            e = this.series.options.dataLabels,\n            c = e.connectorShape,\n            a = this.connectorShapes;\n        a[c] && (c = a[c]);\n        return c.call(this, {\n          x: d.final.x,\n          y: d.final.y,\n          alignment: d.alignment\n        }, d.connectorPosition, e);\n      }\n    });\n    \"\";\n  });\n  N(m, \"Core/Series/DataLabels.js\", [m[\"Core/Animation/AnimationUtilities.js\"], m[\"Core/Globals.js\"], m[\"Core/Series/CartesianSeries.js\"], m[\"Core/Utilities.js\"]], function (f, h, m, z) {\n    var F = f.getDeferredAnimation;\n    f = h.noop;\n    var L = h.seriesTypes,\n        K = z.arrayMax,\n        C = z.clamp,\n        y = z.defined,\n        e = z.extend,\n        I = z.fireEvent,\n        v = z.format,\n        x = z.isArray,\n        D = z.merge,\n        n = z.objectEach,\n        l = z.pick,\n        J = z.relativeLength,\n        w = z.splat,\n        r = z.stableSort;\n    \"\";\n\n    h.distribute = function (d, e, c) {\n      function a(a, c) {\n        return a.target - c.target;\n      }\n\n      var f,\n          g = !0,\n          n = d,\n          m = [];\n      var v = 0;\n      var w = n.reducedLen || e;\n\n      for (f = d.length; f--;) v += d[f].size;\n\n      if (v > w) {\n        r(d, function (a, c) {\n          return (c.rank || 0) - (a.rank || 0);\n        });\n\n        for (v = f = 0; v <= w;) v += d[f].size, f++;\n\n        m = d.splice(f - 1, d.length);\n      }\n\n      r(d, a);\n\n      for (d = d.map(function (a) {\n        return {\n          size: a.size,\n          targets: [a.target],\n          align: l(a.align, .5)\n        };\n      }); g;) {\n        for (f = d.length; f--;) g = d[f], v = (Math.min.apply(0, g.targets) + Math.max.apply(0, g.targets)) / 2, g.pos = C(v - g.size * g.align, 0, e - g.size);\n\n        f = d.length;\n\n        for (g = !1; f--;) 0 < f && d[f - 1].pos + d[f - 1].size > d[f].pos && (d[f - 1].size += d[f].size, d[f - 1].targets = d[f - 1].targets.concat(d[f].targets), d[f - 1].align = .5, d[f - 1].pos + d[f - 1].size > e && (d[f - 1].pos = e - d[f - 1].size), d.splice(f, 1), g = !0);\n      }\n\n      n.push.apply(n, m);\n      f = 0;\n      d.some(function (a) {\n        var d = 0;\n        if (a.targets.some(function () {\n          n[f].pos = a.pos + d;\n          if (\"undefined\" !== typeof c && Math.abs(n[f].pos - n[f].target) > c) return n.slice(0, f + 1).forEach(function (a) {\n            delete a.pos;\n          }), n.reducedLen = (n.reducedLen || e) - .1 * e, n.reducedLen > .1 * e && h.distribute(n, e, c), !0;\n          d += n[f].size;\n          f++;\n        })) return !0;\n      });\n      r(n, a);\n    };\n\n    m.prototype.drawDataLabels = function () {\n      function d(a, c) {\n        var d = c.filter;\n        return d ? (c = d.operator, a = a[d.property], d = d.value, \">\" === c && a > d || \"<\" === c && a < d || \">=\" === c && a >= d || \"<=\" === c && a <= d || \"==\" === c && a == d || \"===\" === c && a === d ? !0 : !1) : !0;\n      }\n\n      function e(a, c) {\n        var d = [],\n            b;\n        if (x(a) && !x(c)) d = a.map(function (a) {\n          return D(a, c);\n        });else if (x(c) && !x(a)) d = c.map(function (b) {\n          return D(a, b);\n        });else if (x(a) || x(c)) for (b = Math.max(a.length, c.length); b--;) d[b] = D(a[b], c[b]);else d = D(a, c);\n        return d;\n      }\n\n      var c = this,\n          a = c.chart,\n          f = c.options,\n          h = f.dataLabels,\n          m = c.points,\n          r,\n          G = c.hasRendered || 0,\n          z = h.animation;\n      z = h.defer ? F(a, z, c) : {\n        defer: 0,\n        duration: 0\n      };\n      var C = a.renderer;\n      h = e(e(a.options.plotOptions && a.options.plotOptions.series && a.options.plotOptions.series.dataLabels, a.options.plotOptions && a.options.plotOptions[c.type] && a.options.plotOptions[c.type].dataLabels), h);\n      I(this, \"drawDataLabels\");\n\n      if (x(h) || h.enabled || c._hasPointLabels) {\n        var J = c.plotGroup(\"dataLabelsGroup\", \"data-labels\", G ? \"inherit\" : \"hidden\", h.zIndex || 6);\n        J.attr({\n          opacity: +G\n        });\n        !G && (G = c.dataLabelsGroup) && (c.visible && J.show(!0), G[f.animation ? \"animate\" : \"attr\"]({\n          opacity: 1\n        }, z));\n        m.forEach(function (g) {\n          r = w(e(h, g.dlOptions || g.options && g.options.dataLabels));\n          r.forEach(function (e, h) {\n            var b = e.enabled && (!g.isNull || g.dataLabelOnNull) && d(g, e),\n                k = g.dataLabels ? g.dataLabels[h] : g.dataLabel,\n                p = g.connectors ? g.connectors[h] : g.connector,\n                m = l(e.distance, g.labelDistance),\n                q = !k;\n\n            if (b) {\n              var u = g.getLabelConfig();\n              var r = l(e[g.formatPrefix + \"Format\"], e.format);\n              u = y(r) ? v(r, u, a) : (e[g.formatPrefix + \"Formatter\"] || e.formatter).call(u, e);\n              r = e.style;\n              var A = e.rotation;\n              a.styledMode || (r.color = l(e.color, r.color, c.color, \"#000000\"), \"contrast\" === r.color ? (g.contrastColor = C.getContrast(g.color || c.color), r.color = !y(m) && e.inside || 0 > m || f.stacking ? g.contrastColor : \"#000000\") : delete g.contrastColor, f.cursor && (r.cursor = f.cursor));\n              var w = {\n                r: e.borderRadius || 0,\n                rotation: A,\n                padding: e.padding,\n                zIndex: 1\n              };\n              a.styledMode || (w.fill = e.backgroundColor, w.stroke = e.borderColor, w[\"stroke-width\"] = e.borderWidth);\n              n(w, function (a, b) {\n                \"undefined\" === typeof a && delete w[b];\n              });\n            }\n\n            !k || b && y(u) ? b && y(u) && (k ? w.text = u : (g.dataLabels = g.dataLabels || [], k = g.dataLabels[h] = A ? C.text(u, 0, -9999, e.useHTML).addClass(\"highcharts-data-label\") : C.label(u, 0, -9999, e.shape, null, null, e.useHTML, null, \"data-label\"), h || (g.dataLabel = k), k.addClass(\" highcharts-data-label-color-\" + g.colorIndex + \" \" + (e.className || \"\") + (e.useHTML ? \" highcharts-tracker\" : \"\"))), k.options = e, k.attr(w), a.styledMode || k.css(r).shadow(e.shadow), k.added || k.add(J), e.textPath && !e.useHTML && (k.setTextPath(g.getDataLabelPath && g.getDataLabelPath(k) || g.graphic, e.textPath), g.dataLabelPath && !e.textPath.enabled && (g.dataLabelPath = g.dataLabelPath.destroy())), c.alignDataLabel(g, k, e, null, q)) : (g.dataLabel = g.dataLabel && g.dataLabel.destroy(), g.dataLabels && (1 === g.dataLabels.length ? delete g.dataLabels : delete g.dataLabels[h]), h || delete g.dataLabel, p && (g.connector = g.connector.destroy(), g.connectors && (1 === g.connectors.length ? delete g.connectors : delete g.connectors[h])));\n          });\n        });\n      }\n\n      I(this, \"afterDrawDataLabels\");\n    };\n\n    m.prototype.alignDataLabel = function (d, g, c, a, f) {\n      var h = this,\n          n = this.chart,\n          m = this.isCartesian && n.inverted,\n          q = this.enabledDataSorting,\n          r = l(d.dlBox && d.dlBox.centerX, d.plotX, -9999),\n          v = l(d.plotY, -9999),\n          w = g.getBBox(),\n          x = c.rotation,\n          y = c.align,\n          u = n.isInsidePlot(r, Math.round(v), m),\n          b = \"justify\" === l(c.overflow, q ? \"none\" : \"justify\"),\n          k = this.visible && !1 !== d.visible && (d.series.forceDL || q && !b || u || c.inside && a && n.isInsidePlot(r, m ? a.x + 1 : a.y + a.height - 1, m));\n\n      var t = function (a) {\n        q && h.xAxis && !b && h.setDataLabelStartPos(d, g, f, u, a);\n      };\n\n      if (k) {\n        var z = n.renderer.fontMetrics(n.styledMode ? void 0 : c.style.fontSize, g).b;\n        a = e({\n          x: m ? this.yAxis.len - v : r,\n          y: Math.round(m ? this.xAxis.len - r : v),\n          width: 0,\n          height: 0\n        }, a);\n        e(c, {\n          width: w.width,\n          height: w.height\n        });\n        x ? (b = !1, r = n.renderer.rotCorr(z, x), r = {\n          x: a.x + (c.x || 0) + a.width / 2 + r.x,\n          y: a.y + (c.y || 0) + {\n            top: 0,\n            middle: .5,\n            bottom: 1\n          }[c.verticalAlign] * a.height\n        }, t(r), g[f ? \"attr\" : \"animate\"](r).attr({\n          align: y\n        }), t = (x + 720) % 360, t = 180 < t && 360 > t, \"left\" === y ? r.y -= t ? w.height : 0 : \"center\" === y ? (r.x -= w.width / 2, r.y -= w.height / 2) : \"right\" === y && (r.x -= w.width, r.y -= t ? 0 : w.height), g.placed = !0, g.alignAttr = r) : (t(a), g.align(c, null, a), r = g.alignAttr);\n        b && 0 <= a.height ? this.justifyDataLabel(g, c, r, w, a, f) : l(c.crop, !0) && (k = n.isInsidePlot(r.x, r.y) && n.isInsidePlot(r.x + w.width, r.y + w.height));\n        if (c.shape && !x) g[f ? \"attr\" : \"animate\"]({\n          anchorX: m ? n.plotWidth - d.plotY : d.plotX,\n          anchorY: m ? n.plotHeight - d.plotX : d.plotY\n        });\n      }\n\n      f && q && (g.placed = !1);\n      k || q && !b || (g.hide(!0), g.placed = !1);\n    };\n\n    m.prototype.setDataLabelStartPos = function (d, e, c, a, f) {\n      var g = this.chart,\n          h = g.inverted,\n          l = this.xAxis,\n          n = l.reversed,\n          m = h ? e.height / 2 : e.width / 2;\n      d = (d = d.pointWidth) ? d / 2 : 0;\n      l = h ? f.x : n ? -m - d : l.width - m + d;\n      f = h ? n ? this.yAxis.height - m + d : -m - d : f.y;\n      e.startXPos = l;\n      e.startYPos = f;\n      a ? \"hidden\" === e.visibility && (e.show(), e.attr({\n        opacity: 0\n      }).animate({\n        opacity: 1\n      })) : e.attr({\n        opacity: 1\n      }).animate({\n        opacity: 0\n      }, void 0, e.hide);\n      g.hasRendered && (c && e.attr({\n        x: e.startXPos,\n        y: e.startYPos\n      }), e.placed = !0);\n    };\n\n    m.prototype.justifyDataLabel = function (d, e, c, a, f, h) {\n      var g = this.chart,\n          p = e.align,\n          l = e.verticalAlign,\n          n = d.box ? 0 : d.padding || 0,\n          m = e.x;\n      m = void 0 === m ? 0 : m;\n      var q = e.y;\n      var r = void 0 === q ? 0 : q;\n      q = c.x + n;\n\n      if (0 > q) {\n        \"right\" === p && 0 <= m ? (e.align = \"left\", e.inside = !0) : m -= q;\n        var v = !0;\n      }\n\n      q = c.x + a.width - n;\n      q > g.plotWidth && (\"left\" === p && 0 >= m ? (e.align = \"right\", e.inside = !0) : m += g.plotWidth - q, v = !0);\n      q = c.y + n;\n      0 > q && (\"bottom\" === l && 0 <= r ? (e.verticalAlign = \"top\", e.inside = !0) : r -= q, v = !0);\n      q = c.y + a.height - n;\n      q > g.plotHeight && (\"top\" === l && 0 >= r ? (e.verticalAlign = \"bottom\", e.inside = !0) : r += g.plotHeight - q, v = !0);\n      v && (e.x = m, e.y = r, d.placed = !h, d.align(e, void 0, f));\n      return v;\n    };\n\n    L.pie && (L.pie.prototype.dataLabelPositioners = {\n      radialDistributionY: function (d) {\n        return d.top + d.distributeBox.pos;\n      },\n      radialDistributionX: function (d, e, c, a) {\n        return d.getX(c < e.top + 2 || c > e.bottom - 2 ? a : c, e.half, e);\n      },\n      justify: function (d, e, c) {\n        return c[0] + (d.half ? -1 : 1) * (e + d.labelDistance);\n      },\n      alignToPlotEdges: function (d, e, c, a) {\n        d = d.getBBox().width;\n        return e ? d + a : c - d - a;\n      },\n      alignToConnectors: function (d, e, c, a) {\n        var f = 0,\n            g;\n        d.forEach(function (a) {\n          g = a.dataLabel.getBBox().width;\n          g > f && (f = g);\n        });\n        return e ? f + a : c - f - a;\n      }\n    }, L.pie.prototype.drawDataLabels = function () {\n      var d = this,\n          e = d.data,\n          c,\n          a = d.chart,\n          f = d.options.dataLabels || {},\n          p = f.connectorPadding,\n          n,\n          r = a.plotWidth,\n          v = a.plotHeight,\n          w = a.plotLeft,\n          x = Math.round(a.chartWidth / 3),\n          z,\n          C = d.center,\n          E = C[2] / 2,\n          u = C[1],\n          b,\n          k,\n          t,\n          F,\n          I = [[], []],\n          J,\n          L,\n          N,\n          P,\n          S = [0, 0, 0, 0],\n          Y = d.dataLabelPositioners,\n          W;\n      d.visible && (f.enabled || d._hasPointLabels) && (e.forEach(function (a) {\n        a.dataLabel && a.visible && a.dataLabel.shortened && (a.dataLabel.attr({\n          width: \"auto\"\n        }).css({\n          width: \"auto\",\n          textOverflow: \"clip\"\n        }), a.dataLabel.shortened = !1);\n      }), m.prototype.drawDataLabels.apply(d), e.forEach(function (a) {\n        a.dataLabel && (a.visible ? (I[a.half].push(a), a.dataLabel._pos = null, !y(f.style.width) && !y(a.options.dataLabels && a.options.dataLabels.style && a.options.dataLabels.style.width) && a.dataLabel.getBBox().width > x && (a.dataLabel.css({\n          width: Math.round(.7 * x) + \"px\"\n        }), a.dataLabel.shortened = !0)) : (a.dataLabel = a.dataLabel.destroy(), a.dataLabels && 1 === a.dataLabels.length && delete a.dataLabels));\n      }), I.forEach(function (e, g) {\n        var n = e.length,\n            m = [],\n            q;\n\n        if (n) {\n          d.sortByAngle(e, g - .5);\n\n          if (0 < d.maxLabelDistance) {\n            var A = Math.max(0, u - E - d.maxLabelDistance);\n            var B = Math.min(u + E + d.maxLabelDistance, a.plotHeight);\n            e.forEach(function (b) {\n              0 < b.labelDistance && b.dataLabel && (b.top = Math.max(0, u - E - b.labelDistance), b.bottom = Math.min(u + E + b.labelDistance, a.plotHeight), q = b.dataLabel.getBBox().height || 21, b.distributeBox = {\n                target: b.labelPosition.natural.y - b.top + q / 2,\n                size: q,\n                rank: b.y\n              }, m.push(b.distributeBox));\n            });\n            A = B + q - A;\n            h.distribute(m, A, A / 5);\n          }\n\n          for (P = 0; P < n; P++) {\n            c = e[P];\n            t = c.labelPosition;\n            b = c.dataLabel;\n            N = !1 === c.visible ? \"hidden\" : \"inherit\";\n            L = A = t.natural.y;\n            m && y(c.distributeBox) && (\"undefined\" === typeof c.distributeBox.pos ? N = \"hidden\" : (F = c.distributeBox.size, L = Y.radialDistributionY(c)));\n            delete c.positionIndex;\n            if (f.justify) J = Y.justify(c, E, C);else switch (f.alignTo) {\n              case \"connectors\":\n                J = Y.alignToConnectors(e, g, r, w);\n                break;\n\n              case \"plotEdges\":\n                J = Y.alignToPlotEdges(b, g, r, w);\n                break;\n\n              default:\n                J = Y.radialDistributionX(d, c, L, A);\n            }\n            b._attr = {\n              visibility: N,\n              align: t.alignment\n            };\n            W = c.options.dataLabels || {};\n            b._pos = {\n              x: J + l(W.x, f.x) + ({\n                left: p,\n                right: -p\n              }[t.alignment] || 0),\n              y: L + l(W.y, f.y) - 10\n            };\n            t.final.x = J;\n            t.final.y = L;\n            l(f.crop, !0) && (k = b.getBBox().width, A = null, J - k < p && 1 === g ? (A = Math.round(k - J + p), S[3] = Math.max(A, S[3])) : J + k > r - p && 0 === g && (A = Math.round(J + k - r + p), S[1] = Math.max(A, S[1])), 0 > L - F / 2 ? S[0] = Math.max(Math.round(-L + F / 2), S[0]) : L + F / 2 > v && (S[2] = Math.max(Math.round(L + F / 2 - v), S[2])), b.sideOverflow = A);\n          }\n        }\n      }), 0 === K(S) || this.verifyDataLabelOverflow(S)) && (this.placeDataLabels(), this.points.forEach(function (c) {\n        W = D(f, c.options.dataLabels);\n\n        if (n = l(W.connectorWidth, 1)) {\n          var e;\n          z = c.connector;\n\n          if ((b = c.dataLabel) && b._pos && c.visible && 0 < c.labelDistance) {\n            N = b._attr.visibility;\n            if (e = !z) c.connector = z = a.renderer.path().addClass(\"highcharts-data-label-connector  highcharts-color-\" + c.colorIndex + (c.className ? \" \" + c.className : \"\")).add(d.dataLabelsGroup), a.styledMode || z.attr({\n              \"stroke-width\": n,\n              stroke: W.connectorColor || c.color || \"#666666\"\n            });\n            z[e ? \"attr\" : \"animate\"]({\n              d: c.getConnectorPath()\n            });\n            z.attr(\"visibility\", N);\n          } else z && (c.connector = z.destroy());\n        }\n      }));\n    }, L.pie.prototype.placeDataLabels = function () {\n      this.points.forEach(function (d) {\n        var e = d.dataLabel,\n            c;\n        e && d.visible && ((c = e._pos) ? (e.sideOverflow && (e._attr.width = Math.max(e.getBBox().width - e.sideOverflow, 0), e.css({\n          width: e._attr.width + \"px\",\n          textOverflow: (this.options.dataLabels.style || {}).textOverflow || \"ellipsis\"\n        }), e.shortened = !0), e.attr(e._attr), e[e.moved ? \"animate\" : \"attr\"](c), e.moved = !0) : e && e.attr({\n          y: -9999\n        }));\n        delete d.distributeBox;\n      }, this);\n    }, L.pie.prototype.alignDataLabel = f, L.pie.prototype.verifyDataLabelOverflow = function (d) {\n      var e = this.center,\n          c = this.options,\n          a = c.center,\n          f = c.minSize || 80,\n          h = null !== c.size;\n\n      if (!h) {\n        if (null !== a[0]) var l = Math.max(e[2] - Math.max(d[1], d[3]), f);else l = Math.max(e[2] - d[1] - d[3], f), e[0] += (d[3] - d[1]) / 2;\n        null !== a[1] ? l = C(l, f, e[2] - Math.max(d[0], d[2])) : (l = C(l, f, e[2] - d[0] - d[2]), e[1] += (d[0] - d[2]) / 2);\n        l < e[2] ? (e[2] = l, e[3] = Math.min(J(c.innerSize || 0, l), l), this.translate(e), this.drawDataLabels && this.drawDataLabels()) : h = !0;\n      }\n\n      return h;\n    });\n    L.column && (L.column.prototype.alignDataLabel = function (d, e, c, a, f) {\n      var g = this.chart.inverted,\n          h = d.series,\n          n = d.dlBox || d.shapeArgs,\n          q = l(d.below, d.plotY > l(this.translatedThreshold, h.yAxis.len)),\n          r = l(c.inside, !!this.options.stacking);\n      n && (a = D(n), 0 > a.y && (a.height += a.y, a.y = 0), n = a.y + a.height - h.yAxis.len, 0 < n && n < a.height && (a.height -= n), g && (a = {\n        x: h.yAxis.len - a.y - a.height,\n        y: h.xAxis.len - a.x - a.width,\n        width: a.height,\n        height: a.width\n      }), r || (g ? (a.x += q ? 0 : a.width, a.width = 0) : (a.y += q ? a.height : 0, a.height = 0)));\n      c.align = l(c.align, !g || r ? \"center\" : q ? \"right\" : \"left\");\n      c.verticalAlign = l(c.verticalAlign, g || r ? \"middle\" : q ? \"top\" : \"bottom\");\n      m.prototype.alignDataLabel.call(this, d, e, c, a, f);\n      c.inside && d.contrastColor && e.css({\n        color: d.contrastColor\n      });\n    });\n  });\n  N(m, \"Extensions/OverlappingDataLabels.js\", [m[\"Core/Chart/Chart.js\"], m[\"Core/Utilities.js\"]], function (f, h) {\n    var m = h.addEvent,\n        z = h.fireEvent,\n        F = h.isArray,\n        L = h.isNumber,\n        K = h.objectEach,\n        C = h.pick;\n    m(f, \"render\", function () {\n      var f = [];\n      (this.labelCollectors || []).forEach(function (e) {\n        f = f.concat(e());\n      });\n      (this.yAxis || []).forEach(function (e) {\n        e.stacking && e.options.stackLabels && !e.options.stackLabels.allowOverlap && K(e.stacking.stacks, function (e) {\n          K(e, function (e) {\n            f.push(e.label);\n          });\n        });\n      });\n      (this.series || []).forEach(function (e) {\n        var h = e.options.dataLabels;\n        e.visible && (!1 !== h.enabled || e._hasPointLabels) && (e.nodes || e.points).forEach(function (e) {\n          e.visible && (F(e.dataLabels) ? e.dataLabels : e.dataLabel ? [e.dataLabel] : []).forEach(function (h) {\n            var m = h.options;\n            h.labelrank = C(m.labelrank, e.labelrank, e.shapeArgs && e.shapeArgs.height);\n            m.allowOverlap || f.push(h);\n          });\n        });\n      });\n      this.hideOverlappingLabels(f);\n    });\n\n    f.prototype.hideOverlappingLabels = function (f) {\n      var e = this,\n          h = f.length,\n          m = e.renderer,\n          x,\n          y,\n          n,\n          l = !1;\n\n      var C = function (d) {\n        var e,\n            c = d.box ? 0 : d.padding || 0,\n            a = e = 0,\n            f;\n\n        if (d && (!d.alignAttr || d.placed)) {\n          var h = d.alignAttr || {\n            x: d.attr(\"x\"),\n            y: d.attr(\"y\")\n          };\n          var l = d.parentGroup;\n          d.width || (e = d.getBBox(), d.width = e.width, d.height = e.height, e = m.fontMetrics(null, d.element).h);\n          var n = d.width - 2 * c;\n          (f = {\n            left: \"0\",\n            center: \"0.5\",\n            right: \"1\"\n          }[d.alignValue]) ? a = +f * n : L(d.x) && Math.round(d.x) !== d.translateX && (a = d.x - d.translateX);\n          return {\n            x: h.x + (l.translateX || 0) + c - (a || 0),\n            y: h.y + (l.translateY || 0) + c - e,\n            width: d.width - 2 * c,\n            height: d.height - 2 * c\n          };\n        }\n      };\n\n      for (y = 0; y < h; y++) if (x = f[y]) x.oldOpacity = x.opacity, x.newOpacity = 1, x.absoluteBox = C(x);\n\n      f.sort(function (d, e) {\n        return (e.labelrank || 0) - (d.labelrank || 0);\n      });\n\n      for (y = 0; y < h; y++) {\n        var w = (C = f[y]) && C.absoluteBox;\n\n        for (x = y + 1; x < h; ++x) {\n          var r = (n = f[x]) && n.absoluteBox;\n          !w || !r || C === n || 0 === C.newOpacity || 0 === n.newOpacity || r.x >= w.x + w.width || r.x + r.width <= w.x || r.y >= w.y + w.height || r.y + r.height <= w.y || ((C.labelrank < n.labelrank ? C : n).newOpacity = 0);\n        }\n      }\n\n      f.forEach(function (d) {\n        if (d) {\n          var f = d.newOpacity;\n          d.oldOpacity !== f && (d.alignAttr && d.placed ? (d[f ? \"removeClass\" : \"addClass\"](\"highcharts-data-label-hidden\"), l = !0, d.alignAttr.opacity = f, d[d.isOld ? \"animate\" : \"attr\"](d.alignAttr, null, function () {\n            e.styledMode || d.css({\n              pointerEvents: f ? \"auto\" : \"none\"\n            });\n            d.visibility = f ? \"inherit\" : \"hidden\";\n          }), z(e, \"afterHideOverlappingLabel\")) : d.attr({\n            opacity: f\n          }));\n          d.isOld = !0;\n        }\n      });\n      l && z(e, \"afterHideAllOverlappingLabels\");\n    };\n  });\n  N(m, \"Core/Interaction.js\", [m[\"Core/Series/Series.js\"], m[\"Core/Chart/Chart.js\"], m[\"Core/Globals.js\"], m[\"Core/Legend.js\"], m[\"Series/LineSeries.js\"], m[\"Core/Options.js\"], m[\"Core/Series/Point.js\"], m[\"Core/Utilities.js\"]], function (f, h, m, z, F, L, K, C) {\n    f = f.seriesTypes;\n    var y = m.hasTouch,\n        e = m.svg,\n        I = L.defaultOptions,\n        v = C.addEvent,\n        x = C.createElement,\n        D = C.css,\n        n = C.defined,\n        l = C.extend,\n        J = C.fireEvent,\n        w = C.isArray,\n        r = C.isFunction,\n        d = C.isNumber,\n        g = C.isObject,\n        c = C.merge,\n        a = C.objectEach,\n        q = C.pick;\n    \"\";\n    m = m.TrackerMixin = {\n      drawTrackerPoint: function () {\n        var a = this,\n            c = a.chart,\n            d = c.pointer,\n            e = function (a) {\n          var c = d.getPointFromEvent(a);\n          \"undefined\" !== typeof c && (d.isDirectTouch = !0, c.onMouseOver(a));\n        },\n            f;\n\n        a.points.forEach(function (a) {\n          f = w(a.dataLabels) ? a.dataLabels : a.dataLabel ? [a.dataLabel] : [];\n          a.graphic && (a.graphic.element.point = a);\n          f.forEach(function (c) {\n            c.div ? c.div.point = a : c.element.point = a;\n          });\n        });\n        a._hasTracking || (a.trackerGroups.forEach(function (f) {\n          if (a[f]) {\n            a[f].addClass(\"highcharts-tracker\").on(\"mouseover\", e).on(\"mouseout\", function (a) {\n              d.onTrackerMouseOut(a);\n            });\n            if (y) a[f].on(\"touchstart\", e);\n            !c.styledMode && a.options.cursor && a[f].css(D).css({\n              cursor: a.options.cursor\n            });\n          }\n        }), a._hasTracking = !0);\n        J(this, \"afterDrawTracker\");\n      },\n      drawTrackerGraph: function () {\n        var a = this,\n            c = a.options,\n            d = c.trackByArea,\n            f = [].concat(d ? a.areaPath : a.graphPath),\n            g = a.chart,\n            h = g.pointer,\n            l = g.renderer,\n            n = g.options.tooltip.snap,\n            m = a.tracker,\n            q = function (b) {\n          if (g.hoverSeries !== a) a.onMouseOver();\n        },\n            b = \"rgba(192,192,192,\" + (e ? .0001 : .002) + \")\";\n\n        m ? m.attr({\n          d: f\n        }) : a.graph && (a.tracker = l.path(f).attr({\n          visibility: a.visible ? \"visible\" : \"hidden\",\n          zIndex: 2\n        }).addClass(d ? \"highcharts-tracker-area\" : \"highcharts-tracker-line\").add(a.group), g.styledMode || a.tracker.attr({\n          \"stroke-linecap\": \"round\",\n          \"stroke-linejoin\": \"round\",\n          stroke: b,\n          fill: d ? b : \"none\",\n          \"stroke-width\": a.graph.strokeWidth() + (d ? 0 : 2 * n)\n        }), [a.tracker, a.markerGroup].forEach(function (a) {\n          a.addClass(\"highcharts-tracker\").on(\"mouseover\", q).on(\"mouseout\", function (a) {\n            h.onTrackerMouseOut(a);\n          });\n          c.cursor && !g.styledMode && a.css({\n            cursor: c.cursor\n          });\n          if (y) a.on(\"touchstart\", q);\n        }));\n        J(this, \"afterDrawTracker\");\n      }\n    };\n    f.column && (f.column.prototype.drawTracker = m.drawTrackerPoint);\n    f.pie && (f.pie.prototype.drawTracker = m.drawTrackerPoint);\n    f.scatter && (f.scatter.prototype.drawTracker = m.drawTrackerPoint);\n    l(z.prototype, {\n      setItemEvents: function (a, d, e) {\n        var f = this,\n            g = f.chart.renderer.boxWrapper,\n            h = a instanceof K,\n            p = \"highcharts-legend-\" + (h ? \"point\" : \"series\") + \"-active\",\n            l = f.chart.styledMode;\n        (e ? [d, a.legendSymbol] : [a.legendGroup]).forEach(function (e) {\n          if (e) e.on(\"mouseover\", function () {\n            a.visible && f.allItems.forEach(function (c) {\n              a !== c && c.setState(\"inactive\", !h);\n            });\n            a.setState(\"hover\");\n            a.visible && g.addClass(p);\n            l || d.css(f.options.itemHoverStyle);\n          }).on(\"mouseout\", function () {\n            f.chart.styledMode || d.css(c(a.visible ? f.itemStyle : f.itemHiddenStyle));\n            f.allItems.forEach(function (c) {\n              a !== c && c.setState(\"\", !h);\n            });\n            g.removeClass(p);\n            a.setState();\n          }).on(\"click\", function (c) {\n            var b = function () {\n              a.setVisible && a.setVisible();\n              f.allItems.forEach(function (b) {\n                a !== b && b.setState(a.visible ? \"inactive\" : \"\", !h);\n              });\n            };\n\n            g.removeClass(p);\n            c = {\n              browserEvent: c\n            };\n            a.firePointEvent ? a.firePointEvent(\"legendItemClick\", c, b) : J(a, \"legendItemClick\", c, b);\n          });\n        });\n      },\n      createCheckboxForItem: function (a) {\n        a.checkbox = x(\"input\", {\n          type: \"checkbox\",\n          className: \"highcharts-legend-checkbox\",\n          checked: a.selected,\n          defaultChecked: a.selected\n        }, this.options.itemCheckboxStyle, this.chart.container);\n        v(a.checkbox, \"click\", function (c) {\n          J(a.series || a, \"checkboxClick\", {\n            checked: c.target.checked,\n            item: a\n          }, function () {\n            a.select();\n          });\n        });\n      }\n    });\n    l(h.prototype, {\n      showResetZoom: function () {\n        function a() {\n          c.zoomOut();\n        }\n\n        var c = this,\n            d = I.lang,\n            e = c.options.chart.resetZoomButton,\n            f = e.theme,\n            g = f.states,\n            h = \"chart\" === e.relativeTo || \"spaceBox\" === e.relativeTo ? null : \"plotBox\";\n        J(this, \"beforeShowResetZoom\", null, function () {\n          c.resetZoomButton = c.renderer.button(d.resetZoom, null, null, a, f, g && g.hover).attr({\n            align: e.position.align,\n            title: d.resetZoomTitle\n          }).addClass(\"highcharts-reset-zoom\").add().align(e.position, !1, h);\n        });\n        J(this, \"afterShowResetZoom\");\n      },\n      zoomOut: function () {\n        J(this, \"selection\", {\n          resetSelection: !0\n        }, this.zoom);\n      },\n      zoom: function (a) {\n        var c = this,\n            d,\n            e = c.pointer,\n            f = !1,\n            h = c.inverted ? e.mouseDownX : e.mouseDownY;\n        !a || a.resetSelection ? (c.axes.forEach(function (a) {\n          d = a.zoom();\n        }), e.initiated = !1) : a.xAxis.concat(a.yAxis).forEach(function (a) {\n          var g = a.axis,\n              p = c.inverted ? g.left : g.top,\n              b = c.inverted ? p + g.width : p + g.height,\n              k = g.isXAxis,\n              l = !1;\n          if (!k && h >= p && h <= b || k || !n(h)) l = !0;\n          e[k ? \"zoomX\" : \"zoomY\"] && l && (d = g.zoom(a.min, a.max), g.displayBtn && (f = !0));\n        });\n        var p = c.resetZoomButton;\n        f && !p ? c.showResetZoom() : !f && g(p) && (c.resetZoomButton = p.destroy());\n        d && c.redraw(q(c.options.chart.animation, a && a.animation, 100 > c.pointCount));\n      },\n      pan: function (a, c) {\n        var e = this,\n            f = e.hoverPoints,\n            g = e.options.chart,\n            h = e.options.mapNavigation && e.options.mapNavigation.enabled,\n            p;\n        c = \"object\" === typeof c ? c : {\n          enabled: c,\n          type: \"x\"\n        };\n        g && g.panning && (g.panning = c);\n        var l = c.type;\n        J(this, \"pan\", {\n          originalEvent: a\n        }, function () {\n          f && f.forEach(function (a) {\n            a.setState();\n          });\n          var c = [1];\n          \"xy\" === l ? c = [1, 0] : \"y\" === l && (c = [0]);\n          c.forEach(function (c) {\n            var b = e[c ? \"xAxis\" : \"yAxis\"][0],\n                f = b.horiz,\n                g = a[f ? \"chartX\" : \"chartY\"];\n            f = f ? \"mouseDownX\" : \"mouseDownY\";\n            var n = e[f],\n                m = (b.pointRange || 0) / 2,\n                r = b.reversed && !e.inverted || !b.reversed && e.inverted ? -1 : 1,\n                u = b.getExtremes(),\n                v = b.toValue(n - g, !0) + m * r;\n            r = b.toValue(n + b.len - g, !0) - m * r;\n            var w = r < v;\n            n = w ? r : v;\n            v = w ? v : r;\n            var A = b.hasVerticalPanning(),\n                x = b.panningState;\n            b.series.forEach(function (a) {\n              if (A && !c && (!x || x.isDirty)) {\n                var b = a.getProcessedData(!0);\n                a = a.getExtremes(b.yData, !0);\n                x || (x = {\n                  startMin: Number.MAX_VALUE,\n                  startMax: -Number.MAX_VALUE\n                });\n                d(a.dataMin) && d(a.dataMax) && (x.startMin = Math.min(a.dataMin, x.startMin), x.startMax = Math.max(a.dataMax, x.startMax));\n              }\n            });\n            r = Math.min(q(null === x || void 0 === x ? void 0 : x.startMin, u.dataMin), m ? u.min : b.toValue(b.toPixels(u.min) - b.minPixelPadding));\n            m = Math.max(q(null === x || void 0 === x ? void 0 : x.startMax, u.dataMax), m ? u.max : b.toValue(b.toPixels(u.max) + b.minPixelPadding));\n            b.panningState = x;\n            b.isOrdinal || (w = r - n, 0 < w && (v += w, n = r), w = v - m, 0 < w && (v = m, n -= w), b.series.length && n !== u.min && v !== u.max && n >= r && v <= m && (b.setExtremes(n, v, !1, !1, {\n              trigger: \"pan\"\n            }), e.resetZoomButton || h || n === r || v === m || !l.match(\"y\") || (e.showResetZoom(), b.displayBtn = !1), p = !0), e[f] = g);\n          });\n          p && e.redraw(!1);\n          D(e.container, {\n            cursor: \"move\"\n          });\n        });\n      }\n    });\n    l(K.prototype, {\n      select: function (a, c) {\n        var d = this,\n            e = d.series,\n            f = e.chart;\n        this.selectedStaging = a = q(a, !d.selected);\n        d.firePointEvent(a ? \"select\" : \"unselect\", {\n          accumulate: c\n        }, function () {\n          d.selected = d.options.selected = a;\n          e.options.data[e.data.indexOf(d)] = d.options;\n          d.setState(a && \"select\");\n          c || f.getSelectedPoints().forEach(function (a) {\n            var c = a.series;\n            a.selected && a !== d && (a.selected = a.options.selected = !1, c.options.data[c.data.indexOf(a)] = a.options, a.setState(f.hoverPoints && c.options.inactiveOtherPoints ? \"inactive\" : \"\"), a.firePointEvent(\"unselect\"));\n          });\n        });\n        delete this.selectedStaging;\n      },\n      onMouseOver: function (a) {\n        var c = this.series.chart,\n            d = c.pointer;\n        a = a ? d.normalize(a) : d.getChartCoordinatesFromPoint(this, c.inverted);\n        d.runPointActions(a, this);\n      },\n      onMouseOut: function () {\n        var a = this.series.chart;\n        this.firePointEvent(\"mouseOut\");\n        this.series.options.inactiveOtherPoints || (a.hoverPoints || []).forEach(function (a) {\n          a.setState();\n        });\n        a.hoverPoints = a.hoverPoint = null;\n      },\n      importEvents: function () {\n        if (!this.hasImportedEvents) {\n          var d = this,\n              e = c(d.series.options.point, d.options).events;\n          d.events = e;\n          a(e, function (a, c) {\n            r(a) && v(d, c, a);\n          });\n          this.hasImportedEvents = !0;\n        }\n      },\n      setState: function (a, c) {\n        var d = this.series,\n            e = this.state,\n            f = d.options.states[a || \"normal\"] || {},\n            g = I.plotOptions[d.type].marker && d.options.marker,\n            h = g && !1 === g.enabled,\n            p = g && g.states && g.states[a || \"normal\"] || {},\n            n = !1 === p.enabled,\n            m = d.stateMarkerGraphic,\n            b = this.marker || {},\n            k = d.chart,\n            r = d.halo,\n            v,\n            w = g && d.markerAttribs;\n        a = a || \"\";\n\n        if (!(a === this.state && !c || this.selected && \"select\" !== a || !1 === f.enabled || a && (n || h && !1 === p.enabled) || a && b.states && b.states[a] && !1 === b.states[a].enabled)) {\n          this.state = a;\n          w && (v = d.markerAttribs(this, a));\n\n          if (this.graphic) {\n            e && this.graphic.removeClass(\"highcharts-point-\" + e);\n            a && this.graphic.addClass(\"highcharts-point-\" + a);\n\n            if (!k.styledMode) {\n              var x = d.pointAttribs(this, a);\n              var y = q(k.options.chart.animation, f.animation);\n              d.options.inactiveOtherPoints && x.opacity && ((this.dataLabels || []).forEach(function (a) {\n                a && a.animate({\n                  opacity: x.opacity\n                }, y);\n              }), this.connector && this.connector.animate({\n                opacity: x.opacity\n              }, y));\n              this.graphic.animate(x, y);\n            }\n\n            v && this.graphic.animate(v, q(k.options.chart.animation, p.animation, g.animation));\n            m && m.hide();\n          } else {\n            if (a && p) {\n              e = b.symbol || d.symbol;\n              m && m.currentSymbol !== e && (m = m.destroy());\n              if (v) if (m) m[c ? \"animate\" : \"attr\"]({\n                x: v.x,\n                y: v.y\n              });else e && (d.stateMarkerGraphic = m = k.renderer.symbol(e, v.x, v.y, v.width, v.height).add(d.markerGroup), m.currentSymbol = e);\n              !k.styledMode && m && m.attr(d.pointAttribs(this, a));\n            }\n\n            m && (m[a && this.isInside ? \"show\" : \"hide\"](), m.element.point = this);\n          }\n\n          a = f.halo;\n          f = (m = this.graphic || m) && m.visibility || \"inherit\";\n          a && a.size && m && \"hidden\" !== f && !this.isCluster ? (r || (d.halo = r = k.renderer.path().add(m.parentGroup)), r.show()[c ? \"animate\" : \"attr\"]({\n            d: this.haloPath(a.size)\n          }), r.attr({\n            \"class\": \"highcharts-halo highcharts-color-\" + q(this.colorIndex, d.colorIndex) + (this.className ? \" \" + this.className : \"\"),\n            visibility: f,\n            zIndex: -1\n          }), r.point = this, k.styledMode || r.attr(l({\n            fill: this.color || d.color,\n            \"fill-opacity\": a.opacity\n          }, a.attributes))) : r && r.point && r.point.haloPath && r.animate({\n            d: r.point.haloPath(0)\n          }, null, r.hide);\n          J(this, \"afterSetState\");\n        }\n      },\n      haloPath: function (a) {\n        return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - a, this.plotY - a, 2 * a, 2 * a);\n      }\n    });\n    l(F.prototype, {\n      onMouseOver: function () {\n        var a = this.chart,\n            c = a.hoverSeries;\n        a.pointer.setHoverChartIndex();\n        if (c && c !== this) c.onMouseOut();\n        this.options.events.mouseOver && J(this, \"mouseOver\");\n        this.setState(\"hover\");\n        a.hoverSeries = this;\n      },\n      onMouseOut: function () {\n        var a = this.options,\n            c = this.chart,\n            d = c.tooltip,\n            e = c.hoverPoint;\n        c.hoverSeries = null;\n        if (e) e.onMouseOut();\n        this && a.events.mouseOut && J(this, \"mouseOut\");\n        !d || this.stickyTracking || d.shared && !this.noSharedTooltip || d.hide();\n        c.series.forEach(function (a) {\n          a.setState(\"\", !0);\n        });\n      },\n      setState: function (a, c) {\n        var d = this,\n            e = d.options,\n            f = d.graph,\n            g = e.inactiveOtherPoints,\n            h = e.states,\n            l = e.lineWidth,\n            m = e.opacity,\n            n = q(h[a || \"normal\"] && h[a || \"normal\"].animation, d.chart.options.chart.animation);\n        e = 0;\n        a = a || \"\";\n\n        if (d.state !== a && ([d.group, d.markerGroup, d.dataLabelsGroup].forEach(function (b) {\n          b && (d.state && b.removeClass(\"highcharts-series-\" + d.state), a && b.addClass(\"highcharts-series-\" + a));\n        }), d.state = a, !d.chart.styledMode)) {\n          if (h[a] && !1 === h[a].enabled) return;\n          a && (l = h[a].lineWidth || l + (h[a].lineWidthPlus || 0), m = q(h[a].opacity, m));\n          if (f && !f.dashstyle) for (h = {\n            \"stroke-width\": l\n          }, f.animate(h, n); d[\"zone-graph-\" + e];) d[\"zone-graph-\" + e].attr(h), e += 1;\n          g || [d.group, d.markerGroup, d.dataLabelsGroup, d.labelBySeries].forEach(function (a) {\n            a && a.animate({\n              opacity: m\n            }, n);\n          });\n        }\n\n        c && g && d.points && d.setAllPointsToState(a);\n      },\n      setAllPointsToState: function (a) {\n        this.points.forEach(function (c) {\n          c.setState && c.setState(a);\n        });\n      },\n      setVisible: function (a, c) {\n        var d = this,\n            e = d.chart,\n            f = d.legendItem,\n            g = e.options.chart.ignoreHiddenSeries,\n            h = d.visible;\n        var l = (d.visible = a = d.options.visible = d.userOptions.visible = \"undefined\" === typeof a ? !h : a) ? \"show\" : \"hide\";\n        [\"group\", \"dataLabelsGroup\", \"markerGroup\", \"tracker\", \"tt\"].forEach(function (a) {\n          if (d[a]) d[a][l]();\n        });\n        if (e.hoverSeries === d || (e.hoverPoint && e.hoverPoint.series) === d) d.onMouseOut();\n        f && e.legend.colorizeItem(d, a);\n        d.isDirty = !0;\n        d.options.stacking && e.series.forEach(function (a) {\n          a.options.stacking && a.visible && (a.isDirty = !0);\n        });\n        d.linkedSeries.forEach(function (c) {\n          c.setVisible(a, !1);\n        });\n        g && (e.isDirtyBox = !0);\n        J(d, l);\n        !1 !== c && e.redraw();\n      },\n      show: function () {\n        this.setVisible(!0);\n      },\n      hide: function () {\n        this.setVisible(!1);\n      },\n      select: function (a) {\n        this.selected = a = this.options.selected = \"undefined\" === typeof a ? !this.selected : a;\n        this.checkbox && (this.checkbox.checked = a);\n        J(this, a ? \"select\" : \"unselect\");\n      },\n      drawTracker: m.drawTrackerGraph\n    });\n  });\n  N(m, \"Core/Responsive.js\", [m[\"Core/Chart/Chart.js\"], m[\"Core/Utilities.js\"]], function (f, h) {\n    var m = h.find,\n        z = h.isArray,\n        F = h.isObject,\n        L = h.merge,\n        K = h.objectEach,\n        C = h.pick,\n        y = h.splat,\n        e = h.uniqueKey;\n\n    f.prototype.setResponsive = function (f, h) {\n      var v = this.options.responsive,\n          y = [],\n          n = this.currentResponsive;\n      !h && v && v.rules && v.rules.forEach(function (f) {\n        \"undefined\" === typeof f._id && (f._id = e());\n        this.matchResponsiveRule(f, y);\n      }, this);\n      h = L.apply(0, y.map(function (e) {\n        return m(v.rules, function (f) {\n          return f._id === e;\n        }).chartOptions;\n      }));\n      h.isResponsiveOptions = !0;\n      y = y.toString() || void 0;\n      y !== (n && n.ruleIds) && (n && this.update(n.undoOptions, f, !0), y ? (n = this.currentOptions(h), n.isResponsiveOptions = !0, this.currentResponsive = {\n        ruleIds: y,\n        mergedOptions: h,\n        undoOptions: n\n      }, this.update(h, f, !0)) : this.currentResponsive = void 0);\n    };\n\n    f.prototype.matchResponsiveRule = function (e, f) {\n      var h = e.condition;\n      (h.callback || function () {\n        return this.chartWidth <= C(h.maxWidth, Number.MAX_VALUE) && this.chartHeight <= C(h.maxHeight, Number.MAX_VALUE) && this.chartWidth >= C(h.minWidth, 0) && this.chartHeight >= C(h.minHeight, 0);\n      }).call(this) && f.push(e._id);\n    };\n\n    f.prototype.currentOptions = function (e) {\n      function f(e, l, m, v) {\n        var n;\n        K(e, function (d, e) {\n          if (!v && -1 < h.collectionsWithUpdate.indexOf(e)) for (d = y(d), m[e] = [], n = 0; n < Math.max(d.length, l[e].length); n++) l[e][n] && (void 0 === d[n] ? m[e][n] = l[e][n] : (m[e][n] = {}, f(d[n], l[e][n], m[e][n], v + 1)));else F(d) ? (m[e] = z(d) ? [] : {}, f(d, l[e] || {}, m[e], v + 1)) : m[e] = \"undefined\" === typeof l[e] ? null : l[e];\n        });\n      }\n\n      var h = this,\n          m = {};\n      f(e, this.options, m, 0);\n      return m;\n    };\n  });\n  N(m, \"masters/highcharts.src.js\", [m[\"Core/Globals.js\"]], function (f) {\n    return f;\n  });\n  m[\"masters/highcharts.src.js\"]._modules = m;\n  return m[\"masters/highcharts.src.js\"];\n}); //# sourceMappingURL=highcharts.js.map","map":null,"metadata":{},"sourceType":"script"}